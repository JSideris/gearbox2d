!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.p2=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var AABB = /** @class */ (function () {
    /**
     * Axis aligned bounding box class.
     * @class AABB
     * @constructor
     * @param {Object}  [options]
     * @param {Array}   [options.upperBound]
     * @param {Array}   [options.lowerBound]
     * @example
     *     var aabb = new AABB({
     *         upperBound: [1, 1],
     *         lowerBound: [-1, -1]
     *     });
     */
    function AABB(options) {
        this.tmp = vec2_1.default.create();
        options = options !== null && options !== void 0 ? options : {};
        /**
         * The lower bound of the bounding box.
         * @property lowerBound
         * @type {Array}
         */
        this.lowerBound = options.lowerBound ? vec2_1.default.clone(options.lowerBound) : vec2_1.default.create();
        /**
         * The upper bound of the bounding box.
         * @property upperBound
         * @type {Array}
         */
        this.upperBound = options.upperBound ? vec2_1.default.clone(options.upperBound) : vec2_1.default.create();
    }
    /**
     * Set the AABB bounds from a set of points, transformed by the given position and angle.
     * @method setFromPoints
     * @param {Array} points An array of vec2's.
     * @param {Array} position
     * @param {number} [angle=0]
     * @param {number} [skinSize=0] Some margin to be added to the AABB.
     */
    AABB.prototype.setFromPoints = function (points, position, angle, skinSize) {
        if (skinSize === void 0) { skinSize = 0; }
        var l = this.lowerBound, u = this.upperBound;
        angle = angle || 0;
        // Set to the first point
        if (angle !== 0) {
            vec2_1.default.rotate(l, points[0], angle);
        }
        else {
            vec2_1.default.copy(l, points[0]);
        }
        vec2_1.default.copy(u, l);
        // Compute cosines and sines just once
        var cosAngle = Math.cos(angle), sinAngle = Math.sin(angle);
        for (var i = 1; i < points.length; i++) {
            var p = points[i];
            if (angle !== 0) {
                var x = p[0], y = p[1];
                this.tmp[0] = cosAngle * x - sinAngle * y;
                this.tmp[1] = sinAngle * x + cosAngle * y;
                p = this.tmp;
            }
            for (var j = 0; j < 2; j++) {
                if (p[j] > u[j]) {
                    u[j] = p[j];
                }
                if (p[j] < l[j]) {
                    l[j] = p[j];
                }
            }
        }
        // Add offset
        if (position) {
            vec2_1.default.add(l, l, position);
            vec2_1.default.add(u, u, position);
        }
        if (skinSize) {
            l[0] -= skinSize;
            l[1] -= skinSize;
            u[0] += skinSize;
            u[1] += skinSize;
        }
    };
    /**
     * Copy bounds from an AABB to this AABB
     * @method copy
     * @param  {AABB} aabb
     */
    AABB.prototype.copy = function (aabb) {
        vec2_1.default.copy(this.lowerBound, aabb.lowerBound);
        vec2_1.default.copy(this.upperBound, aabb.upperBound);
    };
    /**
     * Extend this AABB so that it covers the given AABB too.
     * @method extend
     * @param  {AABB} aabb
     */
    AABB.prototype.extend = function (aabb) {
        var lower = this.lowerBound, upper = this.upperBound;
        // Loop over x and y
        var i = 2;
        while (i--) {
            // Extend lower bound
            var l = aabb.lowerBound[i];
            if (lower[i] > l) {
                lower[i] = l;
            }
            // Upper
            var u = aabb.upperBound[i];
            if (upper[i] < u) {
                upper[i] = u;
            }
        }
    };
    /**
     * Returns true if the given AABB overlaps this AABB.
     * @method overlaps
     * @param  {AABB} aabb
     * @return {Boolean}
     */
    AABB.prototype.overlaps = function (aabb) {
        var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
        //      l2        u2
        //      |---------|
        // |--------|
        // l1       u1
        return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&
            ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));
    };
    ;
    /**
     * @method containsPoint
     * @param  {Array} point
     * @return {boolean}
     */
    AABB.prototype.containsPoint = function (point) {
        var l = this.lowerBound, u = this.upperBound;
        return l[0] <= point[0] && point[0] <= u[0] && l[1] <= point[1] && point[1] <= u[1];
    };
    /**
     * Check if the AABB is hit by a ray.
     * @method overlapsRay
     * @param  {Ray} ray
     * @return {number} -1 if no hit, a number between 0 and 1 if hit, indicating the position between the "from" and "to" points.
     * @example
     *     var aabb = new AABB({
     *         upperBound: [1, 1],
     *         lowerBound: [-1, -1]
     *     });
     *     var ray = new Ray({
     *         from: [-2, 0],
     *         to: [0, 0]
     *     });
     *     var fraction = aabb.overlapsRay(ray); // fraction == 0.5
     */
    AABB.prototype.overlapsRay = function (ray) {
        // ray.direction is unit direction vector of ray
        var dirFracX = 1 / ray.direction[0];
        var dirFracY = 1 / ray.direction[1];
        // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner
        var from = ray.from;
        var lowerBound = this.lowerBound;
        var upperBound = this.upperBound;
        var t1 = (lowerBound[0] - from[0]) * dirFracX;
        var t2 = (upperBound[0] - from[0]) * dirFracX;
        var t3 = (lowerBound[1] - from[1]) * dirFracY;
        var t4 = (upperBound[1] - from[1]) * dirFracY;
        var tmin = Math.max(Math.min(t1, t2), Math.min(t3, t4));
        var tmax = Math.min(Math.max(t1, t2), Math.max(t3, t4));
        // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us
        if (tmax < 0) {
            //t = tmax;
            return -1;
        }
        // if tmin > tmax, ray doesn't intersect AABB
        if (tmin > tmax) {
            //t = tmax;
            return -1;
        }
        return tmin / ray.length;
    };
    return AABB;
}());
exports.default = AABB;

},{"../math/vec2":28}],2:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Body_1 = __importDefault(_dereq_("../objects/Body"));
// TODO: I think this is supposed to be abstract.
var Broadphase = /** @class */ (function () {
    /**
     * Base class for broadphase implementations. Don't use this class directly.
     * @class Broadphase
     * @constructor
     */
    function Broadphase(type) {
        /**
         * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().
         * @property result
         * @type {Array}
         */
        this.result = [];
        /**
         * The world to search for collision pairs in. To change it, use .setWorld()
         * @property world
         * @type {World}
         * @readOnly
         */
        this.world = null;
        /**
         * The bounding volume type to use in the broadphase algorithms. Should be set to Broadphase.AABB or Broadphase.BOUNDING_CIRCLE.
         * @property {Number} boundingVolumeType
         */
        this.boundingVolumeType = Broadphase.AABB;
        this.type = type || 1;
    }
    /**
     * Set the world that we are searching for collision pairs in.
     * @method setWorld
     * @param  {World} world
     */
    // TODO: move to constructor!
    Broadphase.prototype.setWorld = function (world) {
        this.world = world;
    };
    ;
    /*
     * Get all potential intersecting body pairs.
     * @method getCollisionPairs
     * @param  {World} world The world to search in.
     * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).
     */
    Broadphase.prototype.getCollisionPairs = function (world) {
        // I guess this should be overridden?
        // TODO: possible abstract method.
        return [];
    };
    ;
    /**
     * Check whether the bounding radius of two bodies overlap.
     * @method  boundingRadiusCheck
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Broadphase.boundingRadiusCheck = function (bodyA, bodyB) {
        var d2 = vec2_1.default.squaredDistance(bodyA.position, bodyB.position), r = bodyA.boundingRadius + bodyB.boundingRadius;
        return d2 <= r * r;
    };
    ;
    /**
     * Check whether the AABB of two bodies overlap.
     * @method  aabbCheck
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Broadphase.aabbCheck = function (bodyA, bodyB) {
        return bodyA.getAABB().overlaps(bodyB.getAABB());
    };
    ;
    /**
     * Check whether the bounding volumes of two bodies overlap.
     * @method  boundingVolumeCheck
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Broadphase.prototype.boundingVolumeCheck = function (bodyA, bodyB) {
        var result;
        switch (this.boundingVolumeType) {
            case Broadphase.BOUNDING_CIRCLE:
                result = Broadphase.boundingRadiusCheck(bodyA, bodyB);
                break;
            case Broadphase.AABB:
                result = Broadphase.aabbCheck(bodyA, bodyB);
                break;
            default:
                throw new Error('Bounding volume type not recognized: ' + this.boundingVolumeType);
        }
        return result;
    };
    ;
    /**
     * Check whether two bodies are allowed to collide at all.
     * @method  canCollide
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Broadphase.canCollide = function (bodyA, bodyB) {
        var KINEMATIC = Body_1.default.KINEMATIC;
        var STATIC = Body_1.default.STATIC;
        var typeA = bodyA.type;
        var typeB = bodyB.type;
        // Cannot collide static bodies
        if (typeA === STATIC && typeB === STATIC) {
            return false;
        }
        // Cannot collide static vs kinematic bodies
        if ((typeA === KINEMATIC && typeB === STATIC) ||
            (typeA === STATIC && typeB === KINEMATIC)) {
            return false;
        }
        // Cannot collide kinematic vs kinematic
        if (typeA === KINEMATIC && typeB === KINEMATIC) {
            return false;
        }
        // Cannot collide both sleeping bodies
        if (bodyA.sleepState === Body_1.default.SLEEPING && bodyB.sleepState === Body_1.default.SLEEPING) {
            return false;
        }
        // Cannot collide if one is static and the other is sleeping
        if ((bodyA.sleepState === Body_1.default.SLEEPING && typeB === STATIC) ||
            (bodyB.sleepState === Body_1.default.SLEEPING && typeA === STATIC)) {
            return false;
        }
        return true;
    };
    ;
    /**
     * Returns all the bodies within an AABB.
     * @method aabbQuery
     * @param  {World} world
     * @param  {AABB} aabb
     * @param {array} result An array to store resulting bodies in.
     * @return {array}
     */
    Broadphase.prototype.aabbQuery = function (world, aabb, result) {
        // To be implemented in subclasses
    };
    ;
    // Mode:
    Broadphase.NAIVE = 1;
    Broadphase.SAP = 2;
    // Bounding box:
    /**
     * Axis aligned bounding box type.
     * @static
     * @property {Number} AABB
     */
    Broadphase.AABB = 1;
    /**
     * Bounding circle type.
     * @static
     * @property {Number} BOUNDING_CIRCLE
     */
    Broadphase.BOUNDING_CIRCLE = 2;
    return Broadphase;
}());
exports.default = Broadphase;

},{"../math/vec2":28,"../objects/Body":29}],3:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var broadphase_1 = __importDefault(_dereq_("./broadphase"));
var NaiveBroadphase = /** @class */ (function (_super) {
    __extends(NaiveBroadphase, _super);
    /**
     * Naive broadphase implementation. Does N^2 tests.
     *
     * @class NaiveBroadphase
     * @constructor
     * @extends Broadphase
     */
    function NaiveBroadphase() {
        return _super.call(this, broadphase_1.default.NAIVE) || this;
    }
    /**
     * Get the colliding pairs
     * @method getCollisionPairs
     * @param  {World} world
     * @return {Array}
     */
    NaiveBroadphase.prototype.getCollisionPairs = function (world) {
        var bodies = world.bodies, result = this.result;
        result.length = 0;
        for (var i = 0, Ncolliding = bodies.length; i !== Ncolliding; i++) {
            var bi = bodies[i];
            for (var j = 0; j < i; j++) {
                var bj = bodies[j];
                if (broadphase_1.default.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                    result.push(bi);
                    result.push(bj);
                }
            }
        }
        return result;
    };
    ;
    /**
     * Returns all the bodies within an AABB.
     * @method aabbQuery
     * @param  {World} world
     * @param  {AABB} aabb
     * @param {array} result An array to store resulting bodies in.
     * @return {array}
     */
    NaiveBroadphase.prototype.aabbQuery = function (world, aabb, result) {
        result = result || [];
        var bodies = world.bodies;
        for (var i = 0; i < bodies.length; i++) {
            var b = bodies[i];
            if (b.aabbNeedsUpdate) {
                b.updateAABB();
            }
            if (b.aabb.overlaps(aabb)) {
                result.push(b);
            }
        }
        return result;
    };
    ;
    return NaiveBroadphase;
}(broadphase_1.default));
exports.default = NaiveBroadphase;

},{"./broadphase":2}],4:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var sub = vec2_1.default.subtract, add = vec2_1.default.add, dot = vec2_1.default.dot, rotate = vec2_1.default.rotate, normalize = vec2_1.default.normalize, copy = vec2_1.default.copy, scale = vec2_1.default.scale, squaredLength = vec2_1.default.squaredLength, createVec2 = vec2_1.default.create;
var Circle_1 = __importDefault(_dereq_("../shapes/Circle"));
var Convex_1 = __importDefault(_dereq_("../shapes/Convex"));
var Box_1 = __importDefault(_dereq_("../shapes/Box"));
var contact_equation_pool_1 = __importDefault(_dereq_("../utils/contact-equation-pool"));
var friction_equation_pool_1 = __importDefault(_dereq_("../utils/friction-equation-pool"));
var tuple_dictionary_1 = __importDefault(_dereq_("../utils/tuple-dictionary"));
var yAxis = vec2_1.default.fromValues(0, 1);
var tmp1 = createVec2(), tmp2 = createVec2(), tmp3 = createVec2(), tmp4 = createVec2(), tmp5 = createVec2(), tmp6 = createVec2(), tmp7 = createVec2(), tmp8 = createVec2(), tmp9 = createVec2(), tmp10 = createVec2(), tmp11 = createVec2(), tmp12 = createVec2(), tmp13 = createVec2(), tmp14 = createVec2(), tmp15 = createVec2(), tmpArray = [];
var findMaxSeparation_n = vec2_1.default.create();
var findMaxSeparation_v1 = vec2_1.default.create();
var findMaxSeparation_tmp = vec2_1.default.create();
var findMaxSeparation_tmp2 = vec2_1.default.create();
var findIncidentEdge_normal1 = vec2_1.default.create();
var collidePolygons_tempVec = vec2_1.default.create();
var collidePolygons_tmpVec = vec2_1.default.create();
var collidePolygons_localTangent = vec2_1.default.create();
var collidePolygons_localNormal = vec2_1.default.create();
var collidePolygons_planePoint = vec2_1.default.create();
var collidePolygons_tangent = vec2_1.default.create();
var collidePolygons_normal = vec2_1.default.create();
var collidePolygons_negativeTangent = vec2_1.default.create();
var collidePolygons_v11 = vec2_1.default.create();
var collidePolygons_v12 = vec2_1.default.create();
var collidePolygons_dist = vec2_1.default.create();
var collidePolygons_clipPoints1 = [vec2_1.default.create(), vec2_1.default.create()];
var collidePolygons_clipPoints2 = [vec2_1.default.create(), vec2_1.default.create()];
var collidePolygons_incidentEdge = [vec2_1.default.create(), vec2_1.default.create()];
var pic_localPoint = createVec2(), pic_r0 = createVec2(), pic_r1 = createVec2();
var bodiesOverlap_shapePositionA = createVec2(), bodiesOverlap_shapePositionB = createVec2();
var capsuleCapsule_tempVec1 = createVec2(), capsuleCapsule_tempVec2 = createVec2();
var convexCapsule_tempVec = createVec2();
var planeCapsule_tmp1 = createVec2(), planeCapsule_tmp2 = createVec2();
var circleHeightfield_candidate = createVec2(), circleHeightfield_dist = createVec2(), circleHeightfield_v0 = createVec2(), circleHeightfield_v1 = createVec2(), circleHeightfield_minCandidate = createVec2(), circleHeightfield_worldNormal = createVec2(), circleHeightfield_minCandidateNormal = createVec2();
var convexHeightfield_v0 = createVec2(), convexHeightfield_v1 = createVec2(), convexHeightfield_tilePos = createVec2(), convexHeightfield_tempConvexShape = new Convex_1.default(undefined, [createVec2(), createVec2(), createVec2(), createVec2()]);
function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape) {
    var capsuleRadius = capsuleShape.radius;
    var halfCapsuleLength = capsuleShape.length * 0.5;
    var verts = convexShape.vertices;
    vec2_1.default.set(verts[0], -halfCapsuleLength, -capsuleRadius);
    vec2_1.default.set(verts[1], halfCapsuleLength, -capsuleRadius);
    vec2_1.default.set(verts[2], halfCapsuleLength, capsuleRadius);
    vec2_1.default.set(verts[3], -halfCapsuleLength, capsuleRadius);
}
/*
* Check if a point is in a polygon
*/
function pointInConvex(worldPoint, convexShape, convexOffset, convexAngle) {
    var localPoint = pic_localPoint, r0 = pic_r0, r1 = pic_r1, verts = convexShape.vertices, lastCross = null;
    vec2_1.default.toLocalFrame(localPoint, worldPoint, convexOffset, convexAngle);
    for (var i = 0, numVerts = verts.length; i !== numVerts + 1; i++) {
        var v0 = verts[i % numVerts], v1 = verts[(i + 1) % numVerts];
        sub(r0, v0, localPoint);
        sub(r1, v1, localPoint);
        var cross = vec2_1.default.crossLength(r0, r1);
        if (lastCross === null) {
            lastCross = cross;
        }
        // If we got a different sign of the distance vector, the point is out of the polygon
        if (cross * lastCross < 0) {
            return false;
        }
        lastCross = cross;
    }
    return true;
}
/*
* Check if a point is in a polygon
*/
function pointInConvexLocal(localPoint, convexShape) {
    var r0 = pic_r0, r1 = pic_r1, verts = convexShape.vertices, lastCross = null, numVerts = verts.length;
    for (var i = 0; i < numVerts + 1; i++) {
        var v0 = verts[i % numVerts], v1 = verts[(i + 1) % numVerts];
        sub(r0, v0, localPoint);
        sub(r1, v1, localPoint);
        var cross = vec2_1.default.crossLength(r0, r1);
        if (lastCross === null) {
            lastCross = cross;
        }
        // If we got a different sign of the distance vector, the point is out of the polygon
        if (cross * lastCross < 0) {
            return false;
        }
        lastCross = cross;
    }
    return true;
}
function addSub(out, a, b, c) {
    out[0] = a[0] + b[0] - c[0];
    out[1] = a[1] + b[1] - c[1];
}
function findMaxSeparation(maxSeparationOut, poly1, position1, angle1, poly2, position2, angle2) {
    // Find the max separation between poly1 and poly2 using edge normals from poly1.
    var count1 = poly1.vertices.length;
    var count2 = poly2.vertices.length;
    var n1s = poly1.normals;
    var v1s = poly1.vertices;
    var v2s = poly2.vertices;
    var n = findMaxSeparation_n;
    var v1 = findMaxSeparation_v1;
    var tmp = findMaxSeparation_tmp;
    var tmp2 = findMaxSeparation_tmp2;
    var angle = angle1 - angle2;
    var bestIndex = 0;
    var maxSeparation = -Infinity;
    for (var i = 0; i < count1; ++i) {
        // Get poly1 normal in frame2.
        vec2_1.default.rotate(n, n1s[i], angle);
        // Get poly1 vertex in frame2
        vec2_1.default.toGlobalFrame(tmp2, v1s[i], position1, angle1);
        vec2_1.default.toLocalFrame(v1, tmp2, position2, angle2);
        // Find deepest point for normal i.
        var si = Infinity;
        for (var j = 0; j < count2; ++j) {
            vec2_1.default.subtract(tmp, v2s[j], v1);
            var sij = vec2_1.default.dot(n, tmp);
            if (sij < si) {
                si = sij;
            }
        }
        if (si > maxSeparation) {
            maxSeparation = si;
            bestIndex = i;
        }
    }
    // Use a vec2 for storing the float value and always return int, for perf
    maxSeparationOut[0] = maxSeparation;
    return bestIndex;
}
function findIncidentEdge(clipVerticesOut, poly1, position1, angle1, edge1, poly2, position2, angle2) {
    var normals1 = poly1.normals;
    var count2 = poly2.vertices.length;
    var vertices2 = poly2.vertices;
    var normals2 = poly2.normals;
    // Get the normal of the reference edge in poly2's frame.
    var normal1 = findIncidentEdge_normal1;
    vec2_1.default.rotate(normal1, normals1[edge1], angle1 - angle2);
    // Find the incident edge on poly2.
    var index = 0;
    var minDot = Infinity;
    for (var i = 0; i < count2; ++i) {
        var dot_1 = vec2_1.default.dot(normal1, normals2[i]);
        if (dot_1 < minDot) {
            minDot = dot_1;
            index = i;
        }
    }
    // Build the clip vertices for the incident edge.
    var i1 = index;
    var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
    vec2_1.default.toGlobalFrame(clipVerticesOut[0], vertices2[i1], position2, angle2);
    vec2_1.default.toGlobalFrame(clipVerticesOut[1], vertices2[i2], position2, angle2);
}
function clipSegmentToLine(vOut, vIn, normal, offset) {
    // Start with no output points
    var numOut = 0;
    // Calculate the distance of end points to the line
    var distance0 = vec2_1.default.dot(normal, vIn[0]) - offset;
    var distance1 = vec2_1.default.dot(normal, vIn[1]) - offset;
    // If the points are behind the plane
    if (distance0 <= 0.0) {
        vec2_1.default.copy(vOut[numOut++], vIn[0]);
    }
    if (distance1 <= 0.0) {
        vec2_1.default.copy(vOut[numOut++], vIn[1]);
    }
    // If the points are on different sides of the plane
    if (distance0 * distance1 < 0.0) {
        // Find intersection point of edge and plane
        var interp = distance0 / (distance0 - distance1);
        var v = vOut[numOut];
        vec2_1.default.subtract(v, vIn[1], vIn[0]);
        vec2_1.default.scale(v, v, interp);
        vec2_1.default.add(v, v, vIn[0]);
        ++numOut;
    }
    return numOut;
}
var Narrowphase = /** @class */ (function () {
    /**
     * Narrowphase. Creates contacts and friction given shapes and transforms.
     * @class Narrowphase
     * @constructor
     */
    function Narrowphase() {
        /**
         * @property contactEquations
         * @type {Array}
         */
        this.contactEquations = [];
        /**
         * @property frictionEquations
         * @type {Array}
         */
        this.frictionEquations = [];
        /**
         * Whether to make friction equations in the upcoming contacts.
         * @property enableFriction
         * @type {Boolean}
         */
        this.enableFriction = true;
        /**
         * Whether to make equations enabled in upcoming contacts.
         * @property enabledEquations
         * @type {Boolean}
         */
        this.enabledEquations = true;
        /**
         * The friction slip force to use when creating friction equations.
         * @property slipForce
         * @type {Number}
         */
        this.slipForce = 10.0;
        /**
         * Keeps track of the allocated ContactEquations.
         * @property {ContactEquationPool} contactEquationPool
         *
         * @example
         *
         *     // Allocate a few equations before starting the simulation.
         *     // This way, no contact objects need to be created on the fly in the game loop.
         *     world.narrowphase.contactEquationPool.resize(1024);
         *     world.narrowphase.frictionEquationPool.resize(1024);
         */
        this.contactEquationPool = new contact_equation_pool_1.default({ size: 32 });
        /**
         * Keeps track of the allocated ContactEquations.
         * @property {FrictionEquationPool} frictionEquationPool
         */
        this.frictionEquationPool = new friction_equation_pool_1.default({ size: 64 });
        /**
         * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.
         * @property enableFrictionReduction
         * @type {Boolean}
         * @deprecated This flag will be removed when the feature is stable enough.
         * @default true
         */
        this.enableFrictionReduction = true;
        /**
         * Keeps track of the colliding bodies last step.
         * @private
         * @property collidingBodiesLastStep
         * @type {TupleDictionary}
         */
        this.collidingBodiesLastStep = new tuple_dictionary_1.default();
        /**
         * @property currentContactMaterial
         * @type {ContactMaterial}
         */
        this.currentContactMaterial = null;
    }
    /**
     * @method bodiesOverlap
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @param  {boolean} [checkCollisionMasks=false]
     * @return {Boolean}
     */
    Narrowphase.prototype.bodiesOverlap = function (bodyA, bodyB, checkCollisionMasks) {
        if (checkCollisionMasks === void 0) { checkCollisionMasks = false; }
        var shapePositionA = bodiesOverlap_shapePositionA;
        var shapePositionB = bodiesOverlap_shapePositionB;
        // Loop over all shapes of bodyA
        for (var k = 0, Nshapesi = bodyA.shapes.length; k !== Nshapesi; k++) {
            var shapeA = bodyA.shapes[k];
            // All shapes of body j
            for (var l = 0, Nshapesj = bodyB.shapes.length; l !== Nshapesj; l++) {
                var shapeB = bodyB.shapes[l];
                // Check collision groups and masks
                if (checkCollisionMasks && !((shapeA.collisionGroup & shapeB.collisionMask) !== 0 && (shapeB.collisionGroup & shapeA.collisionMask) !== 0)) {
                    return false;
                }
                bodyA.toWorldFrame(shapePositionA, shapeA.position);
                bodyB.toWorldFrame(shapePositionB, shapeB.position);
                var result = this.testContact(bodyA, shapeA, shapePositionA, bodyB, shapeB, shapePositionB, true);
                if (result)
                    return true;
            }
        }
        return false;
    };
    ;
    /**
     * Check if the bodies were in contact since the last reset().
     * @method collidedLastStep
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Narrowphase.prototype.collidedLastStep = function (bodyA, bodyB) {
        var id1 = bodyA.id | 0, id2 = bodyB.id | 0;
        return !!this.collidingBodiesLastStep.get(id1, id2);
    };
    ;
    /**
     * Throws away the old equations and gets ready to create new
     * @method reset
     */
    Narrowphase.prototype.reset = function () {
        this.collidingBodiesLastStep.reset();
        var eqs = this.contactEquations;
        var l = eqs.length;
        while (l--) {
            var eq = eqs[l], id1 = eq.bodyA.id, id2 = eq.bodyB.id;
            this.collidingBodiesLastStep.set(id1, id2, 1);
        }
        var ce = this.contactEquations, fe = this.frictionEquations;
        for (var i = 0; i < ce.length; i++) {
            this.contactEquationPool.release(ce[i]);
        }
        for (var i = 0; i < fe.length; i++) {
            this.frictionEquationPool.release(fe[i]);
        }
        // Reset
        this.contactEquations.length = this.frictionEquations.length = 0;
    };
    ;
    /**
     * Creates a ContactEquation, either by reusing an existing object or creating a new one.
     * @method createContactEquation
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {ContactEquation}
     */
    Narrowphase.prototype.createContactEquation = function (bodyA, bodyB, shapeA, shapeB) {
        var c = this.contactEquationPool.get();
        var currentContactMaterial = this.currentContactMaterial;
        c.bodyA = bodyA;
        c.bodyB = bodyB;
        c.shapeA = shapeA;
        c.shapeB = shapeB;
        c.enabled = this.enabledEquations;
        c.firstImpact = !this.collidedLastStep(bodyA, bodyB);
        c.restitution = currentContactMaterial.restitution;
        c.stiffness = currentContactMaterial.stiffness;
        c.relaxation = currentContactMaterial.relaxation;
        c.offset = currentContactMaterial.contactSkinSize;
        c.needsUpdate = true;
        return c;
    };
    ;
    /**
     * Creates a FrictionEquation, either by reusing an existing object or creating a new one.
     * @method createFrictionEquation
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {FrictionEquation}
     */
    Narrowphase.prototype.createFrictionEquation = function (bodyA, bodyB, shapeA, shapeB) {
        var c = this.frictionEquationPool.get();
        var currentContactMaterial = this.currentContactMaterial;
        c.bodyA = bodyA;
        c.bodyB = bodyB;
        c.shapeA = shapeA;
        c.shapeB = shapeB;
        c.setSlipForce(this.slipForce);
        c.enabled = this.enabledEquations;
        c.frictionCoefficient = currentContactMaterial.friction;
        c.relativeVelocity = currentContactMaterial.surfaceVelocity;
        c.stiffness = currentContactMaterial.frictionStiffness;
        c.relaxation = currentContactMaterial.frictionRelaxation;
        c.needsUpdate = true;
        c.contactEquations.length = 0;
        return c;
    };
    ;
    /**
     * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.
     * @method createFrictionFromContact
     * @param  {ContactEquation} contactEquation
     * @return {FrictionEquation}
     */
    Narrowphase.prototype.createFrictionFromContact = function (c) {
        var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
        copy(eq.contactPointA, c.contactPointA);
        copy(eq.contactPointB, c.contactPointB);
        vec2_1.default.rotate90cw(eq.t, c.normalA);
        eq.contactEquations.push(c);
        return eq;
    };
    ;
    // Take the average N latest contact point on the plane.
    Narrowphase.prototype.createFrictionFromAverage = function (numContacts) {
        var c = this.contactEquations[this.contactEquations.length - 1];
        var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
        var bodyA = c.bodyA;
        vec2_1.default.set(eq.contactPointA, 0, 0);
        vec2_1.default.set(eq.contactPointB, 0, 0);
        vec2_1.default.set(eq.t, 0, 0);
        for (var i = 0; i < numContacts; i++) {
            c = this.contactEquations[this.contactEquations.length - 1 - i];
            if (c.bodyA === bodyA) {
                add(eq.t, eq.t, c.normalA);
                add(eq.contactPointA, eq.contactPointA, c.contactPointA);
                add(eq.contactPointB, eq.contactPointB, c.contactPointB);
            }
            else {
                sub(eq.t, eq.t, c.normalA);
                add(eq.contactPointA, eq.contactPointA, c.contactPointB);
                add(eq.contactPointB, eq.contactPointB, c.contactPointA);
            }
            eq.contactEquations.push(c);
        }
        var invNumContacts = 1 / numContacts;
        scale(eq.contactPointA, eq.contactPointA, invNumContacts);
        scale(eq.contactPointB, eq.contactPointB, invNumContacts);
        normalize(eq.t, eq.t);
        vec2_1.default.rotate90cw(eq.t, eq.t);
        return eq;
    };
    ;
    Narrowphase.prototype.testContact = function (bodyA, shapeA, offsetA, bodyB, shapeB, offsetB, justTest
    // meta?: {
    // 	radiusA?: f32,
    // 	radiusB?: f32
    // }
    ) {
        var result = 0;
        if (shapeA.type > shapeB.type) {
            var bTmp = bodyB;
            bodyB = bodyA;
            bodyA = bTmp;
            var sTmp = shapeB;
            shapeB = shapeA;
            shapeA = sTmp;
            var pTmp = offsetB;
            offsetB = offsetA;
            offsetA = pTmp;
        }
        switch (shapeA.type | shapeB.type) {
            case 1: { // Circle/circle
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleCircle(bodyA, sa, offsetA, bodyB, sb, offsetB, justTest, sa.radius, sb.radius);
                break;
            }
            case 3: { // Particle/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleParticle(bodyA, sa, offsetA, bodyB, sb, offsetB, justTest);
                break;
            }
            case 5: { // Plane/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circlePlane(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 33: // Box/circle.
            case 9: { // Convex/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleConvex(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest, sa.radius);
                break;
            }
            case 17: { // Line/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleLine(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest, 0, sa.radius);
                break;
            }
            case 65: { // Capsule/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleCapsule(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 129: { // Heightfield/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleHeightfield(bodyA, sa, offsetA, bodyB, sb, offsetB, justTest, sa.radius);
                break;
            }
            case 6: { // Plane/particle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.particlePlane(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 34: // Box/particle.
            case 10: { // Convex/particle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.particleConvex(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 10: { // Capsule/particle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.particleCapsule(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 36: // Box/plane.
            case 12: { // Convex/plane.
                var sa = shapeA;
                var sb = shapeB;
                result = this.planeConvex(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 20: { // Line/plane.
                var sa = shapeA;
                var sb = shapeB;
                result = this.planeLine(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 68: { // Capsule/plane.
                var sa = shapeA;
                var sb = shapeB;
                result = this.planeCapsule(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 40: // Box/convex.
            case 8: { // Convex/convex.
                var sa = shapeA;
                var sb = shapeB;
                result = this.convexConvex(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 24: { // Line/convex.
                var sa = shapeA;
                var sb = shapeB;
                // NOT SUPPORTED!
                // result = this.convexLine(bodyA, sa, offsetA, bodyA.angle + sa.angle,
                // 	bodyB, sb, offsetB, bodyB.angle + sb.angle, 
                // 	justTest);
                break;
            }
            case 72: { // Capsule/convex.
                var sa = shapeA;
                var sb = shapeB;
                result = this.convexCapsule(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 136: { // Heightfield/convex.
                var sa = shapeA;
                var sb = shapeB;
                result = this.convexHeightfield(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, justTest);
                break;
            }
            case 16: { // Line/line.
                var sa = shapeA;
                var sb = shapeB;
                // NOT SUPPORTED!
                // result = this.lineLine(bodyA, sa, shapePositionA, bodyA.angle + sa.angle,
                // 	bodyB, sb, offsetB, bodyB.angle + sb.angle,
                // 	justTest);
                break;
            }
            case 48: { // Box/line.
                var sa = shapeA;
                var sb = shapeB;
                // NOT SUPPORTED!
                // result = this.lineBox(bodyA, sa, shapePositionA, bodyA.angle + sa.angle,
                // 	bodyB, sb, offsetB, bodyB.angle + sb.angle,
                // 	justTest);
                break;
            }
            case 80: { // Capsule/line.
                var sa = shapeA;
                var sb = shapeB;
                // NOT SUPPORTED!
                // result = this.lineCapsule(bodyA, sa, shapePositionA, bodyA.angle + sa.angle,
                // 	bodyB, sb, offsetB, bodyB.angle + sb.angle,
                // 	justTest);
                break;
            }
            case 64: { // Capsule/capsule.
                var sa = shapeA;
                var sb = shapeB;
                result = this.capsuleCapsule(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
        }
        return result;
    };
    /**
     * Convex/line narrowphase
     * @method convexLine
     * @param  {Body}       convexBody
     * @param  {Convex}     convexShape
     * @param  {Array}      convexOffset
     * @param  {Number}     convexAngle
     * @param  {Body}       lineBody
     * @param  {Line}       lineShape
     * @param  {Array}      lineOffset
     * @param  {Number}     lineAngle
     * @param {boolean}     justTest
     * @return {number}
     * @todo Implement me!
     */
    //Narrowphase.prototype[Shape.CONVEX | Shape.LINE] =
    Narrowphase.prototype.convexLine = function (
    /*
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest
    */
    ) {
        // TODO
        return 0;
    };
    ;
    /**
     * Line/box narrowphase
     * @method lineBox
     * @param  {Body}       lineBody
     * @param  {Line}       lineShape
     * @param  {Array}      lineOffset
     * @param  {Number}     lineAngle
     * @param  {Body}       boxBody
     * @param  {Box}  boxShape
     * @param  {Array}      boxOffset
     * @param  {Number}     boxAngle
     * @param  {Boolean}    justTest
     * @return {number}
     * @todo Implement me!
     */
    //Narrowphase.prototype[Shape.LINE | Shape.BOX] =
    Narrowphase.prototype.lineBox = function (
    /*
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    boxBody,
    boxShape,
    boxOffset,
    boxAngle,
    justTest
    */
    ) {
        // TODO
        return 0;
    };
    ;
    /**
     * Convex/capsule narrowphase
     * @method convexCapsule
     * @param  {Body}       convexBody
     * @param  {Convex}     convexShape
     * @param  {Array}      convexPosition
     * @param  {Number}     convexAngle
     * @param  {Body}       capsuleBody
     * @param  {Capsule}    capsuleShape
     * @param  {Array}      capsulePosition
     * @param  {Number}     capsuleAngle
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CONVEX | Shape.CAPSULE] =
    //Narrowphase.prototype[Shape.BOX | Shape.CAPSULE] =
    Narrowphase.prototype.convexCapsule = function (convexBody, convexShape, convexPosition, convexAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
        var convexCapsule_tempRect = new Box_1.default({ width: 1, height: 1 });
        // Check the circles
        // Add offsets!
        var circlePos = convexCapsule_tempVec;
        var halfLength = capsuleShape.length / 2;
        vec2_1.default.set(circlePos, halfLength, 0);
        vec2_1.default.toGlobalFrame(circlePos, circlePos, capsulePosition, capsuleAngle);
        var result1 = this.circleConvex(capsuleBody, capsuleShape, circlePos, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
        vec2_1.default.set(circlePos, -halfLength, 0);
        vec2_1.default.toGlobalFrame(circlePos, circlePos, capsulePosition, capsuleAngle);
        var result2 = this.circleConvex(capsuleBody, capsuleShape, circlePos, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
        if (justTest && (result1 + result2) !== 0) {
            return 1;
        }
        // Check center rect
        var r = convexCapsule_tempRect;
        setConvexToCapsuleShapeMiddle(r, capsuleShape);
        var result = this.convexConvex(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, r, capsulePosition, capsuleAngle, justTest);
        return result + result1 + result2;
    };
    ;
    /**
     * Capsule/line narrowphase
     * @method lineCapsule
     * @param  {Body}       lineBody
     * @param  {Line}       lineShape
     * @param  {Array}      linePosition
     * @param  {Number}     lineAngle
     * @param  {Body}       capsuleBody
     * @param  {Capsule}    capsuleShape
     * @param  {Array}      capsulePosition
     * @param  {Number}     capsuleAngle
     * @return {number}
     * @todo Implement me!
     */
    //Narrowphase.prototype[Shape.LINE | Shape.CAPSULE] =
    Narrowphase.prototype.lineCapsule = function (
    /*
    lineBody,
    lineShape,
    linePosition,
    lineAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
    */
    ) {
        // TODO
        return 0;
    };
    ;
    /**
     * Capsule/capsule narrowphase
     * @method capsuleCapsule
     * @param  {Body}       bi
     * @param  {Capsule}    si
     * @param  {Array}      xi
     * @param  {Number}     ai
     * @param  {Body}       bj
     * @param  {Capsule}    sj
     * @param  {Array}      xj
     * @param  {Number}     aj
     */
    //Narrowphase.prototype[Shape.CAPSULE] =
    Narrowphase.prototype.capsuleCapsule = function (bi, si, xi, ai, bj, sj, xj, aj, justTest) {
        throw "Capsule-capsule collisions are not currently supported.";
        return 0;
        // let capsuleCapsule_tempRect1 = new Box({ width: 1, height: 1 });
        // let enableFrictionBefore: boolean = false;
        // // Check the circles
        // // Add offsets!
        // let circlePosi = capsuleCapsule_tempVec1,
        // 	circlePosj = capsuleCapsule_tempVec2;
        // let numContacts = 0;
        // // Need 4 circle checks, between all
        // for(let i=0; i<2; i++){
        // 	vec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);
        // 	vec2.toGlobalFrame(circlePosi, circlePosi, xi, ai);
        // 	for(let j=0; j<2; j++){
        // 		vec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);
        // 		vec2.toGlobalFrame(circlePosj, circlePosj, xj, aj);
        // 		// Temporarily turn off friction
        // 		if(this.enableFrictionReduction){
        // 			enableFrictionBefore = this.enableFriction;
        // 			this.enableFriction = false;
        // 		}
        // 		let result = this.circleCircle(bi,si,circlePosi, bj,sj,circlePosj, justTest, si.radius, sj.radius);
        // 		if(this.enableFrictionReduction){
        // 			this.enableFriction = enableFrictionBefore;
        // 		}
        // 		if(justTest && result !== 0){
        // 			return 1;
        // 		}
        // 		numContacts += result;
        // 	}
        // }
        // if(this.enableFrictionReduction){
        // 	// Temporarily turn off friction
        // 	enableFrictionBefore = this.enableFriction;
        // 	this.enableFriction = false;
        // }
        // // Check circles against the center boxs
        // let rect = capsuleCapsule_tempRect1;
        // setConvexToCapsuleShapeMiddle(rect,si);
        // let result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);
        // if(this.enableFrictionReduction){
        // 	this.enableFriction = enableFrictionBefore;
        // }
        // if(justTest && result1 !== 0){
        // 	return 1;
        // }
        // numContacts += result1;
        // if(this.enableFrictionReduction){
        // 	// Temporarily turn off friction
        // 	let enableFrictionBefore = this.enableFriction;
        // 	this.enableFriction = false;
        // }
        // setConvexToCapsuleShapeMiddle(rect,sj);
        // let result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);
        // if(this.enableFrictionReduction){
        // 	this.enableFriction = enableFrictionBefore;
        // }
        // if(justTest && result2 !== 0){
        // 	return 1;
        // }
        // numContacts += result2;
        // if(this.enableFrictionReduction){
        // 	if(numContacts && this.enableFriction){
        // 		this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        // 	}
        // }
        // return numContacts;
    };
    ;
    /**
     * Line/line narrowphase
     * @method lineLine
     * @param  {Body}       bodyA
     * @param  {Line}       shapeA
     * @param  {Array}      positionA
     * @param  {Number}     angleA
     * @param  {Body}       bodyB
     * @param  {Line}       shapeB
     * @param  {Array}      positionB
     * @param  {Number}     angleB
     * @return {number}
     * @todo Implement me!
     */
    //Narrowphase.prototype[Shape.LINE] =
    Narrowphase.prototype.lineLine = function (
    /* bodyA,
        shapeA,
        positionA,
        angleA,
        bodyB,
        shapeB,
        positionB,
        angleB,
        justTest*/
    ) {
        // TODO
        return 0;
    };
    ;
    /**
     * Plane/line Narrowphase
     * @method planeLine
     * @param  {Body}   planeBody
     * @param  {Plane}  planeShape
     * @param  {Array}  planeOffset
     * @param  {Number} planeAngle
     * @param  {Body}   lineBody
     * @param  {Line}   lineShape
     * @param  {Array}  lineOffset
     * @param  {Number} lineAngle
     */
    //Narrowphase.prototype[Shape.PLANE | Shape.LINE] =
    Narrowphase.prototype.planeLine = function (planeBody, planeShape, planeOffset, planeAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
        var worldVertex0 = tmp1, worldVertex1 = tmp2, worldVertex01 = tmp3, worldVertex11 = tmp4, worldEdge = tmp5, worldEdgeUnit = tmp6, dist = tmp7, worldNormal = tmp8, worldTangent = tmp9, verts = tmpArray, numContacts = 0;
        // Get start and end points
        vec2_1.default.set(worldVertex0, -lineShape.length / 2, 0);
        vec2_1.default.set(worldVertex1, lineShape.length / 2, 0);
        // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
        vec2_1.default.toGlobalFrame(worldVertex01, worldVertex0, lineOffset, lineAngle);
        vec2_1.default.toGlobalFrame(worldVertex11, worldVertex1, lineOffset, lineAngle);
        copy(worldVertex0, worldVertex01);
        copy(worldVertex1, worldVertex11);
        // Get vector along the line
        sub(worldEdge, worldVertex1, worldVertex0);
        normalize(worldEdgeUnit, worldEdge);
        // Get tangent to the edge.
        vec2_1.default.rotate90cw(worldTangent, worldEdgeUnit);
        rotate(worldNormal, yAxis, planeAngle);
        // Check line ends
        verts[0] = worldVertex0;
        verts[1] = worldVertex1;
        for (var i = 0; i < verts.length; i++) {
            var v = verts[i];
            sub(dist, v, planeOffset);
            var d = dot(dist, worldNormal);
            if (d < 0) {
                if (justTest) {
                    return 1;
                }
                var c = this.createContactEquation(planeBody, lineBody, planeShape, lineShape);
                numContacts++;
                copy(c.normalA, worldNormal);
                normalize(c.normalA, c.normalA);
                // distance vector along plane normal
                scale(dist, worldNormal, d);
                // Vector from plane center to contact
                sub(c.contactPointA, v, dist);
                sub(c.contactPointA, c.contactPointA, planeBody.position);
                // From line center to contact
                sub(c.contactPointB, v, lineOffset);
                add(c.contactPointB, c.contactPointB, lineOffset);
                sub(c.contactPointB, c.contactPointB, lineBody.position);
                this.contactEquations.push(c);
                if (!this.enableFrictionReduction) {
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
        if (justTest) {
            return 0;
        }
        if (!this.enableFrictionReduction) {
            if (numContacts && this.enableFriction) {
                this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
            }
        }
        return numContacts;
    };
    ;
    //Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =
    Narrowphase.prototype.particleCapsule = function (particleBody, particleShape, particlePosition, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
        return this.circleLine(particleBody, particleShape, particlePosition, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest, capsuleShape.radius, 0);
    };
    ;
    /**
     * Circle/line Narrowphase
     * @method circleLine
     * @param  {Body} circleBody
     * @param  {Circle} circleShape
     * @param  {Array} circleOffset
     * @param  {Body} lineBody
     * @param  {Line} lineShape
     * @param  {Array} lineOffset
     * @param  {Number} lineAngle
     * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.
     * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.
     * @param {Number} circleRadius If set, this value overrides the circle shape radius.
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] =
    Narrowphase.prototype.circleLine = function (circleBody, circleShape, circleOffset, 
    //circleAngle: f32,
    lineBody, lineShape, lineOffset, lineAngle, justTest, lineRadius, circleRadius) {
        lineRadius = lineRadius !== null && lineRadius !== void 0 ? lineRadius : 0;
        var orthoDist = tmp1;
        var lineToCircleOrthoUnit = tmp2;
        var projectedPoint = tmp3;
        var centerDist = tmp4;
        var worldTangent = tmp5;
        var worldEdge = tmp6;
        var worldEdgeUnit = tmp7;
        var worldVertex0 = tmp8;
        var worldVertex1 = tmp9;
        var worldVertex01 = tmp10;
        var worldVertex11 = tmp11;
        var dist = tmp12;
        var lineToCircle = tmp13;
        var lineEndToLineRadius = tmp14;
        var verts = tmpArray;
        var halfLineLength = lineShape.length / 2;
        // Get start and end points
        vec2_1.default.set(worldVertex0, -halfLineLength, 0);
        vec2_1.default.set(worldVertex1, halfLineLength, 0);
        // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
        vec2_1.default.toGlobalFrame(worldVertex01, worldVertex0, lineOffset, lineAngle);
        vec2_1.default.toGlobalFrame(worldVertex11, worldVertex1, lineOffset, lineAngle);
        copy(worldVertex0, worldVertex01);
        copy(worldVertex1, worldVertex11);
        // Get vector along the line
        sub(worldEdge, worldVertex1, worldVertex0);
        normalize(worldEdgeUnit, worldEdge);
        // Get tangent to the edge.
        vec2_1.default.rotate90cw(worldTangent, worldEdgeUnit);
        // Check distance from the plane spanned by the edge vs the circle
        sub(dist, circleOffset, worldVertex0);
        var d = dot(dist, worldTangent); // Distance from center of line to circle center
        sub(centerDist, worldVertex0, lineOffset);
        sub(lineToCircle, circleOffset, lineOffset);
        var radiusSum = circleRadius + lineRadius;
        if (Math.abs(d) < radiusSum) {
            // Now project the circle onto the edge
            scale(orthoDist, worldTangent, d);
            sub(projectedPoint, circleOffset, orthoDist);
            // Add the missing line radius
            scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
            normalize(lineToCircleOrthoUnit, lineToCircleOrthoUnit);
            scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
            add(projectedPoint, projectedPoint, lineToCircleOrthoUnit);
            // Check if the point is within the edge span
            var pos = dot(worldEdgeUnit, projectedPoint);
            var pos0 = dot(worldEdgeUnit, worldVertex0);
            var pos1 = dot(worldEdgeUnit, worldVertex1);
            if (pos > pos0 && pos < pos1) {
                // We got contact!
                if (justTest) {
                    return 1;
                }
                var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                scale(c.normalA, orthoDist, -1);
                normalize(c.normalA, c.normalA);
                scale(c.contactPointA, c.normalA, circleRadius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);
                sub(c.contactPointB, projectedPoint, lineOffset);
                add(c.contactPointB, c.contactPointB, lineOffset);
                sub(c.contactPointB, c.contactPointB, lineBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            }
        }
        // Add corner
        verts[0] = worldVertex0;
        verts[1] = worldVertex1;
        for (var i = 0; i < verts.length; i++) {
            var v = verts[i];
            sub(dist, v, circleOffset);
            if (squaredLength(dist) < Math.pow(radiusSum, 2)) {
                if (justTest) {
                    return 1;
                }
                var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                copy(c.normalA, dist);
                normalize(c.normalA, c.normalA);
                // Vector from circle to contact point is the normal times the circle radius
                scale(c.contactPointA, c.normalA, circleRadius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);
                sub(c.contactPointB, v, lineOffset);
                scale(lineEndToLineRadius, c.normalA, -lineRadius);
                add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
                add(c.contactPointB, c.contactPointB, lineOffset);
                sub(c.contactPointB, c.contactPointB, lineBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            }
        }
        return 0;
    };
    ;
    /**
     * Circle/capsule Narrowphase
     * @method circleCapsule
     * @param  {Body}   bi
     * @param  {Circle} si
     * @param  {Array}  xi
     * @param  {Body}   bj
     * @param  {Line}   sj
     * @param  {Array}  xj
     * @param  {Number} aj
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =
    Narrowphase.prototype.circleCapsule = function (bi, si, xi, bj, sj, xj, aj, justTest) {
        return this.circleLine(bi, si, xi, bj, sj, xj, aj, justTest, 0, si.radius);
    };
    ;
    /**
     * Circle/convex Narrowphase.
     * @method circleConvex
     * @param  {Body} circleBody
     * @param  {Circle} circleShape
     * @param  {Array} circleOffset
     * @param  {Body} convexBody
     * @param  {Convex} convexShape
     * @param  {Array} convexOffset
     * @param  {Number} convexAngle
     * @param  {Boolean} justTest
     * @param  {Number} circleRadius
     * @return {number}
     * @todo Should probably do a separating axis test like https://github.com/erincatto/Box2D/blob/master/Box2D/Box2D/Collision/b2CollideCircle.cpp#L62
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =
    //Narrowphase.prototype[Shape.CIRCLE | Shape.BOX] =
    Narrowphase.prototype.circleConvex = function (circleBody, circleShape, circleOffset, convexBody, convexShape, convexOffset, convexAngle, justTest, circleRadius) {
        var worldVertex0 = tmp1, worldVertex1 = tmp2, edge = tmp3, edgeUnit = tmp4, normal = tmp5, zero = tmp6, localCirclePosition = tmp7, r = tmp8, dist = tmp10, worldVertex = tmp11, closestEdgeProjectedPoint = tmp13, candidate = tmp14, candidateDist = tmp15, found = -1, minCandidateDistance = Infinity;
        vec2_1.default.set(zero, 0, 0);
        // New algorithm:
        // 1. Check so center of circle is not inside the polygon. If it is, this wont work...
        // 2. For each edge
        // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
        // 2. 2. Check if point is inside.
        vec2_1.default.toLocalFrame(localCirclePosition, circleOffset, convexOffset, convexAngle);
        var vertices = convexShape.vertices;
        var normals = convexShape.normals;
        var numVertices = vertices.length;
        var normalIndex = -1;
        // Find the min separating edge.
        var separation = -Infinity;
        var radius = convexShape.boundingRadius + circleRadius;
        for (var i = 0; i < numVertices; i++) {
            sub(r, localCirclePosition, vertices[i]);
            var s = dot(normals[i], r);
            if (s > radius) {
                // Early out.
                return 0;
            }
            if (s > separation) {
                separation = s;
                normalIndex = i;
            }
        }
        // Check edges first
        for (var i = normalIndex + numVertices - 1; i < normalIndex + numVertices + 2; i++) {
            var v0 = vertices[i % numVertices], n = normals[i % numVertices];
            // Get point on circle, closest to the convex
            scale(candidate, n, -circleRadius);
            add(candidate, candidate, localCirclePosition);
            if (pointInConvexLocal(candidate, convexShape)) {
                sub(candidateDist, v0, candidate);
                var candidateDistance = Math.abs(dot(candidateDist, n));
                if (candidateDistance < minCandidateDistance) {
                    minCandidateDistance = candidateDistance;
                    found = i;
                }
            }
        }
        if (found !== -1) {
            if (justTest) {
                return 1;
            }
            var v0 = vertices[found % numVertices], v1 = vertices[(found + 1) % numVertices];
            vec2_1.default.toGlobalFrame(worldVertex0, v0, convexOffset, convexAngle);
            vec2_1.default.toGlobalFrame(worldVertex1, v1, convexOffset, convexAngle);
            sub(edge, worldVertex1, worldVertex0);
            normalize(edgeUnit, edge);
            // Get tangent to the edge. Points out of the Convex
            vec2_1.default.rotate90cw(normal, edgeUnit);
            // Get point on circle, closest to the convex
            scale(candidate, normal, -circleRadius);
            add(candidate, candidate, circleOffset);
            scale(closestEdgeProjectedPoint, normal, minCandidateDistance);
            add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, candidate);
            var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
            sub(c.normalA, candidate, circleOffset);
            normalize(c.normalA, c.normalA);
            scale(c.contactPointA, c.normalA, circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);
            sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
            add(c.contactPointB, c.contactPointB, convexOffset);
            sub(c.contactPointB, c.contactPointB, convexBody.position);
            this.contactEquations.push(c);
            if (this.enableFriction) {
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }
            return 1;
        }
        // Check closest vertices
        if (circleRadius > 0 && normalIndex !== -1) {
            for (var i = normalIndex + numVertices; i < normalIndex + numVertices + 2; i++) {
                var localVertex = vertices[i % numVertices];
                sub(dist, localVertex, localCirclePosition);
                if (squaredLength(dist) < circleRadius * circleRadius) {
                    if (justTest) {
                        return 1;
                    }
                    vec2_1.default.toGlobalFrame(worldVertex, localVertex, convexOffset, convexAngle);
                    sub(dist, worldVertex, circleOffset);
                    var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
                    copy(c.normalA, dist);
                    normalize(c.normalA, c.normalA);
                    // Vector from circle to contact point is the normal times the circle radius
                    scale(c.contactPointA, c.normalA, circleRadius);
                    add(c.contactPointA, c.contactPointA, circleOffset);
                    sub(c.contactPointA, c.contactPointA, circleBody.position);
                    sub(c.contactPointB, worldVertex, convexOffset);
                    add(c.contactPointB, c.contactPointB, convexOffset);
                    sub(c.contactPointB, c.contactPointB, convexBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                    return 1;
                }
            }
        }
        return 0;
    };
    ;
    /**
     * Particle/convex Narrowphase
     * @method particleConvex
     * @param  {Body} particleBody
     * @param  {Particle} particleShape
     * @param  {Array} particleOffset
     * @param  {Number} particleAngle
     * @param  {Body} convexBody
     * @param  {Convex} convexShape
     * @param  {Array} convexOffset
     * @param  {Number} convexAngle
     * @param {Boolean} justTest
     * @return {number}
     * @todo use pointInConvex and code more similar to circleConvex
     * @todo don't transform each vertex, but transform the particle position to convex-local instead
     */
    //Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =
    //Narrowphase.prototype[Shape.PARTICLE | Shape.BOX] =
    Narrowphase.prototype.particleConvex = function (particleBody, particleShape, particleOffset, convexBody, convexShape, convexOffset, convexAngle, justTest) {
        var worldVertex0 = tmp1, worldVertex1 = tmp2, worldEdge = tmp3, worldEdgeUnit = tmp4, worldTangent = tmp5, centerDist = tmp6, convexToparticle = tmp7, closestEdgeProjectedPoint = tmp13, candidateDist = tmp14, minEdgeNormal = tmp15, minCandidateDistance = Infinity, found = false, verts = convexShape.vertices;
        // Check if the particle is in the polygon at all
        if (!pointInConvex(particleOffset, convexShape, convexOffset, convexAngle)) {
            return 0;
        }
        if (justTest) {
            return 1;
        }
        // Check edges first
        for (var i = 0, numVerts = verts.length; i !== numVerts + 1; i++) {
            var v0 = verts[i % numVerts], v1 = verts[(i + 1) % numVerts];
            // Transform vertices to world
            // @todo transform point to local space instead
            rotate(worldVertex0, v0, convexAngle);
            rotate(worldVertex1, v1, convexAngle);
            add(worldVertex0, worldVertex0, convexOffset);
            add(worldVertex1, worldVertex1, convexOffset);
            // Get world edge
            sub(worldEdge, worldVertex1, worldVertex0);
            normalize(worldEdgeUnit, worldEdge);
            // Get tangent to the edge. Points out of the Convex
            vec2_1.default.rotate90cw(worldTangent, worldEdgeUnit);
            // Check distance from the infinite line (spanned by the edge) to the particle
            //sub(dist, particleOffset, worldVertex0);
            //let d = dot(dist, worldTangent);
            sub(centerDist, worldVertex0, convexOffset);
            sub(convexToparticle, particleOffset, convexOffset);
            sub(candidateDist, worldVertex0, particleOffset);
            var candidateDistance = Math.abs(dot(candidateDist, worldTangent));
            if (candidateDistance < minCandidateDistance) {
                minCandidateDistance = candidateDistance;
                scale(closestEdgeProjectedPoint, worldTangent, candidateDistance);
                add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, particleOffset);
                copy(minEdgeNormal, worldTangent);
                found = true;
            }
        }
        if (found) {
            var c = this.createContactEquation(particleBody, convexBody, particleShape, convexShape);
            scale(c.normalA, minEdgeNormal, -1);
            normalize(c.normalA, c.normalA);
            // Particle has no extent to the contact point
            vec2_1.default.set(c.contactPointA, 0, 0);
            add(c.contactPointA, c.contactPointA, particleOffset);
            sub(c.contactPointA, c.contactPointA, particleBody.position);
            // From convex center to point
            sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
            add(c.contactPointB, c.contactPointB, convexOffset);
            sub(c.contactPointB, c.contactPointB, convexBody.position);
            this.contactEquations.push(c);
            if (this.enableFriction) {
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }
            return 1;
        }
        return 0;
    };
    ;
    /**
     * Circle/circle Narrowphase
     * @method circleCircle
     * @param  {Body} bodyA
     * @param  {Circle} shapeA
     * @param  {Array} offsetA
     * @param  {Body} bodyB
     * @param  {Circle} shapeB
     * @param  {Array} offsetB
     * @param {Boolean} justTest
     * @param {Number} [radiusA] Optional radius to use for shapeA
     * @param {Number} [radiusB] Optional radius to use for shapeB
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CIRCLE] =
    Narrowphase.prototype.circleCircle = function (bodyA, shapeA, offsetA, bodyB, shapeB, offsetB, justTest, radiusA, radiusB) {
        var dist = tmp1;
        sub(dist, offsetA, offsetB);
        var r = radiusA + radiusB;
        if (squaredLength(dist) > r * r) {
            return 0;
        }
        if (justTest) {
            return 1;
        }
        var c = this.createContactEquation(bodyA, bodyB, shapeA, shapeB);
        var cpA = c.contactPointA;
        var cpB = c.contactPointB;
        var normalA = c.normalA;
        sub(normalA, offsetB, offsetA);
        normalize(normalA, normalA);
        scale(cpA, normalA, radiusA);
        scale(cpB, normalA, -radiusB);
        addSub(cpA, cpA, offsetA, bodyA.position);
        addSub(cpB, cpB, offsetB, bodyB.position);
        this.contactEquations.push(c);
        if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(c));
        }
        return 1;
    };
    ;
    /**
     * Plane/Convex Narrowphase
     * @method planeConvex
     * @param  {Body} planeBody
     * @param  {Plane} planeShape
     * @param  {Array} planeOffset
     * @param  {Number} planeAngle
     * @param  {Body} convexBody
     * @param  {Convex} convexShape
     * @param  {Array} convexOffset
     * @param  {Number} convexAngle
     * @param {Boolean} justTest
     * @return {number}
     * @todo only use the deepest contact point + the contact point furthest away from it
     */
    //Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] =
    //Narrowphase.prototype[Shape.PLANE | Shape.BOX] =
    Narrowphase.prototype.planeConvex = function (planeBody, planeShape, planeOffset, planeAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
        var worldVertex = tmp1, worldNormal = tmp2, dist = tmp3, localPlaneOffset = tmp4, localPlaneNormal = tmp5, localDist = tmp6;
        var numReported = 0;
        rotate(worldNormal, yAxis, planeAngle);
        // Get convex-local plane offset and normal
        vec2_1.default.vectorToLocalFrame(localPlaneNormal, worldNormal, convexAngle);
        vec2_1.default.toLocalFrame(localPlaneOffset, planeOffset, convexOffset, convexAngle);
        var vertices = convexShape.vertices;
        for (var i = 0, numVerts = vertices.length; i !== numVerts; i++) {
            var v = vertices[i];
            sub(localDist, v, localPlaneOffset);
            if (dot(localDist, localPlaneNormal) <= 0) {
                if (justTest) {
                    return 1;
                }
                vec2_1.default.toGlobalFrame(worldVertex, v, convexOffset, convexAngle);
                sub(dist, worldVertex, planeOffset);
                // Found vertex
                numReported++;
                var c = this.createContactEquation(planeBody, convexBody, planeShape, convexShape);
                sub(dist, worldVertex, planeOffset);
                copy(c.normalA, worldNormal);
                var d = dot(dist, c.normalA);
                scale(dist, c.normalA, d);
                // rj is from convex center to contact
                sub(c.contactPointB, worldVertex, convexBody.position);
                // ri is from plane center to contact
                sub(c.contactPointA, worldVertex, dist);
                sub(c.contactPointA, c.contactPointA, planeBody.position);
                this.contactEquations.push(c);
                if (!this.enableFrictionReduction) {
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
        if (this.enableFrictionReduction) {
            if (this.enableFriction && numReported) {
                this.frictionEquations.push(this.createFrictionFromAverage(numReported));
            }
        }
        return numReported;
    };
    ;
    /**
     * Narrowphase for particle vs plane
     * @method particlePlane
     * @param  {Body}       particleBody
     * @param  {Particle}   particleShape
     * @param  {Array}      particleOffset
     * @param  {Body}       planeBody
     * @param  {Plane}      planeShape
     * @param  {Array}      planeOffset
     * @param  {Number}     planeAngle
     * @param {Boolean}     justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =
    Narrowphase.prototype.particlePlane = function (particleBody, particleShape, particleOffset, planeBody, planeShape, planeOffset, planeAngle, justTest) {
        var dist = tmp1, worldNormal = tmp2;
        planeAngle = planeAngle || 0;
        sub(dist, particleOffset, planeOffset);
        rotate(worldNormal, yAxis, planeAngle);
        var d = dot(dist, worldNormal);
        if (d > 0) {
            return 0;
        }
        if (justTest) {
            return 1;
        }
        var c = this.createContactEquation(planeBody, particleBody, planeShape, particleShape);
        copy(c.normalA, worldNormal);
        scale(dist, c.normalA, d);
        // dist is now the distance vector in the normal direction
        // ri is the particle position projected down onto the plane, from the plane center
        sub(c.contactPointA, particleOffset, dist);
        sub(c.contactPointA, c.contactPointA, planeBody.position);
        // rj is from the body center to the particle center
        sub(c.contactPointB, particleOffset, particleBody.position);
        this.contactEquations.push(c);
        if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(c));
        }
        return 1;
    };
    ;
    /**
     * Circle/Particle Narrowphase
     * @method circleParticle
     * @param  {Body} circleBody
     * @param  {Circle} circleShape
     * @param  {Array} circleOffset
     * @param  {Body} particleBody
     * @param  {Particle} particleShape
     * @param  {Array} particleOffset
     * @param  {Boolean} justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =
    Narrowphase.prototype.circleParticle = function (circleBody, circleShape, circleOffset, particleBody, particleShape, particleOffset, justTest) {
        var dist = tmp1;
        var circleRadius = circleShape.radius;
        sub(dist, particleOffset, circleOffset);
        if (squaredLength(dist) > circleRadius * circleRadius) {
            return 0;
        }
        if (justTest) {
            return 1;
        }
        var c = this.createContactEquation(circleBody, particleBody, circleShape, particleShape);
        var normalA = c.normalA;
        var contactPointA = c.contactPointA;
        var contactPointB = c.contactPointB;
        copy(normalA, dist);
        normalize(normalA, normalA);
        // Vector from circle to contact point is the normal times the circle radius
        scale(contactPointA, normalA, circleRadius);
        add(contactPointA, contactPointA, circleOffset);
        sub(contactPointA, contactPointA, circleBody.position);
        // Vector from particle center to contact point is zero
        sub(contactPointB, particleOffset, particleBody.position);
        this.contactEquations.push(c);
        if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(c));
        }
        return 1;
    };
    ;
    /**
     * @method planeCapsule
     * @param  {Body} planeBody
     * @param  {Circle} planeShape
     * @param  {Array} planeOffset
     * @param  {Number} planeAngle
     * @param  {Body} capsuleBody
     * @param  {Particle} capsuleShape
     * @param  {Array} capsuleOffset
     * @param  {Number} capsuleAngle
     * @param {Boolean} justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =
    Narrowphase.prototype.planeCapsule = function (planeBody, planeShape, planeOffset, planeAngle, capsuleBody, capsuleShape, capsuleOffset, capsuleAngle, justTest) {
        var planeCapsule_tmpCircle = new Circle_1.default({ radius: 1 });
        var end1 = planeCapsule_tmp1, end2 = planeCapsule_tmp2, circle = planeCapsule_tmpCircle, halfLength = capsuleShape.length / 2;
        // Compute world end positions
        vec2_1.default.set(end1, -halfLength, 0);
        vec2_1.default.set(end2, halfLength, 0);
        vec2_1.default.toGlobalFrame(end1, end1, capsuleOffset, capsuleAngle);
        vec2_1.default.toGlobalFrame(end2, end2, capsuleOffset, capsuleAngle);
        circle.radius = capsuleShape.radius;
        var enableFrictionBefore = this.enableFriction;
        // Temporarily turn off friction
        if (this.enableFrictionReduction) {
            this.enableFriction = false;
        }
        // Do Narrowphase as two circles
        var numContacts1 = this.circlePlane(capsuleBody, circle, end1, planeBody, planeShape, planeOffset, planeAngle, justTest), numContacts2 = this.circlePlane(capsuleBody, circle, end2, planeBody, planeShape, planeOffset, planeAngle, justTest);
        // Restore friction
        if (this.enableFrictionReduction) {
            this.enableFriction = enableFrictionBefore;
        }
        if (justTest) {
            return numContacts1 + numContacts2;
        }
        else {
            var numTotal = numContacts1 + numContacts2;
            if (this.enableFrictionReduction) {
                if (numTotal) {
                    this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
                }
            }
            return numTotal;
        }
    };
    ;
    /**
     * @method circlePlane
     * @param  {Body}    circleBody
     * @param  {Circle}  circleShape
     * @param  {Array}   circleOffset
     * @param  {Body}    planeBody
     * @param  {Plane}   planeShape
     * @param  {Array}   planeOffset
     * @param  {Number}  planeAngle
     * @param  {Boolean} justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =
    Narrowphase.prototype.circlePlane = function (circleBody, circleShape, circleOffset, planeBody, planeShape, planeOffset, planeAngle, justTest) {
        var circleRadius = circleShape.radius;
        // Vector from plane to circle
        var planeToCircle = tmp1, worldNormal = tmp2, temp = tmp3;
        sub(planeToCircle, circleOffset, planeOffset);
        // World plane normal
        rotate(worldNormal, yAxis, planeAngle);
        // Normal direction distance
        var d = dot(worldNormal, planeToCircle);
        if (d > circleRadius) {
            return 0; // No overlap. Abort.
        }
        if (justTest) {
            return 1;
        }
        // Create contact
        var contact = this.createContactEquation(planeBody, circleBody, planeShape, circleShape);
        // ni is the plane world normal
        copy(contact.normalA, worldNormal);
        // rj is the vector from circle center to the contact point
        var cpB = contact.contactPointB;
        scale(cpB, contact.normalA, -circleRadius);
        add(cpB, cpB, circleOffset);
        sub(cpB, cpB, circleBody.position);
        // ri is the distance from plane center to contact.
        var cpA = contact.contactPointA;
        scale(temp, contact.normalA, d);
        sub(cpA, planeToCircle, temp); // Subtract normal distance vector from the distance vector
        add(cpA, cpA, planeOffset);
        sub(cpA, cpA, planeBody.position);
        this.contactEquations.push(contact);
        if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(contact));
        }
        return 1;
    };
    ;
    // Find edge normal of max separation on A - return if separating axis is found
    // Find edge normal of max separation on B - return if separation axis is found
    // Choose reference edge as min(minA, minB)
    // Find incident edge
    // Clip
    // The normal points from 1 to 2
    /*function collidePolygons(
        manifold,
        polyA, positionA, angleA,
        polyB, positionB, angleB,
        incidentEdge
    ) {*/
    /**
     * Convex/convex Narrowphase.See <a href="http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/">this article</a> for more info.
     * @method convexConvex
     * @param  {Body} bi
     * @param  {Convex} si
     * @param  {Array} xi
     * @param  {Number} ai
     * @param  {Body} bj
     * @param  {Convex} sj
     * @param  {Array} xj
     * @param  {Number} aj
     * @param  {Boolean} justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CONVEX] =
    //Narrowphase.prototype[Shape.CONVEX | Shape.BOX] =
    //Narrowphase.prototype[Shape.BOX] =
    Narrowphase.prototype.convexConvex = function (bodyA, polyA, positionA, angleA, bodyB, polyB, positionB, angleB, justTest) {
        var maxManifoldPoints = 2;
        var totalRadius = 0;
        var dist = collidePolygons_dist;
        var tempVec = collidePolygons_tempVec;
        var tmpVec = collidePolygons_tmpVec;
        var edgeA = findMaxSeparation(tempVec, polyA, positionA, angleA, polyB, positionB, angleB);
        var separationA = tempVec[0];
        if (separationA > totalRadius) {
            return 0;
        }
        var edgeB = findMaxSeparation(tmpVec, polyB, positionB, angleB, polyA, positionA, angleA);
        var separationB = tmpVec[0];
        if (separationB > totalRadius) {
            return 0;
        }
        var poly1; // reference polygon
        var poly2; // incident polygon
        var position1;
        var position2;
        var angle1;
        var angle2;
        var body1;
        var body2;
        var edge1; // reference edge
        var type;
        if (separationB > separationA) {
            poly1 = polyB;
            poly2 = polyA;
            body1 = bodyB;
            body2 = bodyA;
            position1 = positionB;
            angle1 = angleB;
            position2 = positionA;
            angle2 = angleA;
            edge1 = edgeB;
            type = 1; // faceB
        }
        else {
            poly1 = polyA;
            poly2 = polyB;
            body1 = bodyA;
            body2 = bodyB;
            position1 = positionA;
            angle1 = angleA;
            position2 = positionB;
            angle2 = angleB;
            edge1 = edgeA;
            type = 0; // faceA
        }
        var incidentEdge = collidePolygons_incidentEdge;
        findIncidentEdge(incidentEdge, poly1, position1, angle1, edge1, poly2, position2, angle2);
        var count1 = poly1.vertices.length;
        var vertices1 = poly1.vertices;
        var iv1 = edge1;
        var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;
        var v11 = collidePolygons_v11;
        var v12 = collidePolygons_v12;
        vec2_1.default.copy(v11, vertices1[iv1]);
        vec2_1.default.copy(v12, vertices1[iv2]);
        var localTangent = collidePolygons_localTangent;
        vec2_1.default.subtract(localTangent, v12, v11);
        vec2_1.default.normalize(localTangent, localTangent);
        var localNormal = collidePolygons_localNormal;
        vec2_1.default.crossVZ(localNormal, localTangent, 1.0);
        var planePoint = collidePolygons_planePoint;
        vec2_1.default.add(planePoint, v11, v12);
        vec2_1.default.scale(planePoint, planePoint, 0.5);
        var tangent = collidePolygons_tangent; // tangent in world space
        vec2_1.default.rotate(tangent, localTangent, angle1);
        var normal = collidePolygons_normal; // normal in world space
        vec2_1.default.crossVZ(normal, tangent, 1.0);
        vec2_1.default.toGlobalFrame(v11, v11, position1, angle1);
        vec2_1.default.toGlobalFrame(v12, v12, position1, angle1);
        // Face offset.
        var frontOffset = vec2_1.default.dot(normal, v11);
        // Side offsets, extended by polytope skin thickness.
        var sideOffset1 = -vec2_1.default.dot(tangent, v11) + totalRadius;
        var sideOffset2 = vec2_1.default.dot(tangent, v12) + totalRadius;
        // Clip incident edge against extruded edge1 side edges.
        var clipPoints1 = collidePolygons_clipPoints1;
        var clipPoints2 = collidePolygons_clipPoints2;
        var np = 0;
        // Clip to box side 1
        var negativeTangent = collidePolygons_negativeTangent;
        vec2_1.default.scale(negativeTangent, tangent, -1);
        np = clipSegmentToLine(clipPoints1, incidentEdge, negativeTangent, sideOffset1 /*, iv1*/);
        if (np < 2) {
            return 0;
        }
        // Clip to negative box side 1
        np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2 /*, iv2*/);
        if (np < 2) {
            return 0;
        }
        var pointCount = 0;
        for (var i = 0; i < maxManifoldPoints; ++i) {
            var separation = vec2_1.default.dot(normal, clipPoints2[i]) - frontOffset;
            if (separation <= totalRadius) {
                if (justTest) {
                    return 1;
                }
                ++pointCount;
                var c = this.createContactEquation(body1, body2, poly1, poly2);
                vec2_1.default.copy(c.normalA, normal);
                vec2_1.default.copy(c.contactPointB, clipPoints2[i]);
                sub(c.contactPointB, c.contactPointB, body2.position);
                vec2_1.default.scale(dist, normal, -separation);
                vec2_1.default.add(c.contactPointA, clipPoints2[i], dist);
                sub(c.contactPointA, c.contactPointA, body1.position);
                this.contactEquations.push(c);
                if (this.enableFriction && !this.enableFrictionReduction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
        if (pointCount && this.enableFrictionReduction && this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromAverage(pointCount));
        }
        return pointCount;
    };
    ;
    //Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =
    Narrowphase.prototype.circleHeightfield = function (circleBody, circleShape, circlePos, hfBody, hfShape, hfPos, justTest, radius) {
        var data = hfShape.heights, w = hfShape.elementWidth, dist = circleHeightfield_dist, candidate = circleHeightfield_candidate, minCandidate = circleHeightfield_minCandidate, minCandidateNormal = circleHeightfield_minCandidateNormal, worldNormal = circleHeightfield_worldNormal, v0 = circleHeightfield_v0, v1 = circleHeightfield_v1;
        // Get the index of the points to test against
        var idxA = Math.floor((circlePos[0] - radius - hfPos[0]) / w), idxB = Math.ceil((circlePos[0] + radius - hfPos[0]) / w);
        /*if(idxB < 0 || idxA >= data.length)
            return justTest ? false : 0;*/
        if (idxA < 0) {
            idxA = 0;
        }
        if (idxB >= data.length) {
            idxB = data.length - 1;
        }
        // Get max and min
        var max = data[idxA], min = data[idxB];
        for (var i = idxA; i < idxB; i++) {
            if (data[i] < min) {
                min = data[i];
            }
            if (data[i] > max) {
                max = data[i];
            }
        }
        if (circlePos[1] - radius > max) {
            return 0;
        }
        /*
        if(circlePos[1]+radius < min){
            // Below the minimum point... We can just guess.
            // TODO
        }
        */
        // 1. Check so center of circle is not inside the field. If it is, this wont work...
        // 2. For each edge
        // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
        // 2. 2. Check if point is inside.
        var found = false;
        // Check all edges first
        for (var i = idxA; i < idxB; i++) {
            // Get points
            vec2_1.default.set(v0, i * w, data[i]);
            vec2_1.default.set(v1, (i + 1) * w, data[i + 1]);
            add(v0, v0, hfPos); // @todo transform circle to local heightfield space instead
            add(v1, v1, hfPos);
            // Get normal
            sub(worldNormal, v1, v0);
            rotate(worldNormal, worldNormal, Math.PI / 2);
            normalize(worldNormal, worldNormal);
            // Get point on circle, closest to the edge
            scale(candidate, worldNormal, -radius);
            add(candidate, candidate, circlePos);
            // Distance from v0 to the candidate point
            sub(dist, candidate, v0);
            // Check if it is in the element "stick"
            var d = dot(dist, worldNormal);
            if (candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0) {
                if (justTest) {
                    return 1;
                }
                found = true;
                // Store the candidate point, projected to the edge
                scale(dist, worldNormal, -d);
                add(minCandidate, candidate, dist);
                copy(minCandidateNormal, worldNormal);
                var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                // Normal is out of the heightfield
                copy(c.normalA, minCandidateNormal);
                // Vector from circle to heightfield
                scale(c.contactPointB, c.normalA, -radius);
                add(c.contactPointB, c.contactPointB, circlePos);
                sub(c.contactPointB, c.contactPointB, circleBody.position);
                copy(c.contactPointA, minCandidate);
                sub(c.contactPointA, c.contactPointA, hfBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
        // Check all vertices
        found = false;
        if (radius > 0) {
            for (var i = idxA; i <= idxB; i++) {
                // Get point
                vec2_1.default.set(v0, i * w, data[i]);
                add(v0, v0, hfPos);
                sub(dist, circlePos, v0);
                if (squaredLength(dist) < Math.pow(radius, 2)) {
                    if (justTest) {
                        return 1;
                    }
                    found = true;
                    var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                    // Construct normal - out of heightfield
                    copy(c.normalA, dist);
                    normalize(c.normalA, c.normalA);
                    scale(c.contactPointB, c.normalA, -radius);
                    add(c.contactPointB, c.contactPointB, circlePos);
                    sub(c.contactPointB, c.contactPointB, circleBody.position);
                    sub(c.contactPointA, v0, hfPos);
                    add(c.contactPointA, c.contactPointA, hfPos);
                    sub(c.contactPointA, c.contactPointA, hfBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
        if (found) {
            return 1;
        }
        return 0;
    };
    //Narrowphase.prototype[Shape.BOX | Shape.HEIGHTFIELD] =
    //Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =
    Narrowphase.prototype.convexHeightfield = function (convexBody, convexShape, convexPos, convexAngle, hfBody, hfShape, hfPos, justTest) {
        var data = hfShape.heights, w = hfShape.elementWidth, v0 = convexHeightfield_v0, v1 = convexHeightfield_v1, tilePos = convexHeightfield_tilePos, tileConvex = convexHeightfield_tempConvexShape;
        // Get the index of the points to test against
        var idxA = Math.floor((convexBody.aabb.lowerBound[0] - hfPos[0]) / w), idxB = Math.ceil((convexBody.aabb.upperBound[0] - hfPos[0]) / w);
        if (idxA < 0) {
            idxA = 0;
        }
        if (idxB >= data.length) {
            idxB = data.length - 1;
        }
        // Get max and min
        var max = data[idxA], min = data[idxB];
        for (var i = idxA; i < idxB; i++) {
            if (data[i] < min) {
                min = data[i];
            }
            if (data[i] > max) {
                max = data[i];
            }
        }
        if (convexBody.aabb.lowerBound[1] > max) {
            return 0;
        }
        var numContacts = 0;
        // Loop over all edges
        // @todo If possible, construct a convex from several data points (need o check if the points make a convex shape)
        // @todo transform convex to local heightfield space.
        // @todo bail out if the heightfield tile is not tall enough.
        for (var i = idxA; i < idxB; i++) {
            // Get points
            vec2_1.default.set(v0, i * w, data[i]);
            vec2_1.default.set(v1, (i + 1) * w, data[i + 1]);
            add(v0, v0, hfPos);
            add(v1, v1, hfPos);
            // Construct a convex
            var tileHeight = 100; // todo
            vec2_1.default.set(tilePos, (v1[0] + v0[0]) * 0.5, (v1[1] + v0[1] - tileHeight) * 0.5);
            sub(tileConvex.vertices[0], v1, tilePos);
            sub(tileConvex.vertices[1], v0, tilePos);
            copy(tileConvex.vertices[2], tileConvex.vertices[1]);
            copy(tileConvex.vertices[3], tileConvex.vertices[0]);
            tileConvex.vertices[2][1] -= tileHeight;
            tileConvex.vertices[3][1] -= tileHeight;
            tileConvex.updateNormals();
            // Do convex collision
            numContacts += this.convexConvex(convexBody, convexShape, convexPos, convexAngle, hfBody, tileConvex, tilePos, 0, justTest);
        }
        return numContacts;
    };
    return Narrowphase;
}());
exports.default = Narrowphase;

},{"../math/vec2":28,"../shapes/Box":35,"../shapes/Circle":36,"../shapes/Convex":37,"../utils/contact-equation-pool":49,"../utils/friction-equation-pool":50,"../utils/tuple-dictionary":55}],5:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var intersectBody_worldPosition = vec2_1.default.create();
var v0 = vec2_1.default.create(), intersect = vec2_1.default.create();
var Ray = /** @class */ (function () {
    /**
     * A line with a start and end point that is used to intersect shapes. For an example, see {{#crossLink "World/raycast:method"}}World.raycast{{/crossLink}}
     * @class Ray
     * @constructor
     * @param {object} [options]
     * @param {array} [options.from]
     * @param {array} [options.to]
     * @param {boolean} [options.checkCollisionResponse=true]
     * @param {boolean} [options.skipBackfaces=false]
     * @param {number} [options.collisionMask=-1]
     * @param {number} [options.collisionGroup=-1]
     * @param {number} [options.mode=Ray.ANY]
     * @param {Function} [options.callback]
     */
    function Ray(options) {
        /**
         * @readOnly
         * @property {array} direction
         */
        this.direction = vec2_1.default.create();
        /**
         * Length of the ray
         * @readOnly
         * @property {number} length
         */
        this.length = 1;
        options = options !== null && options !== void 0 ? options : {};
        this.from = options.from ? vec2_1.default.clone(options.from) : vec2_1.default.create();
        this.to = options.to ? vec2_1.default.clone(options.to) : vec2_1.default.create();
        this.checkCollisionResponse = options.checkCollisionResponse !== undefined ? options.checkCollisionResponse : true;
        this.skipBackfaces = !!options.skipBackfaces;
        this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : -1;
        this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : -1;
        this.mode = options.mode !== undefined ? options.mode : Ray.ANY;
        this.callback = options.callback || function ( /*result*/) { };
        this.update();
    }
    /**
     * Should be called if you change the from or to point.
     * @method update
     */
    Ray.prototype.update = function () {
        // Update .direction and .length
        var d = this.direction;
        vec2_1.default.subtract(d, this.to, this.from);
        this.length = vec2_1.default.length(d);
        vec2_1.default.normalize(d, d);
    };
    ;
    /**
     * @method intersectBodies
     * @param {Array} bodies An array of Body objects.
     */
    Ray.prototype.intersectBodies = function (result, bodies) {
        for (var i = 0, l = bodies.length; !result.shouldStop(this) && i < l; i++) {
            var body = bodies[i];
            var aabb = body.getAABB();
            if (aabb.overlapsRay(this) >= 0 || aabb.containsPoint(this.from)) {
                this.intersectBody(result, body);
            }
        }
    };
    ;
    /**
     * Shoot a ray at a body, get back information about the hit.
     * @method intersectBody
     * @private
     * @param {Body} body
     */
    Ray.prototype.intersectBody = function (result, body) {
        var checkCollisionResponse = this.checkCollisionResponse;
        if (checkCollisionResponse && !body.collisionResponse) {
            return;
        }
        var worldPosition = intersectBody_worldPosition;
        for (var i = 0, N = body.shapes.length; i < N; i++) {
            var shape = body.shapes[i];
            if (checkCollisionResponse && !shape.collisionResponse) {
                continue; // Skip
            }
            if ((this.collisionGroup & shape.collisionMask) === 0 || (shape.collisionGroup & this.collisionMask) === 0) {
                continue;
            }
            // Get world angle and position of the shape
            vec2_1.default.rotate(worldPosition, shape.position, body.angle);
            vec2_1.default.add(worldPosition, worldPosition, body.position);
            var worldAngle = shape.angle + body.angle;
            this.intersectShape(result, shape, worldAngle, worldPosition, body);
            if (result.shouldStop(this)) {
                break;
            }
        }
    };
    ;
    /**
     * @method intersectShape
     * @private
     * @param {Shape} shape
     * @param {number} angle
     * @param {array} position
     * @param {Body} body
     */
    Ray.prototype.intersectShape = function (result, shape, angle, position, body) {
        var from = this.from;
        // Checking radius
        var distance = distanceFromIntersectionSquared(from, this.direction, position);
        if (distance > shape.boundingRadius * shape.boundingRadius) {
            return;
        }
        this._currentBody = body;
        this._currentShape = shape;
        shape.raycast(result, this, position, angle);
        this._currentBody = undefined;
        this._currentShape = undefined;
    };
    ;
    /**
     * Get the AABB of the ray.
     * @method getAABB
     * @param  {AABB} aabb
     */
    Ray.prototype.getAABB = function (result) {
        var to = this.to;
        var from = this.from;
        vec2_1.default.set(result.lowerBound, Math.min(to[0], from[0]), Math.min(to[1], from[1]));
        vec2_1.default.set(result.upperBound, Math.max(to[0], from[0]), Math.max(to[1], from[1]));
    };
    ;
    /**
     * @method reportIntersection
     * @private
     * @param  {number} fraction
     * @param  {array} normal
     * @param  {number} [faceIndex=-1]
     * @return {boolean} True if the intersections should continue // This never returned anything.
     */
    Ray.prototype.reportIntersection = function (result, fraction, normal, faceIndex) {
        var shape = this._currentShape;
        var body = this._currentBody;
        // Skip back faces?
        if (this.skipBackfaces && vec2_1.default.dot(normal, this.direction) > 0) {
            return;
        }
        switch (this.mode) {
            case Ray.ALL:
                result.set(normal, shape, body, fraction, faceIndex);
                this.callback(result);
                break;
            case Ray.CLOSEST:
                // Store if closer than current closest
                if (fraction < result.fraction || !result.hasHit()) {
                    result.set(normal, shape, body, fraction, faceIndex);
                }
                break;
            case Ray.ANY:
                // Report and stop.
                result.set(normal, shape, body, fraction, faceIndex);
                break;
        }
    };
    ;
    /**
     * This raycasting mode will make the Ray traverse through all intersection points and only return the closest one.
     * @static
     * @property {Number} CLOSEST
     */
    Ray.CLOSEST = 1;
    /**
     * This raycasting mode will make the Ray stop when it finds the first intersection point.
     * @static
     * @property {Number} ANY
     */
    Ray.ANY = 2;
    /**
     * This raycasting mode will traverse all intersection points and executes a callback for each one.
     * @static
     * @property {Number} ALL
     */
    Ray.ALL = 4;
    return Ray;
}());
exports.default = Ray;
function distanceFromIntersectionSquared(from, direction, position) {
    // v0 is vector from from to position
    vec2_1.default.subtract(v0, position, from);
    var dot = vec2_1.default.dot(v0, direction);
    // intersect = direction * dot + from
    vec2_1.default.scale(intersect, direction, dot);
    vec2_1.default.add(intersect, intersect, from);
    return vec2_1.default.squaredDistance(position, intersect);
}

},{"../math/vec2":28}],6:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var ray_1 = __importDefault(_dereq_("./ray"));
var RaycastResult = /** @class */ (function () {
    /**
     * Storage for Ray casting hit data.
     * @class RaycastResult
     * @constructor
     */
    function RaycastResult() {
        /**
         * The normal of the hit, oriented in world space.
         * @property {array} normal
         */
        this.normal = vec2_1.default.create();
        /**
         * The index of the hit triangle, if the hit shape was indexable.
         * @property {number} faceIndex
         * @default -1
         */
        this.faceIndex = -1;
        /**
         * Distance to the hit, as a fraction. 0 is at the "from" point, 1 is at the "to" point. Will be set to -1 if there was no hit yet.
         * @property {number} fraction
         * @default -1
         */
        this.fraction = -1;
        /**
         * If the ray should stop traversing.
         * @readonly
         * @property {Boolean} isStopped
         */
        this.isStopped = false;
    }
    /**
     * Reset all result data. Must be done before re-using the result object.
     * @method reset
     */
    RaycastResult.prototype.reset = function () {
        vec2_1.default.set(this.normal, 0, 0);
        this.shape = undefined;
        this.body = undefined;
        this.faceIndex = -1;
        this.fraction = -1;
        this.isStopped = false;
    };
    /**
     * Get the distance to the hit point.
     * @method getHitDistance
     * @param {Ray} ray
     * @return {number}
     */
    RaycastResult.prototype.getHitDistance = function (ray) {
        return vec2_1.default.distance(ray.from, ray.to) * this.fraction;
    };
    /**
     * Returns true if the ray hit something since the last reset().
     * @method hasHit
     * @®eturn {boolean}
     */
    RaycastResult.prototype.hasHit = function () {
        return this.fraction !== -1;
    };
    /**
     * Get world hit point.
     * @method getHitPoint
     * @param {array} out
     * @param {Ray} ray
     */
    RaycastResult.prototype.getHitPoint = function (out, ray) {
        vec2_1.default.lerp(out, ray.from, ray.to, this.fraction);
    };
    /**
     * Can be called while iterating over hits to stop searching for hit points.
     * @method stop
     */
    RaycastResult.prototype.stop = function () {
        this.isStopped = true;
    };
    /**
     * @method shouldStop
     * @private
     * @param {Ray} ray
     * @return {boolean}
     */
    RaycastResult.prototype.shouldStop = function (ray) {
        return this.isStopped || (this.fraction !== -1 && ray.mode === ray_1.default.ANY);
    };
    /**
     * @method set
     * @private
     * @param {array} normal
     * @param {Shape} shape
     * @param {Body} body
     * @param {number} fraction
     * @param {number} faceIndex
     */
    RaycastResult.prototype.set = function (normal, shape, body, fraction, faceIndex) {
        vec2_1.default.copy(this.normal, normal);
        this.shape = shape;
        this.body = body;
        this.fraction = fraction;
        this.faceIndex = faceIndex;
    };
    return RaycastResult;
}());
exports.default = RaycastResult;

},{"../math/vec2":28,"./ray":5}],7:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var broadphase_1 = __importDefault(_dereq_("./broadphase"));
var utils_1 = __importDefault(_dereq_("../utils/utils"));
// TODO: this appears to be a bubble sort. We could probably do better.
function sortAxisList(a, axisIndex) {
    for (var i = 1, l = a.length; i < l; i++) { // Why not i=0?
        var v = a[i];
        for (var j = i - 1; j >= 0; j--) {
            if (a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]) {
                break;
            }
            a[j + 1] = a[j];
        }
        a[j + 1] = v;
    }
    return a;
}
var SAPBroadphase = /** @class */ (function (_super) {
    __extends(SAPBroadphase, _super);
    /**
     * Sweep and prune broadphase along one axis.
     *
     * @class SAPBroadphase
     * @constructor
     * @extends Broadphase
     */
    function SAPBroadphase() {
        var _this = _super.call(this, broadphase_1.default.SAP) || this;
        _this.axisList = [];
        _this.axisIndex = 0;
        _this._addBodyHandler = function (e) {
            _this.axisList.push(e.body);
        };
        _this._removeBodyHandler = function (e) {
            // Remove from list
            var idx = _this.axisList.indexOf(e.body);
            if (idx !== -1) {
                _this.axisList.splice(idx, 1);
            }
        };
        return _this;
    }
    /**
     * Change the world
     * @method setWorld
     * @param {World} world
     */
    SAPBroadphase.prototype.setWorld = function (world) {
        // Clear the old axis array
        this.axisList.length = 0;
        // Add all bodies from the new world
        utils_1.default.appendArray(this.axisList, world.bodies);
        // Remove old handlers, if any
        world
            .off("addBody", this._addBodyHandler)
            .off("removeBody", this._removeBodyHandler);
        // Add handlers to update the list of bodies.
        // TODO: now that I've added context, we can test moving those inline functions to proper private methods.
        world.on("addBody", this._addBodyHandler, this)
            .on("removeBody", this._removeBodyHandler, this);
        this.world = world;
    };
    ;
    SAPBroadphase.prototype.sortList = function () {
        var bodies = this.axisList, axisIndex = this.axisIndex;
        // Sort the lists
        sortAxisList(bodies, axisIndex);
    };
    ;
    /**
     * Get the colliding pairs
     * @method getCollisionPairs
     * @param  {World} world
     * @return {Array}
     */
    SAPBroadphase.prototype.getCollisionPairs = function ( /*world*/) {
        var bodies = this.axisList, result = this.result, axisIndex = this.axisIndex;
        result.length = 0;
        // Update all AABBs if needed
        var l = bodies.length;
        while (l--) {
            var b = bodies[l];
            if (b.aabbNeedsUpdate) {
                b.updateAABB();
            }
        }
        // Sort the lists
        this.sortList();
        // Look through the X list
        for (var i = 0, N = bodies.length | 0; i !== N; i++) {
            var bi = bodies[i];
            for (var j = i + 1; j < N; j++) {
                var bj = bodies[j];
                // Bounds overlap?
                var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);
                if (!overlaps) {
                    break;
                }
                if (broadphase_1.default.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                    result.push(bi);
                    result.push(bj);
                }
            }
        }
        return result;
    };
    ;
    /**
     * Returns all the bodies within an AABB.
     * @method aabbQuery
     * @param  {World} world
     * @param  {AABB} aabb
     * @param {array} result An array to store resulting bodies in.
     * @return {array}
     * @todo since the list is sorted, optimization can be done
     */
    SAPBroadphase.prototype.aabbQuery = function (world, aabb, result) {
        result = result || [];
        this.sortList();
        var axisList = this.axisList;
        for (var i = 0; i < axisList.length; i++) {
            var b = axisList[i];
            if (b.aabbNeedsUpdate) {
                b.updateAABB();
            }
            if (b.aabb.overlaps(aabb)) {
                result.push(b);
            }
        }
        return result;
    };
    ;
    return SAPBroadphase;
}(broadphase_1.default));
exports.default = SAPBroadphase;

},{"../utils/utils":56,"./broadphase":2}],8:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Constraint = /** @class */ (function () {
    /**
     * Base constraint class.
     *
     * @class Constraint
     * @constructor
     * @author schteppe
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Number} type
     * @param {Object} [options]
     * @param {Object} [options.collideConnected=true]
     */
    function Constraint(bodyA, bodyB, type, options) {
        var _a, _b;
        this.type = type;
        this.equations = [];
        this.bodyA = bodyA;
        this.bodyB = bodyB;
        this.collideConnected = (_a = options === null || options === void 0 ? void 0 : options.collideConnected) !== null && _a !== void 0 ? _a : true;
        // Wake up bodies when connected
        if (((_b = options === null || options === void 0 ? void 0 : options.wakeUpBodies) !== null && _b !== void 0 ? _b : false) !== false) {
            if (bodyA) {
                bodyA.wakeUp();
            }
            if (bodyB) {
                bodyB.wakeUp();
            }
        }
    }
    /**
     * Updates the internal constraint parameters before solve.
     * @method update
     */
    Constraint.prototype.update = function () {
        throw new Error("method update() not implmemented in this Constraint subclass!");
    };
    ;
    /**
     * Set stiffness for this constraint.
     * @method setStiffness
     * @param {Number} stiffness
     */
    Constraint.prototype.setStiffness = function (stiffness) {
        var eqs = this.equations;
        for (var i = 0; i !== eqs.length; i++) {
            var eq = eqs[i];
            eq.stiffness = stiffness;
            eq.needsUpdate = true;
        }
    };
    ;
    /**
     * Set relaxation for this constraint.
     * @method setRelaxation
     * @param {Number} relaxation
     */
    Constraint.prototype.setRelaxation = function (relaxation) {
        var eqs = this.equations;
        for (var i = 0; i !== eqs.length; i++) {
            var eq = eqs[i];
            eq.relaxation = relaxation;
            eq.needsUpdate = true;
        }
    };
    ;
    /**
     * @method setMaxBias
     * @param {Number} maxBias
     */
    Constraint.prototype.setMaxBias = function (maxBias) {
        var eqs = this.equations;
        for (var i = 0; i !== eqs.length; i++) {
            var eq = eqs[i];
            eq.maxBias = maxBias;
        }
    };
    ;
    /**
     * @static
     * @property {number} DISTANCE
     */
    Constraint.DISTANCE = 1;
    /**
     * @static
     * @property {number} GEAR
     */
    Constraint.GEAR = 2;
    /**
     * @static
     * @property {number} LOCK
     */
    Constraint.LOCK = 3;
    /**
     * @static
     * @property {number} PRISMATIC
     */
    Constraint.PRISMATIC = 4;
    /**
     * @static
     * @property {number} REVOLUTE
     */
    Constraint.REVOLUTE = 5;
    return Constraint;
}());
exports.default = Constraint;

},{}],9:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var constraint_1 = __importDefault(_dereq_("./constraint"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var n = vec2_1.default.create();
var ri = vec2_1.default.create(); // worldAnchorA
var rj = vec2_1.default.create(); // worldAnchorB
var DistanceConstraint = /** @class */ (function (_super) {
    __extends(DistanceConstraint, _super);
    // this.upperLimitEnabled = false;
    // this.upperLimit = 1;
    // this.lowerLimitEnabled = false;
    // this.lowerLimit = 0;
    // this.position = 0;
    /**
     * Constraint that tries to keep the distance between two bodies constant.
     *
     * @class DistanceConstraint
     * @constructor
     * @author schteppe
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {object} [options]
     * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.
     * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
     * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
     * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.
     * @extends Constraint
     *
     * @example
     *     // If distance is not given as an option, then the current distance between the bodies is used.
     *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.
     *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
     *     var bodyB = new Body({ mass: 1, position: [1, 0] });
     *     var constraint = new DistanceConstraint(bodyA, bodyB);
     *     world.addConstraint(constraint);
     *
     * @example
     *     // Manually set the distance and anchors
     *     var constraint = new DistanceConstraint(bodyA, bodyB, {
     *         distance: 1,          // Distance to keep between the points
     *         localAnchorA: [1, 0], // Point on bodyA
     *         localAnchorB: [-1, 0] // Point on bodyB
     *     });
     *     world.addConstraint(constraint);
     */
    function DistanceConstraint(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, constraint_1.default.DISTANCE, options) || this;
        /**
         * The distance to keep.
         * @property distance
         * @type {Number}
         */
        _this.distance = 0;
        /**
         * Max force to apply.
         * @property {number} maxForce
         */
        _this.maxForce = Infinity;
        /**
         * If the upper limit is enabled or not.
         * @property {Boolean} upperLimitEnabled
         */
        _this.upperLimitEnabled = false;
        /**
         * The upper constraint limit.
         * @property {number} upperLimit
         */
        _this.upperLimit = 1;
        /**
         * If the lower limit is enabled or not.
         * @property {Boolean} lowerLimitEnabled
         */
        _this.lowerLimitEnabled = false;
        /**
         * The lower constraint limit.
         * @property {number} lowerLimit
         */
        _this.lowerLimit = 0;
        /**
         * Current constraint position. This is equal to the current distance between the world anchor points.
         * @property {number} position
         */
        _this.position = 0;
        _this.localAnchorA = (options === null || options === void 0 ? void 0 : options.localAnchorA) ? vec2_1.default.clone(options.localAnchorA) : vec2_1.default.create();
        _this.localAnchorB = (options === null || options === void 0 ? void 0 : options.localAnchorB) ? vec2_1.default.clone(options.localAnchorB) : vec2_1.default.create();
        var localAnchorA = _this.localAnchorA;
        var localAnchorB = _this.localAnchorB;
        _this.distance = 0;
        if ((options === null || options === void 0 ? void 0 : options.distance) !== undefined) {
            _this.distance = options.distance;
        }
        else {
            // Use the current world distance between the world anchor points.
            var worldAnchorA = vec2_1.default.create(), worldAnchorB = vec2_1.default.create(), r = vec2_1.default.create();
            // Transform local anchors to world
            vec2_1.default.rotate(worldAnchorA, localAnchorA, bodyA.angle);
            vec2_1.default.rotate(worldAnchorB, localAnchorB, bodyB.angle);
            vec2_1.default.add(r, bodyB.position, worldAnchorB);
            vec2_1.default.subtract(r, r, worldAnchorA);
            vec2_1.default.subtract(r, r, bodyA.position);
            _this.distance = vec2_1.default.length(r);
        }
        var maxForce = (_a = options === null || options === void 0 ? void 0 : options.maxForce) !== null && _a !== void 0 ? _a : Infinity;
        var normal = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce); // Just in the normal direction
        _this.equations = [normal];
        _this.maxForce = maxForce;
        // g = (xi - xj).dot(n)
        // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'
        // ...and if we were to include offset points:
        // g =
        //      (xj + rj - xi - ri).dot(n) - distance
        // dg/dt =
        //      (vj + wj x rj - vi - wi x ri).dot(n) =
        //      { term 2 is near zero } =
        //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =
        //      G * W
        // => G = [-n -rixn n rjxn]
        var r = vec2_1.default.create();
        var ri = vec2_1.default.create(); // worldAnchorA
        var rj = vec2_1.default.create(); // worldAnchorB
        var that = _this;
        normal.computeGq = function () {
            var bodyA = this.bodyA, bodyB = this.bodyB, xi = bodyA.position, xj = bodyB.position;
            // Transform local anchors to world
            vec2_1.default.rotate(ri, localAnchorA, bodyA.angle);
            vec2_1.default.rotate(rj, localAnchorB, bodyB.angle);
            vec2_1.default.add(r, xj, rj);
            vec2_1.default.subtract(r, r, ri);
            vec2_1.default.subtract(r, r, xi);
            //vec2.subtract(r, bodyB.position, bodyA.position);
            return vec2_1.default.length(r) - that.distance;
        };
        // Make the contact constraint bilateral
        _this.setMaxForce(maxForce);
        return _this;
    }
    /**
     * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
     * @method update
     */
    DistanceConstraint.prototype.update = function () {
        var normal = this.equations[0], bodyA = this.bodyA, bodyB = this.bodyB, xi = bodyA.position, xj = bodyB.position, normalEquation = this.equations[0], G = normal.G;
        // Transform local anchors to world
        vec2_1.default.rotate(ri, this.localAnchorA, bodyA.angle);
        vec2_1.default.rotate(rj, this.localAnchorB, bodyB.angle);
        // Get world anchor points and normal
        vec2_1.default.add(n, xj, rj);
        vec2_1.default.subtract(n, n, ri);
        vec2_1.default.subtract(n, n, xi);
        this.position = vec2_1.default.length(n);
        var violating = false;
        if (this.upperLimitEnabled) {
            if (this.position > this.upperLimit) {
                normalEquation.maxForce = 0;
                normalEquation.minForce = -this.maxForce;
                this.distance = this.upperLimit;
                violating = true;
            }
        }
        if (this.lowerLimitEnabled) {
            if (this.position < this.lowerLimit) {
                normalEquation.maxForce = this.maxForce;
                normalEquation.minForce = 0;
                this.distance = this.lowerLimit;
                violating = true;
            }
        }
        if ((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating) {
            // No constraint needed.
            normalEquation.enabled = false;
            return;
        }
        normalEquation.enabled = true;
        vec2_1.default.normalize(n, n);
        // Caluclate cross products
        var rixn = vec2_1.default.crossLength(ri, n), rjxn = vec2_1.default.crossLength(rj, n);
        // G = [-n -rixn n rjxn]
        G[0] = -n[0];
        G[1] = -n[1];
        G[2] = -rixn;
        G[3] = n[0];
        G[4] = n[1];
        G[5] = rjxn;
    };
    /**
     * Set the max force to be used
     * @method setMaxForce
     * @param {Number} maxForce
     */
    DistanceConstraint.prototype.setMaxForce = function (maxForce) {
        var normal = this.equations[0];
        normal.minForce = -maxForce;
        normal.maxForce = maxForce;
    };
    /**
     * Get the max force
     * @method getMaxForce
     * @return {Number}
     */
    DistanceConstraint.prototype.getMaxForce = function () {
        var normal = this.equations[0];
        return normal.maxForce;
    };
    return DistanceConstraint;
}(constraint_1.default));
exports.default = DistanceConstraint;

},{"../equations/Equation":14,"../math/vec2":28,"./constraint":8}],10:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var angle_lock_equation_1 = __importDefault(_dereq_("../equations/angle-lock-equation"));
var constraint_1 = __importDefault(_dereq_("./constraint"));
var GearConstraint = /** @class */ (function (_super) {
    __extends(GearConstraint, _super);
    /**
     * Constrains the angle of two bodies to each other to be equal. If a gear ratio is not one, the angle of bodyA must be a multiple of the angle of bodyB.
     * @class GearConstraint
     * @constructor
     * @author schteppe
     * @param {Body}            bodyA
     * @param {Body}            bodyB
     * @param {Object}          [options]
     * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).
     * @param {Number}          [options.ratio=1] Gear ratio.
     * @param {Number}          [options.maxTorque] Maximum torque to apply.
     * @extends Constraint
     *
     * @example
     *     var constraint = new GearConstraint(bodyA, bodyB);
     *     world.addConstraint(constraint);
     *
     * @example
     *     var constraint = new GearConstraint(bodyA, bodyB, {
     *         ratio: 2,
     *         maxTorque: 1000
     *     });
     *     world.addConstraint(constraint);
     */
    function GearConstraint(bodyA, bodyB, options) {
        var _a;
        var _this = this;
        options = options || {};
        _this = _super.call(this, bodyA, bodyB, constraint_1.default.GEAR, options) || this;
        /**
         * The gear ratio.
         * @property ratio
         * @type {Number}
         */
        _this.ratio = (_a = options === null || options === void 0 ? void 0 : options.ratio) !== null && _a !== void 0 ? _a : 1;
        /**
         * The relative angle
         * @property angle
         * @type {Number}
         */
        _this.angle = options.angle !== undefined ? options.angle : bodyB.angle - _this.ratio * bodyA.angle;
        // Send same parameters to the equation
        _this.equations = [
            new angle_lock_equation_1.default(bodyA, bodyB, {
                ratio: _this.ratio,
                angle: _this.angle
            }),
        ];
        // Set max torque
        if (options.maxTorque !== undefined) {
            _this.setMaxTorque(options.maxTorque);
        }
        return _this;
    }
    GearConstraint.prototype.update = function () {
        var eq = this.equations[0];
        var ratio = this.ratio;
        if (eq.ratio !== ratio) {
            eq.setRatio(ratio);
        }
        eq.angle = this.angle;
    };
    /**
     * Set the max torque for the constraint.
     * @method setMaxTorque
     * @param {Number} torque
     */
    GearConstraint.prototype.setMaxTorque = function (torque) {
        this.equations[0].setMaxTorque(torque);
    };
    /**
     * Get the max torque for the constraint.
     * @method getMaxTorque
     * @return {Number}
     */
    GearConstraint.prototype.getMaxTorque = function () {
        return this.equations[0].maxForce;
    };
    return GearConstraint;
}(constraint_1.default));
exports.default = GearConstraint;

},{"../equations/angle-lock-equation":15,"./constraint":8}],11:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var constraint_1 = __importDefault(_dereq_("./constraint"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var l = vec2_1.default.create();
var r = vec2_1.default.create();
var t = vec2_1.default.create();
var xAxis = vec2_1.default.fromValues(1, 0);
var yAxis = vec2_1.default.fromValues(0, 1);
var LockConstraint = /** @class */ (function (_super) {
    __extends(LockConstraint, _super);
    /**
     * Locks the relative position and rotation between two bodies.
     *
     * @class LockConstraint
     * @constructor
     * @author schteppe
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.
     * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.
     * @param {number} [options.maxForce]
     * @extends Constraint
     *
     * @example
     *     // Locks the relative position and rotation between bodyA and bodyB
     *     var constraint = new LockConstraint(bodyA, bodyB);
     *     world.addConstraint(constraint);
     */
    function LockConstraint(bodyA, bodyB, options) {
        //options = options || {};
        var _a, _b;
        var _this = _super.call(this, bodyA, bodyB, constraint_1.default.LOCK, options) || this;
        var maxForce = (_a = options === null || options === void 0 ? void 0 : options.maxForce) !== null && _a !== void 0 ? _a : Infinity;
        // Use 3 equations:
        // gx =   (xj - xi - l) * xhat = 0
        // gy =   (xj - xi - l) * yhat = 0
        // gr =   (xi - xj + r) * that = 0
        //
        // ...where:
        //   l is the localOffsetB vector rotated to world in bodyA frame
        //   r is the same vector but reversed and rotated from bodyB frame
        //   xhat, yhat are world axis vectors
        //   that is the tangent of r
        //
        // For the first two constraints, we get
        // G*W = (vj - vi - ldot  ) * xhat
        //     = (vj - vi - wi x l) * xhat
        //
        // Since (wi x l) * xhat = (l x xhat) * wi, we get
        // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]
        //
        // The last constraint gives
        // GW = (vi - vj + wj x r) * that
        //    = [  that   0  -that  (r x t) ]
        var x = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce), y = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce), rot = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce);
        var l = vec2_1.default.create(), g = vec2_1.default.create(), that = _this;
        x.computeGq = function () {
            vec2_1.default.rotate(l, that.localOffsetB, bodyA.angle);
            vec2_1.default.subtract(g, bodyB.position, bodyA.position);
            vec2_1.default.subtract(g, g, l);
            return g[0];
        };
        y.computeGq = function () {
            vec2_1.default.rotate(l, that.localOffsetB, bodyA.angle);
            vec2_1.default.subtract(g, bodyB.position, bodyA.position);
            vec2_1.default.subtract(g, g, l);
            return g[1];
        };
        var r = vec2_1.default.create(), t = vec2_1.default.create();
        rot.computeGq = function () {
            vec2_1.default.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
            vec2_1.default.scale(r, r, -1);
            vec2_1.default.subtract(g, bodyA.position, bodyB.position);
            vec2_1.default.add(g, g, r);
            vec2_1.default.rotate(t, r, -Math.PI / 2);
            vec2_1.default.normalize(t, t);
            return vec2_1.default.dot(g, t);
        };
        /**
         * The offset of bodyB in bodyA's frame.
         * @property {Array} localOffsetB
         */
        _this.localOffsetB = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.localOffsetB) {
            vec2_1.default.copy(_this.localOffsetB, options.localOffsetB);
        }
        else {
            // Construct from current positions
            vec2_1.default.subtract(_this.localOffsetB, bodyB.position, bodyA.position);
            vec2_1.default.rotate(_this.localOffsetB, _this.localOffsetB, -bodyA.angle);
        }
        /**
         * The offset angle of bodyB in bodyA's frame.
         * @property {Number} localAngleB
         */
        _this.localAngleB = (_b = options === null || options === void 0 ? void 0 : options.localAngleB) !== null && _b !== void 0 ? _b : bodyB.angle - bodyA.angle;
        _this.equations.push(x);
        _this.equations.push(y);
        _this.equations.push(rot);
        _this.setMaxForce(maxForce);
        return _this;
    }
    /**
     * Set the maximum force to be applied.
     * @method setMaxForce
     * @param {Number} force
     */
    LockConstraint.prototype.setMaxForce = function (force) {
        var eqs = this.equations;
        for (var i = 0; i < this.equations.length; i++) {
            eqs[i].maxForce = force;
            eqs[i].minForce = -force;
        }
    };
    /**
     * Get the max force.
     * @method getMaxForce
     * @return {Number}
     */
    LockConstraint.prototype.getMaxForce = function () {
        return this.equations[0].maxForce;
    };
    LockConstraint.prototype.update = function () {
        var x = this.equations[0], y = this.equations[1], rot = this.equations[2], bodyA = this.bodyA, bodyB = this.bodyB;
        vec2_1.default.rotate(l, this.localOffsetB, bodyA.angle);
        vec2_1.default.rotate(r, this.localOffsetB, bodyB.angle - this.localAngleB);
        vec2_1.default.scale(r, r, -1);
        vec2_1.default.rotate(t, r, Math.PI / 2);
        vec2_1.default.normalize(t, t);
        x.G[0] = -1;
        x.G[1] = 0;
        x.G[2] = -vec2_1.default.crossLength(l, xAxis);
        x.G[3] = 1;
        y.G[0] = 0;
        y.G[1] = -1;
        y.G[2] = -vec2_1.default.crossLength(l, yAxis);
        y.G[4] = 1;
        rot.G[0] = -t[0];
        rot.G[1] = -t[1];
        rot.G[3] = t[0];
        rot.G[4] = t[1];
        rot.G[5] = vec2_1.default.crossLength(r, t);
    };
    return LockConstraint;
}(constraint_1.default));
exports.default = LockConstraint;

},{"../equations/Equation":14,"../math/vec2":28,"./constraint":8}],12:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var constraint_1 = __importDefault(_dereq_("./constraint"));
var contact_equation_1 = __importDefault(_dereq_("../equations/contact-equation"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var rotational_lock_equation_1 = __importDefault(_dereq_("../equations/rotational-lock-equation"));
var worldAxisA = vec2_1.default.create(), worldAnchorA = vec2_1.default.create(), worldAnchorB = vec2_1.default.create(), orientedAnchorA = vec2_1.default.create(), orientedAnchorB = vec2_1.default.create(), tmp = vec2_1.default.create();
var PrismaticConstraint = /** @class */ (function (_super) {
    __extends(PrismaticConstraint, _super);
    /**
     * Constraint that only allows bodies to move along a line, relative to each other. See <a href="http://www.iforce2d.net/b2dtut/joints-prismatic">this tutorial</a>. Also called "slider constraint".
     *
     * @class PrismaticConstraint
     * @constructor
     * @extends Constraint
     * @author schteppe
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {Number} [options.maxForce] Max force to be applied by the constraint
     * @param {Array} [options.localAnchorA] Body A's anchor point, defined in its own local frame.
     * @param {Array} [options.localAnchorB] Body B's anchor point, defined in its own local frame.
     * @param {Array} [options.localAxisA] An axis, defined in body A frame, that body B's anchor point may slide along.
     * @param {Boolean} [options.disableRotationalLock] If set to true, bodyB will be free to rotate around its anchor point.
     * @param {Number} [options.upperLimit]
     * @param {Number} [options.lowerLimit]
     * @todo Ability to create using only a point and a worldAxis
     * @example
     *     var constraint = new PrismaticConstraint(bodyA, bodyB, {
     *         localAxisA: [0, 1]
     *     });
     *     world.addConstraint(constraint);
     */
    function PrismaticConstraint(bodyA, bodyB, options) {
        var _a, _b, _c;
        var _this = _super.call(this, bodyA, bodyB, constraint_1.default.PRISMATIC, options) || this;
        // Get anchors
        var localAnchorA = vec2_1.default.create(), localAxisA = vec2_1.default.fromValues(1, 0), localAnchorB = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.localAnchorA) {
            vec2_1.default.copy(localAnchorA, options.localAnchorA);
        }
        if (options === null || options === void 0 ? void 0 : options.localAxisA) {
            vec2_1.default.copy(localAxisA, options.localAxisA);
        }
        if (options === null || options === void 0 ? void 0 : options.localAnchorB) {
            vec2_1.default.copy(localAnchorB, options.localAnchorB);
        }
        _this.localAnchorA = localAnchorA;
        _this.localAnchorB = localAnchorB;
        _this.localAxisA = localAxisA;
        /*

        The constraint violation for the common axis point is

            g = ( xj + rj - xi - ri ) * t   :=  gg*t

        where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.

            gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )

        Note the use of the chain rule. Now we identify the jacobian

            G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]

        The rotational part is just a rotation lock.

        */
        var maxForce = _this.maxForce = (_a = options === null || options === void 0 ? void 0 : options.maxForce) !== null && _a !== void 0 ? _a : Infinity;
        // Translational part
        var trans = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce);
        var ri = vec2_1.default.create(), rj = vec2_1.default.create(), gg = vec2_1.default.create(), t = vec2_1.default.create();
        // TODO: This is a bad practice.
        trans.computeGq = function () {
            // g = ( xj + rj - xi - ri ) * t
            return vec2_1.default.dot(gg, t);
        };
        // TODO: This is a bad practice.
        trans.updateJacobian = function () {
            var G = this.G, xi = bodyA.position, xj = bodyB.position;
            vec2_1.default.rotate(ri, localAnchorA, bodyA.angle);
            vec2_1.default.rotate(rj, localAnchorB, bodyB.angle);
            vec2_1.default.add(gg, xj, rj);
            vec2_1.default.subtract(gg, gg, xi);
            vec2_1.default.subtract(gg, gg, ri);
            vec2_1.default.rotate(t, localAxisA, bodyA.angle + Math.PI / 2);
            G[0] = -t[0];
            G[1] = -t[1];
            G[2] = -vec2_1.default.crossLength(ri, t) + vec2_1.default.crossLength(t, gg);
            G[3] = t[0];
            G[4] = t[1];
            G[5] = vec2_1.default.crossLength(rj, t);
        };
        _this.equations.push(trans);
        // Rotational part
        if (!(options === null || options === void 0 ? void 0 : options.disableRotationalLock)) {
            var rot = new rotational_lock_equation_1.default(bodyA, bodyB);
            _this.equations.push(rot);
        }
        /**
         * The position of anchor A relative to anchor B, along the constraint axis.
         * @property position
         * @type {Number}
         */
        _this.position = 0;
        // Is this one used at all?
        _this.velocity = 0;
        /**
         * Set to true to enable lower limit.
         * @property lowerLimitEnabled
         * @type {Boolean}
         */
        _this.lowerLimitEnabled = (options === null || options === void 0 ? void 0 : options.lowerLimit) !== undefined ? true : false;
        /**
         * Set to true to enable upper limit.
         * @property upperLimitEnabled
         * @type {Boolean}
         */
        _this.upperLimitEnabled = (options === null || options === void 0 ? void 0 : options.upperLimit) !== undefined ? true : false;
        /**
         * Lower constraint limit. The constraint position is forced to be larger than this value.
         * @property lowerLimit
         * @type {Number}
         */
        _this.lowerLimit = (_b = options === null || options === void 0 ? void 0 : options.lowerLimit) !== null && _b !== void 0 ? _b : 0;
        /**
         * Upper constraint limit. The constraint position is forced to be smaller than this value.
         * @property upperLimit
         * @type {Number}
         */
        _this.upperLimit = (_c = options === null || options === void 0 ? void 0 : options.upperLimit) !== null && _c !== void 0 ? _c : 1;
        // Equations used for limits
        _this.upperLimitEquation = new contact_equation_1.default(bodyA, bodyB);
        _this.lowerLimitEquation = new contact_equation_1.default(bodyA, bodyB);
        // Set max/min forces
        _this.upperLimitEquation.minForce = _this.lowerLimitEquation.minForce = 0;
        _this.upperLimitEquation.maxForce = _this.lowerLimitEquation.maxForce = maxForce;
        /**
         * Equation used for the motor.
         * @property motorEquation
         * @type {Equation}
         */
        _this.motorEquation = new Equation_1.default(bodyA, bodyB);
        /**
         * The current motor state. Enable or disable the motor using .enableMotor
         * @property motorEnabled
         * @type {Boolean}
         */
        _this.motorEnabled = false;
        /**
         * Set the target speed for the motor.
         * @property motorSpeed
         * @type {Number}
         */
        _this.motorSpeed = 0;
        var that = _this;
        var motorEquation = _this.motorEquation;
        motorEquation.computeGq = function () { return 0; };
        motorEquation.computeGW = function () {
            var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
            return this.gmult(G, vi, wi, vj, wj) + that.motorSpeed;
        };
        return _this;
    }
    /**
     * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
     * @method update
     */
    PrismaticConstraint.prototype.update = function () {
        var eqs = this.equations, trans = eqs[0], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation, bodyA = this.bodyA, bodyB = this.bodyB, localAxisA = this.localAxisA, localAnchorA = this.localAnchorA, localAnchorB = this.localAnchorB;
        trans.updateJacobian();
        // Transform local things to world
        vec2_1.default.rotate(worldAxisA, localAxisA, bodyA.angle);
        vec2_1.default.rotate(orientedAnchorA, localAnchorA, bodyA.angle);
        vec2_1.default.add(worldAnchorA, orientedAnchorA, bodyA.position);
        vec2_1.default.rotate(orientedAnchorB, localAnchorB, bodyB.angle);
        vec2_1.default.add(worldAnchorB, orientedAnchorB, bodyB.position);
        var relPosition = this.position = vec2_1.default.dot(worldAnchorB, worldAxisA) - vec2_1.default.dot(worldAnchorA, worldAxisA);
        // Motor
        if (this.motorEnabled) {
            // G = [ a     a x ri   -a   -a x rj ]
            var G = this.motorEquation.G;
            G[0] = worldAxisA[0];
            G[1] = worldAxisA[1];
            G[2] = vec2_1.default.crossLength(worldAxisA, orientedAnchorB);
            G[3] = -worldAxisA[0];
            G[4] = -worldAxisA[1];
            G[5] = -vec2_1.default.crossLength(worldAxisA, orientedAnchorA);
        }
        /*
            Limits strategy:
            Add contact equation, with normal along the constraint axis.
            min/maxForce is set so the constraint is repulsive in the correct direction.
            Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.

                    ^
                    |
        upperLimit x
                    |    ------
            anchorB x<---|  B |
                    |    |    |
            ------   |    ------
            |    |   |
            |  A |-->x anchorA
            ------   |
                    x lowerLimit
                    |
                    axis
        */
        if (this.upperLimitEnabled && relPosition > upperLimit) {
            // Update contact constraint normal, etc
            vec2_1.default.scale(upperLimitEquation.normalA, worldAxisA, -1);
            vec2_1.default.subtract(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
            vec2_1.default.subtract(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
            vec2_1.default.scale(tmp, worldAxisA, upperLimit);
            vec2_1.default.add(upperLimitEquation.contactPointA, upperLimitEquation.contactPointA, tmp);
            if (eqs.indexOf(upperLimitEquation) === -1) {
                eqs.push(upperLimitEquation);
            }
        }
        else {
            var idx = eqs.indexOf(upperLimitEquation);
            if (idx !== -1) {
                eqs.splice(idx, 1);
            }
        }
        if (this.lowerLimitEnabled && relPosition < lowerLimit) {
            // Update contact constraint normal, etc
            vec2_1.default.scale(lowerLimitEquation.normalA, worldAxisA, 1);
            vec2_1.default.subtract(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
            vec2_1.default.subtract(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
            vec2_1.default.scale(tmp, worldAxisA, lowerLimit);
            vec2_1.default.subtract(lowerLimitEquation.contactPointB, lowerLimitEquation.contactPointB, tmp);
            if (eqs.indexOf(lowerLimitEquation) === -1) {
                eqs.push(lowerLimitEquation);
            }
        }
        else {
            var idx = eqs.indexOf(lowerLimitEquation);
            if (idx !== -1) {
                eqs.splice(idx, 1);
            }
        }
    };
    /**
     * Enable the motor
     * @method enableMotor
     */
    PrismaticConstraint.prototype.enableMotor = function () {
        if (this.motorEnabled) {
            return;
        }
        this.equations.push(this.motorEquation);
        this.motorEnabled = true;
    };
    /**
     * Disable the rotational motor
     * @method disableMotor
     */
    PrismaticConstraint.prototype.disableMotor = function () {
        if (!this.motorEnabled) {
            return;
        }
        var i = this.equations.indexOf(this.motorEquation);
        this.equations.splice(i, 1);
        this.motorEnabled = false;
    };
    /**
     * Set the constraint limits.
     * @method setLimits
     * @param {number} lower Lower limit.
     * @param {number} upper Upper limit.
     */
    PrismaticConstraint.prototype.setLimits = function (lower, upper) {
        if (typeof (lower) === 'number') {
            this.lowerLimit = lower;
            this.lowerLimitEnabled = true;
        }
        else {
            this.lowerLimit = lower;
            this.lowerLimitEnabled = false;
        }
        if (typeof (upper) === 'number') {
            this.upperLimit = upper;
            this.upperLimitEnabled = true;
        }
        else {
            this.upperLimit = upper;
            this.upperLimitEnabled = false;
        }
    };
    return PrismaticConstraint;
}(constraint_1.default));
exports.default = PrismaticConstraint;

},{"../equations/Equation":14,"../equations/contact-equation":16,"../equations/rotational-lock-equation":19,"../math/vec2":28,"./constraint":8}],13:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var constraint_1 = __importDefault(_dereq_("./constraint"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var rotational_velocity_equation_1 = __importDefault(_dereq_("../equations/rotational-velocity-equation"));
var rotational_lock_equation_1 = __importDefault(_dereq_("../equations/rotational-lock-equation"));
var sub = vec2_1.default.subtract;
var add = vec2_1.default.add;
var dot = vec2_1.default.dot;
var rotate = vec2_1.default.rotate;
var copy = vec2_1.default.copy;
var crossLength = vec2_1.default.crossLength;
var worldPivotA = vec2_1.default.create(), worldPivotB = vec2_1.default.create(), xAxis = vec2_1.default.fromValues(1, 0), yAxis = vec2_1.default.fromValues(0, 1), g = vec2_1.default.create();
var RevoluteConstraint = /** @class */ (function (_super) {
    __extends(RevoluteConstraint, _super);
    /**
     * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
     * @class RevoluteConstraint
     * @constructor
     * @author schteppe
     * @param {Body}    bodyA
     * @param {Body}    bodyB
     * @param {Object}  [options]
     * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.
     * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.
     * @param {Array}   [options.localPivotB] See localPivotA.
     * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.
     * @extends Constraint
     *
     * @example
     *     // This will create a revolute constraint between two bodies with pivot point in between them.
     *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
     *     world.addBody(bodyA);
     *
     *     var bodyB = new Body({ mass: 1, position: [1, 0] });
     *     world.addBody(bodyB);
     *
     *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
     *         worldPivot: [0, 0]
     *     });
     *     world.addConstraint(constraint);
     *
     *     // Using body-local pivot points, the constraint could have been constructed like this:
     *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
     *         localPivotA: [1, 0],
     *         localPivotB: [-1, 0]
     *     });
     */
    function RevoluteConstraint(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, constraint_1.default.REVOLUTE, options) || this;
        var maxForce = _this.maxForce = (_a = options === null || options === void 0 ? void 0 : options.maxForce) !== null && _a !== void 0 ? _a : Infinity;
        var pivotA = _this.pivotA = vec2_1.default.create();
        var pivotB = _this.pivotB = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.worldPivot) {
            // Compute pivotA and pivotB
            sub(pivotA, options.worldPivot, bodyA.position);
            sub(pivotB, options.worldPivot, bodyB.position);
            // Rotate to local coordinate system
            rotate(pivotA, pivotA, -bodyA.angle);
            rotate(pivotB, pivotB, -bodyB.angle);
        }
        else {
            // Get pivotA and pivotB
            if (options === null || options === void 0 ? void 0 : options.localPivotA) {
                copy(pivotA, options.localPivotA);
            }
            if (options === null || options === void 0 ? void 0 : options.localPivotB) {
                copy(pivotB, options.localPivotB);
            }
        }
        var motorEquation = _this.motorEquation = new rotational_velocity_equation_1.default(bodyA, bodyB);
        motorEquation.enabled = false;
        var upperLimitEquation = _this.upperLimitEquation = new rotational_lock_equation_1.default(bodyA, bodyB);
        var lowerLimitEquation = _this.lowerLimitEquation = new rotational_lock_equation_1.default(bodyA, bodyB);
        upperLimitEquation.minForce = lowerLimitEquation.maxForce = 0;
        // Equations to be fed to the solver
        var eqs = _this.equations = [
            new Equation_1.default(bodyA, bodyB, -maxForce, maxForce),
            new Equation_1.default(bodyA, bodyB, -maxForce, maxForce),
            motorEquation,
            upperLimitEquation,
            lowerLimitEquation
        ];
        var x = eqs[0];
        var y = eqs[1];
        // TODO: bad practice.
        x.computeGq = function () {
            rotate(worldPivotA, pivotA, bodyA.angle);
            rotate(worldPivotB, pivotB, bodyB.angle);
            add(g, bodyB.position, worldPivotB);
            sub(g, g, bodyA.position);
            sub(g, g, worldPivotA);
            return dot(g, xAxis);
        };
        y.computeGq = function () {
            rotate(worldPivotA, pivotA, bodyA.angle);
            rotate(worldPivotB, pivotB, bodyB.angle);
            add(g, bodyB.position, worldPivotB);
            sub(g, g, bodyA.position);
            sub(g, g, worldPivotA);
            return dot(g, yAxis);
        };
        y.minForce = x.minForce = -maxForce;
        y.maxForce = x.maxForce = maxForce;
        // These never change but the angular parts do
        x.G[0] = -1;
        x.G[1] = 0;
        x.G[3] = 1;
        x.G[4] = 0;
        y.G[0] = 0;
        y.G[1] = -1;
        y.G[3] = 0;
        y.G[4] = 1;
        _this.angle = 0;
        _this.lowerLimitEnabled = false;
        _this.upperLimitEnabled = false;
        _this.lowerLimit = 0;
        _this.upperLimit = 0;
        return _this;
    }
    /**
     * Set the constraint angle limits, and enable them.
     * @method setLimits
     * @param {number} lower Lower angle limit.
     * @param {number} upper Upper angle limit.
     */
    RevoluteConstraint.prototype.setLimits = function (lower, upper) {
        this.lowerLimit = lower;
        this.upperLimit = upper;
        this.lowerLimitEnabled = this.upperLimitEnabled = true;
    };
    RevoluteConstraint.prototype.update = function () {
        var bodyA = this.bodyA, bodyB = this.bodyB, pivotA = this.pivotA, pivotB = this.pivotB, eqs = this.equations, x = eqs[0], y = eqs[1], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation;
        var relAngle = this.angle = bodyB.angle - bodyA.angle;
        upperLimitEquation.angle = upperLimit;
        upperLimitEquation.enabled = this.upperLimitEnabled && relAngle > upperLimit;
        lowerLimitEquation.angle = lowerLimit;
        lowerLimitEquation.enabled = this.lowerLimitEnabled && relAngle < lowerLimit;
        /*

        The constraint violation is

            g = xj + rj - xi - ri

        ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:

            gdot = vj + wj x rj - vi - wi x ri

        We split this into x and y directions. (let x and y be unit vectors along the respective axes)

            gdot * x = ( vj + wj x rj - vi - wi x ri ) * x
                    = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x
                    = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi
                    = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]
                    = G*W

        ...and similar for y. We have then identified the jacobian entries for x and y directions:

            Gx = [ x   (rj x x)   -x   -(ri x x)]
            Gy = [ y   (rj x y)   -y   -(ri x y)]

        So for example, in the X direction we would get in 2 dimensions

            G = [ [1   0   (rj x [1,0])   -1   0   -(ri x [1,0])]
                [0   1   (rj x [0,1])    0  -1   -(ri x [0,1])]
        */
        rotate(worldPivotA, pivotA, bodyA.angle);
        rotate(worldPivotB, pivotB, bodyB.angle);
        // @todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc
        var xG = x.G;
        xG[2] = -crossLength(worldPivotA, xAxis);
        xG[5] = crossLength(worldPivotB, xAxis);
        var yG = y.G;
        yG[2] = -crossLength(worldPivotA, yAxis);
        yG[5] = crossLength(worldPivotB, yAxis);
    };
    Object.defineProperty(RevoluteConstraint.prototype, "motorEnabled", {
        /**
         * @property {boolean} motorEnabled
         */
        get: function () {
            return this.motorEquation.enabled;
        },
        set: function (value) {
            this.motorEquation.enabled = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RevoluteConstraint.prototype, "motorSpeed", {
        /**
         * @property {number} motorSpeed
         */
        get: function () {
            return this.motorEquation.relativeVelocity;
        },
        set: function (value) {
            this.motorEquation.relativeVelocity = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RevoluteConstraint.prototype, "motorMaxForce", {
        /**
         * @property {number} motorMaxForce
         */
        get: function () {
            return this.motorEquation.maxForce;
        },
        set: function (value) {
            var eq = this.motorEquation;
            eq.maxForce = value;
            eq.minForce = -value;
        },
        enumerable: false,
        configurable: true
    });
    return RevoluteConstraint;
}(constraint_1.default));
exports.default = RevoluteConstraint;

},{"../equations/Equation":14,"../equations/rotational-lock-equation":19,"../equations/rotational-velocity-equation":20,"../math/vec2":28,"./constraint":8}],14:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
// Shortcuts.
var scale = vec2_1.default.scale, multiply = vec2_1.default.multiply, createVec2 = vec2_1.default.create;
var Equation = /** @class */ (function () {
    /**
     * Base class for constraint equations.
     * @class Equation
     * @constructor
     * @param {Body} bodyA First body participating in the equation
     * @param {Body} bodyB Second body participating in the equation
     * @param {number} minForce Minimum force to apply. Default: -Infinity
     * @param {number} maxForce Maximum force to apply. Default: Infinity
     */
    function Equation(bodyA, bodyB, minForce, maxForce) {
        /**
         * Cap the constraint violation (G*q) to this value.
         * @property maxBias
         * @type {Number}
         */
        this.maxBias = Infinity;
        /**
         * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.
         * @property stiffness
         * @type {Number}
         */
        this.stiffness = Equation.DEFAULT_STIFFNESS;
        /**
         * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.
         * @property relaxation
         * @type {Number}
         */
        this.relaxation = Equation.DEFAULT_RELAXATION;
        this.offset = 0;
        this.a = 0;
        this.b = 0;
        this.epsilon = 0;
        this.timeStep = 1 / 60;
        /**
         * Indicates if stiffness or relaxation was changed.
         * @property {Boolean} needsUpdate
         */
        this.needsUpdate = true;
        /**
         * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.
         * @property multiplier
         * @type {Number}
         */
        this.multiplier = 0;
        /**
         * Relative velocity.
         * @property {Number} relativeVelocity
         */
        this.relativeVelocity = 0;
        /**
         * Whether this equation is enabled or not. If true, it will be added to the solver.
         * @property {Boolean} enabled
         */
        this.enabled = true;
        // Temp stuff
        this.maxForceDt = 0;
        this.minForceDt = 0;
        this.invC = 0;
        this.B = 0;
        this.lambda = 0;
        this.index = -1;
        this.minForce = minForce !== null && minForce !== void 0 ? minForce : -Infinity;
        this.maxForce = maxForce !== null && maxForce !== void 0 ? maxForce : Infinity;
        this.maxBias = Infinity;
        this.bodyA = bodyA !== null && bodyA !== void 0 ? bodyA : null;
        this.bodyB = bodyB !== null && bodyB !== void 0 ? bodyB : null;
        this.stiffness = Equation.DEFAULT_STIFFNESS;
        this.relaxation = Equation.DEFAULT_RELAXATION;
        this.G = new Float32Array(6);
        for (var i = 0; i < 6; i++) {
            this.G[i] = 0;
        }
    }
    /**
     * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href="http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf">SPOOK notes</a>.
     * @method update
     */
    Equation.prototype.update = function () {
        var k = this.stiffness, d = this.relaxation, h = this.timeStep;
        this.a = 4 / (h * (1 + 4 * d));
        this.b = (4 * d) / (1 + 4 * d);
        this.epsilon = 4 / (h * h * k * (1 + 4 * d));
        this.needsUpdate = false;
    };
    /**
     * Multiply a jacobian entry with corresponding positions or velocities
     * @method gmult
     * @return {Number}
     */
    Equation.prototype.gmult = function (G, vi, wi, vj, wj) {
        return G[0] * vi[0] +
            G[1] * vi[1] +
            G[2] * wi +
            G[3] * vj[0] +
            G[4] * vj[1] +
            G[5] * wj;
    };
    /**
     * Computes the RHS of the SPOOK equation
     * @method computeB
     * @return {Number}
     */
    Equation.prototype.computeB = function (a, b, h) {
        var GW = this.computeGW();
        var Gq = this.computeGq();
        var maxBias = this.maxBias;
        if (Math.abs(Gq) > maxBias) {
            Gq = Gq > 0 ? maxBias : -maxBias;
        }
        var GiMf = this.computeGiMf();
        var B = -Gq * a - GW * b - GiMf * h;
        return B;
    };
    /**
     * Computes G\*q, where q are the generalized body coordinates
     * @method computeGq
     * @return {Number}
     */
    Equation.prototype.computeGq = function () {
        var G = this.G, bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var ai = bi.angle, aj = bj.angle;
        var qi = createVec2(), qj = createVec2();
        return this.gmult(G, qi, ai, qj, aj) + this.offset;
    };
    /**
     * Computes G\*W, where W are the body velocities
     * @method computeGW
     * @return {Number}
     */
    Equation.prototype.computeGW = function () {
        var G = this.G, bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
        return this.gmult(G, vi, wi, vj, wj) + this.relativeVelocity;
    };
    /**
     * Computes G\*Wlambda, where W are the body velocities
     * @method computeGWlambda
     * @return {Number}
     */
    Equation.prototype.computeGWlambda = function () {
        var G = this.G, bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var vi = bi.vlambda, vj = bj.vlambda, wi = bi.wlambda, wj = bj.wlambda;
        return this.gmult(G, vi, wi, vj, wj);
    };
    /**
     * Computes G\*inv(M)\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
     * @method computeGiMf
     * @return {Number}
     */
    Equation.prototype.computeGiMf = function () {
        var bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var fi = bi.force, ti = bi.angularForce, fj = bj.force, tj = bj.angularForce, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
        var iMfi = createVec2(), iMfj = createVec2();
        scale(iMfi, fi, invMassi);
        multiply(iMfi, bi.massMultiplier, iMfi);
        scale(iMfj, fj, invMassj);
        multiply(iMfj, bj.massMultiplier, iMfj);
        return this.gmult(G, iMfi, ti * invIi, iMfj, tj * invIj);
    };
    /**
     * Computes G\*inv(M)\*G'
     * @method computeGiMGt
     * @return {Number}
     */
    Equation.prototype.computeGiMGt = function () {
        var bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
        return G[0] * G[0] * invMassi * bi.massMultiplier[0] +
            G[1] * G[1] * invMassi * bi.massMultiplier[1] +
            G[2] * G[2] * invIi +
            G[3] * G[3] * invMassj * bj.massMultiplier[0] +
            G[4] * G[4] * invMassj * bj.massMultiplier[1] +
            G[5] * G[5] * invIj;
    };
    Equation.prototype.updateJacobian = function () { };
    ;
    /**
     * Add constraint velocity to the bodies.
     * @method addToWlambda
     * @param {Number} deltalambda
     */
    Equation.prototype.addToWlambda = function (deltalambda) {
        var bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return;
        var invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
        // v_lambda = G * inv(M) * delta_lambda
        addToVLambda(bi.vlambda, G[0], G[1], invMassi, deltalambda, bi.massMultiplier);
        bi.wlambda += invIi * G[2] * deltalambda;
        addToVLambda(bj.vlambda, G[3], G[4], invMassj, deltalambda, bj.massMultiplier);
        bj.wlambda += invIj * G[5] * deltalambda;
    };
    /**
     * Compute the denominator part of the SPOOK equation: C = G\*inv(M)\*G' + eps
     * @method computeInvC
     * @param  {Number} eps
     * @return {Number}
     */
    Equation.prototype.computeInvC = function (eps) {
        var invC = 1 / (this.computeGiMGt() + eps);
        return invC;
    };
    /**
     * The default stiffness when creating a new Equation.
     * @static
     * @property {Number} DEFAULT_STIFFNESS
     * @default 1e6
     */
    Equation.DEFAULT_STIFFNESS = 1e6;
    /**
     * The default relaxation when creating a new Equation.
     * @static
     * @property {Number} DEFAULT_RELAXATION
     * @default 4
     */
    Equation.DEFAULT_RELAXATION = 4;
    return Equation;
}());
exports.default = Equation;
function addToVLambda(vlambda, Gx, Gy, invMass, deltalambda, massMultiplier) {
    vlambda[0] += Gx * invMass * deltalambda * massMultiplier[0];
    vlambda[1] += Gy * invMass * deltalambda * massMultiplier[1];
}

},{"../math/vec2":28}],15:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Equation_1 = __importDefault(_dereq_("./Equation"));
var AngleLockEquation = /** @class */ (function (_super) {
    __extends(AngleLockEquation, _super);
    /**
     * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
     *
     * @class AngleLockEquation
     * @constructor
     * @extends Equation
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {Number} [options.angle] Angle to add to the local vector in body A.
     * @param {Number} [options.ratio] Gear ratio
     */
    function AngleLockEquation(bodyA, bodyB, options) {
        var _a, _b;
        var _this = _super.call(this, bodyA, bodyB, -Infinity, Infinity) || this;
        _this.angle = (_a = options === null || options === void 0 ? void 0 : options.angle) !== null && _a !== void 0 ? _a : 0;
        _this.ratio = (_b = options === null || options === void 0 ? void 0 : options.ratio) !== null && _b !== void 0 ? _b : 1;
        _this.setRatio(_this.ratio);
        return _this;
    }
    AngleLockEquation.prototype.computeGq = function () {
        return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
    };
    /**
     * Set the gear ratio for this equation
     * @method setRatio
     * @param {Number} ratio
     */
    AngleLockEquation.prototype.setRatio = function (ratio) {
        var G = this.G;
        G[2] = ratio;
        G[5] = -1;
        this.ratio = ratio;
    };
    /**
     * Set the max force for the equation.
     * @method setMaxTorque
     * @param {Number} torque
     */
    AngleLockEquation.prototype.setMaxTorque = function (torque) {
        this.maxForce = torque;
        this.minForce = -torque;
    };
    return AngleLockEquation;
}(Equation_1.default));
exports.default = AngleLockEquation;

},{"./Equation":14}],16:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Equation_1 = __importDefault(_dereq_("./Equation"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
function addSubSub(out, a, b, c, d) {
    out[0] = a[0] + b[0] - c[0] - d[0];
    out[1] = a[1] + b[1] - c[1] - d[1];
}
var vi = vec2_1.default.create();
var vj = vec2_1.default.create();
var relVel = vec2_1.default.create();
var ContactEquation = /** @class */ (function (_super) {
    __extends(ContactEquation, _super);
    /**
     * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.
     *
     * @class ContactEquation
     * @constructor
     * @extends Equation
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    function ContactEquation(bodyA, bodyB) {
        var _this = _super.call(this, bodyA, bodyB, 0, Infinity) || this;
        /**
         * Vector from body i center of mass to the contact point.
         * @property contactPointA
         * @type {Array}
         */
        _this.contactPointA = vec2_1.default.create();
        _this.penetrationVec = vec2_1.default.create();
        /**
         * World-oriented vector from body A center of mass to the contact point.
         * @property contactPointB
         * @type {Array}
         */
        _this.contactPointB = vec2_1.default.create();
        /**
         * The normal vector, pointing out of body i
         * @property normalA
         * @type {Array}
         */
        _this.normalA = vec2_1.default.create();
        /**
         * The restitution to use (0=no bounciness, 1=max bounciness).
         * @property restitution
         * @type {Number}
         */
        _this.restitution = 0;
        /**
         * This property is set to true if this is the first impact between the bodies (not persistant contact).
         * @property firstImpact
         * @type {Boolean}
         * @readOnly
         */
        _this.firstImpact = false;
        /**
         * The shape in body i that triggered this contact.
         * @property shapeA
         * @type {Shape}
         */
        _this.shapeA = null;
        /**
         * The shape in body j that triggered this contact.
         * @property shapeB
         * @type {Shape}
         */
        _this.shapeB = null;
        return _this;
    }
    ContactEquation.prototype.computeB = function (a, b, h) {
        var _a, _b;
        var bi = this.bodyA, bj = this.bodyB, ri = this.contactPointA, rj = this.contactPointB, xi = (_a = bi === null || bi === void 0 ? void 0 : bi.position) !== null && _a !== void 0 ? _a : new Float32Array(2), xj = (_b = bj === null || bj === void 0 ? void 0 : bj.position) !== null && _b !== void 0 ? _b : new Float32Array(2);
        var n = this.normalA, G = this.G;
        // Caluclate cross products
        var rixn = vec2_1.default.crossLength(ri, n), rjxn = vec2_1.default.crossLength(rj, n);
        // G = [-n -rixn n rjxn]
        G[0] = -n[0];
        G[1] = -n[1];
        G[2] = -rixn;
        G[3] = n[0];
        G[4] = n[1];
        G[5] = rjxn;
        // Compute iteration
        var GW, Gq;
        if (this.firstImpact && this.restitution !== 0) {
            Gq = 0;
            GW = (1 / b) * (1 + this.restitution) * this.computeGW();
        }
        else {
            // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector
            var penetrationVec = this.penetrationVec;
            addSubSub(penetrationVec, xj, rj, xi, ri);
            Gq = vec2_1.default.dot(n, penetrationVec) + this.offset;
            GW = this.computeGW();
        }
        var GiMf = this.computeGiMf();
        var B = -Gq * a - GW * b - h * GiMf;
        return B;
    };
    ;
    /**
     * Get the relative velocity along the normal vector.
     * @method getVelocityAlongNormal
     * @return {number}
     */
    ContactEquation.prototype.getVelocityAlongNormal = function () {
        this.bodyA && this.bodyA.getVelocityAtPoint(vi, this.contactPointA);
        this.bodyB && this.bodyB.getVelocityAtPoint(vj, this.contactPointB);
        vec2_1.default.subtract(relVel, vi, vj);
        return vec2_1.default.dot(this.normalA, relVel);
    };
    ;
    return ContactEquation;
}(Equation_1.default));
exports.default = ContactEquation;

},{"../math/vec2":28,"./Equation":14}],17:[function(_dereq_,module,exports){
module.exports=_dereq_(14)
},{"../math/vec2":28}],18:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Equation_1 = __importDefault(_dereq_("./Equation"));
var FrictionEquation = /** @class */ (function (_super) {
    __extends(FrictionEquation, _super);
    /**
     * Constrains the slipping in a contact along a tangent
     *
     * @class FrictionEquation
     * @constructor
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Number} slipForce
     * @extends Equation
     */
    function FrictionEquation(bodyA, bodyB, slipForce) {
        if (slipForce === void 0) { slipForce = Infinity; }
        var _this = _super.call(this, bodyA, bodyB, -slipForce, slipForce) || this;
        /**
         * Relative vector from center of body A to the contact point, world oriented.
         * @property contactPointA
         * @type {Array}
         */
        _this.contactPointA = vec2_1.default.create();
        /**
         * Relative vector from center of body B to the contact point, world oriented.
         * @property contactPointB
         * @type {Array}
         */
        _this.contactPointB = vec2_1.default.create();
        /**
         * Tangent vector that the friction force will act along. World oriented.
         * @property t
         * @type {Array}
         */
        _this.t = vec2_1.default.create();
        /**
         * ContactEquations connected to this friction equation. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.
         * @property contactEquations
         * @type {ContactEquation[]}
         */
        _this.contactEquations = [];
        /**
         * The shape in body i that triggered this friction.
         * @property shapeA
         * @type {Shape}
         * @todo Needed? The shape can be looked up via contactEquation.shapeA...
         */
        _this.shapeA = null;
        /**
         * The shape in body j that triggered this friction.
         * @property shapeB
         * @type {Shape}
         * @todo Needed? The shape can be looked up via contactEquation.shapeB...
         */
        _this.shapeB = null;
        /**
         * The friction coefficient to use.
         * @property frictionCoefficient
         * @type {Number}
         */
        _this.frictionCoefficient = 0.3;
        return _this;
    }
    /**
     * Set the slipping condition for the constraint. The friction force cannot be
     * larger than this value.
     * @method setSlipForce
     * @param  {Number} slipForce
     */
    FrictionEquation.prototype.setSlipForce = function (slipForce) {
        this.maxForce = slipForce;
        this.minForce = -slipForce;
    };
    ;
    /**
     * Get the max force for the constraint.
     * @method getSlipForce
     * @return {Number}
     */
    FrictionEquation.prototype.getSlipForce = function () {
        return this.maxForce;
    };
    ;
    FrictionEquation.prototype.computeB = function (a, b, h) {
        var ri = this.contactPointA, rj = this.contactPointB, t = this.t, G = this.G;
        // G = [-t -rixt t rjxt]
        // And remember, this is a pure velocity constraint, g is always zero!
        G[0] = -t[0];
        G[1] = -t[1];
        G[2] = -vec2_1.default.crossLength(ri, t);
        G[3] = t[0];
        G[4] = t[1];
        G[5] = vec2_1.default.crossLength(rj, t);
        var GW = this.computeGW(), GiMf = this.computeGiMf();
        var B = /* - g * a  */ -GW * b - h * GiMf;
        return B;
    };
    ;
    return FrictionEquation;
}(Equation_1.default));
exports.default = FrictionEquation;

},{"../math/vec2":28,"./Equation":14}],19:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Equation_1 = __importDefault(_dereq_("./Equation"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var worldVectorA = vec2_1.default.create(), worldVectorB = vec2_1.default.create(), xAxis = vec2_1.default.fromValues(1, 0), yAxis = vec2_1.default.fromValues(0, 1);
var RotationalLockEquation = /** @class */ (function (_super) {
    __extends(RotationalLockEquation, _super);
    /**
     * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
     *
     * @class RotationalLockEquation
     * @constructor
     * @extends Equation
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {Number} [options.angle] Angle to add to the local vector in bodyA.
     */
    function RotationalLockEquation(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, -Infinity, Infinity) || this;
        _this.angle = (_a = options === null || options === void 0 ? void 0 : options.angle) !== null && _a !== void 0 ? _a : 0;
        var G = _this.G;
        G[2] = 1;
        G[5] = -1;
        return _this;
    }
    RotationalLockEquation.prototype.computeGq = function () {
        vec2_1.default.rotate(worldVectorA, xAxis, this.bodyA.angle + this.angle);
        vec2_1.default.rotate(worldVectorB, yAxis, this.bodyB.angle);
        return vec2_1.default.dot(worldVectorA, worldVectorB);
    };
    ;
    return RotationalLockEquation;
}(Equation_1.default));
exports.default = RotationalLockEquation;

},{"../math/vec2":28,"./Equation":14}],20:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Equation_1 = __importDefault(_dereq_("./Equation"));
var RotationalVelocityEquation = /** @class */ (function (_super) {
    __extends(RotationalVelocityEquation, _super);
    /**
     * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).
     *
     * @class RotationalVelocityEquation
     * @constructor
     * @extends Equation
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    function RotationalVelocityEquation(bodyA, bodyB) {
        var _this = _super.call(this, bodyA, bodyB, -Infinity, Infinity) || this;
        _this.relativeVelocity = 1;
        _this.ratio = 1;
        return _this;
    }
    RotationalVelocityEquation.prototype.computeB = function (a, b, h) {
        var G = this.G;
        G[2] = -1;
        G[5] = this.ratio;
        var GiMf = this.computeGiMf();
        var GW = this.computeGW();
        var B = -GW * b - h * GiMf;
        return B;
    };
    return RotationalVelocityEquation;
}(Equation_1.default));
exports.default = RotationalVelocityEquation;

},{"./Equation":14}],21:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Base class for objects that dispatches events.
 * @class EventEmitter
 * @example
 *     var emitter = new EventEmitter();
 *     emitter.on('myEvent', function(evt){
 *         console.log(evt.message);
 *     });
 *     emitter.emit({
 *         type: 'myEvent',
 *         message: 'Hello world!'
 *     });
 */
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this._listeners = {};
        this._contexts = {};
    }
    /**
     * Add an event listener
     * @method on
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     * @example
     *     emitter.on('myEvent', function(evt){
     *         console.log('myEvt was triggered!');
     *     });
     */
    EventEmitter.prototype.on = function (type, listener, context) {
        if (this._listeners[type] === undefined) {
            this._listeners[type] = [];
            this._contexts[type] = [];
        }
        if (this._listeners[type].indexOf(listener) === -1) {
            this._listeners[type].push(listener);
            this._contexts[type].push(context);
        }
        return this;
    };
    /**
     * Remove an event listener
     * @method off
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     * @example
     *     emitter.on('myEvent', handler); // Add handler
     *     emitter.off('myEvent', handler); // Remove handler
     */
    EventEmitter.prototype.off = function (type, listener) {
        if (!this._listeners || !this._listeners[type]) {
            return this;
        }
        var index = this._listeners[type].indexOf(listener);
        if (index !== -1) {
            this._listeners[type].splice(index, 1);
            this._contexts[type].splice(index, 1);
        }
        return this;
    };
    /**
     * Check if an event listener is added
     * @method has
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    EventEmitter.prototype.has = function (type, listener) {
        if (this._listeners === undefined) {
            return false;
        }
        var listeners = this._listeners;
        if (listener) {
            if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
                return true;
            }
        }
        else {
            if (listeners[type] !== undefined) {
                return true;
            }
        }
        return false;
    };
    /**
     * Emit an event.
     * @method emit
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventEmitter} The self object, for chainability.
     * @example
     *     emitter.emit({
     *         type: 'myEvent',
     *         customData: 123
     *     });
     */
    // TODO: the unknown type here is disturbing.
    EventEmitter.prototype.emit = function (event) {
        if (this._listeners === undefined) {
            return this;
        }
        var listenerArray = this._listeners[event.type];
        var contextArray = this._contexts[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            // Need to copy the listener array, in case some listener was added/removed inside a listener
            var tmpListenerArray = [];
            var tmpContextArray = [];
            for (var i = 0, l = listenerArray.length; i < l; i++) {
                tmpListenerArray.push(listenerArray[i]);
                tmpContextArray.push(contextArray[i]);
            }
            for (var i = 0, l = listenerArray.length; i < l; i++) {
                var listener = listenerArray[i];
                var context = contextArray[i];
                listener.call(context, event);
            }
        }
        return this;
    };
    return EventEmitter;
}());
exports.default = EventEmitter;

},{}],22:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.version = exports.vec2 = exports.World = exports.Utils = exports.RotationalSpring = exports.LinearSpring = exports.TopDownVehicle = exports.Spring = exports.Solver = exports.Shape = exports.SAPBroadphase = exports.RotationalVelocityEquation = exports.Box = exports.RaycastResult = exports.Ray = exports.PrismaticConstraint = exports.RevoluteConstraint = exports.Pool = exports.Plane = exports.Particle = exports.NaiveBroadphase = exports.Narrowphase = exports.Material = exports.LockConstraint = exports.Line = exports.Heightfield = exports.GSSolver = exports.GearConstraint = exports.FrictionEquationPool = exports.FrictionEquation = exports.EventEmitter = exports.Equation = exports.DistanceConstraint = exports.Convex = exports.ContactMaterial = exports.ContactEquationPool = exports.ContactEquation = exports.Constraint = exports.Circle = exports.Capsule = exports.Broadphase = exports.Body = exports.AngleLockEquation = exports.AABB = void 0;
var aabb_1 = __importDefault(_dereq_("./collision/aabb"));
exports.AABB = aabb_1.default;
var angle_lock_equation_1 = __importDefault(_dereq_("./equations/angle-lock-equation"));
exports.AngleLockEquation = angle_lock_equation_1.default;
var body_1 = __importDefault(_dereq_("./objects/body"));
exports.Body = body_1.default;
var broadphase_1 = __importDefault(_dereq_("./collision/broadphase"));
exports.Broadphase = broadphase_1.default;
var capsule_1 = __importDefault(_dereq_("./shapes/capsule"));
exports.Capsule = capsule_1.default;
var circle_1 = __importDefault(_dereq_("./shapes/circle"));
exports.Circle = circle_1.default;
var constraint_1 = __importDefault(_dereq_("./constraints/constraint"));
exports.Constraint = constraint_1.default;
var contact_equation_1 = __importDefault(_dereq_("./equations/contact-equation"));
exports.ContactEquation = contact_equation_1.default;
var contact_equation_pool_1 = __importDefault(_dereq_("./utils/contact-equation-pool"));
exports.ContactEquationPool = contact_equation_pool_1.default;
var contact_material_1 = __importDefault(_dereq_("./material/contact-material"));
exports.ContactMaterial = contact_material_1.default;
var convex_1 = __importDefault(_dereq_("./shapes/convex"));
exports.Convex = convex_1.default;
var distance_constraint_1 = __importDefault(_dereq_("./constraints/distance-constraint"));
exports.DistanceConstraint = distance_constraint_1.default;
var equation_1 = __importDefault(_dereq_("./equations/equation"));
exports.Equation = equation_1.default;
var event_emitter_1 = __importDefault(_dereq_("./events/event-emitter"));
exports.EventEmitter = event_emitter_1.default;
var friction_equation_1 = __importDefault(_dereq_("./equations/friction-equation"));
exports.FrictionEquation = friction_equation_1.default;
var friction_equation_pool_1 = __importDefault(_dereq_("./utils/friction-equation-pool"));
exports.FrictionEquationPool = friction_equation_pool_1.default;
var gear_constraint_1 = __importDefault(_dereq_("./constraints/gear-constraint"));
exports.GearConstraint = gear_constraint_1.default;
var gs_solver_1 = __importDefault(_dereq_("./solver/gs-solver"));
exports.GSSolver = gs_solver_1.default;
var heightfield_1 = __importDefault(_dereq_("./shapes/heightfield"));
exports.Heightfield = heightfield_1.default;
var line_1 = __importDefault(_dereq_("./shapes/line"));
exports.Line = line_1.default;
var lock_constraint_1 = __importDefault(_dereq_("./constraints/lock-constraint"));
exports.LockConstraint = lock_constraint_1.default;
var material_1 = __importDefault(_dereq_("./material/material"));
exports.Material = material_1.default;
var narrowphase_1 = __importDefault(_dereq_("./collision/narrowphase"));
exports.Narrowphase = narrowphase_1.default;
var naive_broadphase_1 = __importDefault(_dereq_("./collision/naive-broadphase"));
exports.NaiveBroadphase = naive_broadphase_1.default;
var particle_1 = __importDefault(_dereq_("./shapes/particle"));
exports.Particle = particle_1.default;
var plane_1 = __importDefault(_dereq_("./shapes/plane"));
exports.Plane = plane_1.default;
var pool_1 = __importDefault(_dereq_("./utils/pool"));
exports.Pool = pool_1.default;
var revolute_constraint_1 = __importDefault(_dereq_("./constraints/revolute-constraint"));
exports.RevoluteConstraint = revolute_constraint_1.default;
var prismatic_constraint_1 = __importDefault(_dereq_("./constraints/prismatic-constraint"));
exports.PrismaticConstraint = prismatic_constraint_1.default;
var ray_1 = __importDefault(_dereq_("./collision/ray"));
exports.Ray = ray_1.default;
var raycast_result_1 = __importDefault(_dereq_("./collision/raycast-result"));
exports.RaycastResult = raycast_result_1.default;
var Box_1 = __importDefault(_dereq_("./shapes/Box"));
exports.Box = Box_1.default;
var rotational_velocity_equation_1 = __importDefault(_dereq_("./equations/rotational-velocity-equation"));
exports.RotationalVelocityEquation = rotational_velocity_equation_1.default;
var sap_broadphase_1 = __importDefault(_dereq_("./collision/sap-broadphase"));
exports.SAPBroadphase = sap_broadphase_1.default;
var shape_1 = __importDefault(_dereq_("./shapes/shape"));
exports.Shape = shape_1.default;
var solver_1 = __importDefault(_dereq_("./solver/solver"));
exports.Solver = solver_1.default;
var spring_1 = __importDefault(_dereq_("./objects/spring"));
exports.Spring = spring_1.default;
var top_down_vehicle_1 = __importDefault(_dereq_("./objects/top-down-vehicle"));
exports.TopDownVehicle = top_down_vehicle_1.default;
var linear_spring_1 = __importDefault(_dereq_("./objects/linear-spring"));
exports.LinearSpring = linear_spring_1.default;
var rotational_spring_1 = __importDefault(_dereq_("./objects/rotational-spring"));
exports.RotationalSpring = rotational_spring_1.default;
var utils_1 = __importDefault(_dereq_("./utils/utils"));
exports.Utils = utils_1.default;
var world_1 = __importDefault(_dereq_("./world/world"));
exports.World = world_1.default;
var vec2_1 = __importDefault(_dereq_("./math/vec2"));
exports.vec2 = vec2_1.default;
var version = "0.0.1";
exports.version = version;

},{"./collision/aabb":1,"./collision/broadphase":2,"./collision/naive-broadphase":3,"./collision/narrowphase":4,"./collision/ray":5,"./collision/raycast-result":6,"./collision/sap-broadphase":7,"./constraints/constraint":8,"./constraints/distance-constraint":9,"./constraints/gear-constraint":10,"./constraints/lock-constraint":11,"./constraints/prismatic-constraint":12,"./constraints/revolute-constraint":13,"./equations/angle-lock-equation":15,"./equations/contact-equation":16,"./equations/equation":17,"./equations/friction-equation":18,"./equations/rotational-velocity-equation":20,"./events/event-emitter":21,"./material/contact-material":24,"./material/material":25,"./math/vec2":28,"./objects/body":30,"./objects/linear-spring":31,"./objects/rotational-spring":32,"./objects/spring":33,"./objects/top-down-vehicle":34,"./shapes/Box":35,"./shapes/capsule":39,"./shapes/circle":40,"./shapes/convex":41,"./shapes/heightfield":42,"./shapes/line":43,"./shapes/particle":44,"./shapes/plane":45,"./shapes/shape":46,"./solver/gs-solver":47,"./solver/solver":48,"./utils/contact-equation-pool":49,"./utils/friction-equation-pool":50,"./utils/pool":54,"./utils/utils":56,"./world/world":58}],23:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Material = /** @class */ (function () {
    /**
     * Defines a physics material. To be used with {{#crossLink "ContactMaterial"}}{{/crossLink}}.
     * @class Material
     * @constructor
     * @author schteppe
     * @example
     *     // Create a wooden box
     *     var woodMaterial = new Material();
     *     var boxShape = new Box({
     *         material: woodMaterial
     *     });
     *     body.addShape(boxShape);
     */
    function Material() {
        /**
         * The material identifier. Read only.
         * @readonly
         * @property id
         * @type {Number}
         */
        this.id = ++Material.idCounter;
    }
    Material.idCounter = 0;
    return Material;
}());
exports.default = Material;

},{}],24:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Material_1 = __importDefault(_dereq_("./Material"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var ContactMaterial = /** @class */ (function () {
    /**
     * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters. Also see {{#crossLink "Material"}}{{/crossLink}}.
     * @class ContactMaterial
     * @constructor
     * @param {Material} materialA
     * @param {Material} materialB
     * @param {Object}   [options]
     * @param {Number}   [options.friction=0.3]       Friction coefficient.
     * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.
     * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.
     * @param {Number}   [options.relaxation]         ContactEquation relaxation.
     * @param {Number}   [options.restitution=0]      Restitution coefficient aka "bounciness".
     * @param {Number}   [options.stiffness]          ContactEquation stiffness.
     * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.
     * @author schteppe
     * @example
     *     var ice = new Material();
     *     var wood = new Material();
     *     var iceWoodContactMaterial = new ContactMaterial(ice, wood, {
     *         friction: 0.2,
     *         restitution: 0.3
     *     });
     *     world.addContactMaterial(iceWoodContactMaterial);
     */
    function ContactMaterial(materialA, materialB, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        /**
         * Friction coefficient to use in the contact of these two materials. Friction = 0 will make the involved objects super slippery, and friction = 1 will make it much less slippery. A friction coefficient larger than 1 will allow for very large friction forces, which can be convenient for preventing car tires not slip on the ground.
         * @property friction
         * @type {Number}
         * @default 0.3
         */
        this.friction = 0.3;
        /**
         * Restitution, or "bounciness" to use in the contact of these two materials. A restitution of 0 will make no bounce, while restitution=1 will approximately bounce back with the same velocity the object came with.
         * @property restitution
         * @type {Number}
         * @default 0
         */
        this.restitution = 0;
        /**
         * Hardness of the contact. Less stiffness will make the objects penetrate more, and will make the contact act more like a spring than a contact force. Default value is {{#crossLink "Equation/DEFAULT_STIFFNESS:property"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.
         * @property stiffness
         * @type {Number}
         */
        this.stiffness = Equation_1.default.DEFAULT_STIFFNESS;
        /**
         * Relaxation of the resulting ContactEquation that this ContactMaterial generate. Default value is {{#crossLink "Equation/DEFAULT_RELAXATION:property"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.
         * @property relaxation
         * @type {Number}
         */
        this.relaxation = Equation_1.default.DEFAULT_RELAXATION;
        /**
         * Stiffness of the resulting friction force. For most cases, the value of this property should be a large number. I cannot think of any case where you would want less frictionStiffness. Default value is {{#crossLink "Equation/DEFAULT_STIFFNESS:property"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.
         * @property frictionStiffness
         * @type {Number}
         */
        this.frictionStiffness = Equation_1.default.DEFAULT_STIFFNESS;
        /**
         * Relaxation of the resulting friction force. The default value should be good for most simulations. Default value is {{#crossLink "Equation/DEFAULT_RELAXATION:property"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.
         * @property frictionRelaxation
         * @type {Number}
         */
        this.frictionRelaxation = Equation_1.default.DEFAULT_RELAXATION;
        /**
         * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.
         * @property {Number} surfaceVelocity
         * @default 0
         */
        this.surfaceVelocity = 0;
        /**
         * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka "cure for nervous contacts".
         * @property contactSkinSize
         * @type {Number}
         */
        this.contactSkinSize = 0.005;
        if (!(materialA instanceof Material_1.default) || !(materialB instanceof Material_1.default)) {
            throw new Error("First two arguments must be Material instances.");
        }
        this.id = ++ContactMaterial.idCounter;
        this.materialA = materialA;
        this.materialB = materialB;
        this.friction = (_a = options === null || options === void 0 ? void 0 : options.friction) !== null && _a !== void 0 ? _a : 0.3;
        this.restitution = (_b = options === null || options === void 0 ? void 0 : options.restitution) !== null && _b !== void 0 ? _b : 0;
        this.stiffness = (_c = options === null || options === void 0 ? void 0 : options.stiffness) !== null && _c !== void 0 ? _c : Equation_1.default.DEFAULT_STIFFNESS;
        this.relaxation = (_d = options === null || options === void 0 ? void 0 : options.relaxation) !== null && _d !== void 0 ? _d : Equation_1.default.DEFAULT_RELAXATION;
        this.frictionStiffness = (_e = options === null || options === void 0 ? void 0 : options.frictionStiffness) !== null && _e !== void 0 ? _e : Equation_1.default.DEFAULT_STIFFNESS;
        this.frictionRelaxation = (_f = options === null || options === void 0 ? void 0 : options.frictionRelaxation) !== null && _f !== void 0 ? _f : Equation_1.default.DEFAULT_RELAXATION;
        this.surfaceVelocity = (_g = options === null || options === void 0 ? void 0 : options.surfaceVelocity) !== null && _g !== void 0 ? _g : 0;
        this.contactSkinSize = 0.005;
    }
    ContactMaterial.idCounter = 0;
    return ContactMaterial;
}());
exports.default = ContactMaterial;

},{"../equations/Equation":14,"./Material":23}],25:[function(_dereq_,module,exports){
module.exports=_dereq_(23)
},{}],26:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
function lineInt(l1, l2, precision) {
    if (precision === void 0) { precision = 0; }
    var i = new Float32Array(2); // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2 * b1;
    if (!scalar_eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
}
/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
function lineSegmentsIntersect(p1, p2, q1, q2) {
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    var da = q2[0] - q1[0];
    var db = q2[1] - q1[1];
    // segments are parallel
    if ((da * dy - db * dx) === 0) {
        return false;
    }
    var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
    var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
    return (s >= 0 && s <= 1 && t >= 0 && t <= 1);
}
/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
function triangleArea(a, b, c) {
    return (((b[0] - a[0]) * (c[1] - a[1])) - ((c[0] - a[0]) * (b[1] - a[1])));
}
function isLeft(a, b, c) {
    return triangleArea(a, b, c) > 0;
}
function isLeftOn(a, b, c) {
    return triangleArea(a, b, c) >= 0;
}
function isRight(a, b, c) {
    return triangleArea(a, b, c) < 0;
}
function isRightOn(a, b, c) {
    return triangleArea(a, b, c) <= 0;
}
var tmpPoint1 = new Float32Array(2), tmpPoint2 = new Float32Array(2);
/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
function collinear(a, b, c, thresholdAngle) {
    if (!thresholdAngle) {
        return triangleArea(a, b, c) === 0;
    }
    else {
        var ab = tmpPoint1, bc = tmpPoint2;
        ab[0] = b[0] - a[0];
        ab[1] = b[1] - a[1];
        bc[0] = c[0] - b[0];
        bc[1] = c[1] - b[1];
        var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
        return angle < thresholdAngle;
    }
}
function sqdist(a, b) {
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
}
/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
function polygonAt(polygon, i) {
    var s = polygon.length;
    return polygon[i < 0 ? i % s + s : i % s];
}
/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
function polygonClear(polygon) {
    polygon.length = 0;
}
/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
function polygonAppend(polygon, poly, from, to) {
    for (var i = from; i < to; i++) {
        polygon.push(poly[i]);
    }
}
/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
function polygonMakeCCW(polygon) {
    var br = 0, v = polygon;
    // find bottom right point
    for (var i = 1; i < polygon.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }
    // reverse poly if clockwise
    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
        polygonReverse(polygon);
        return true;
    }
    else {
        return false;
    }
}
/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
function polygonReverse(polygon) {
    var tmp = [];
    var N = polygon.length;
    for (var i = 0; i !== N; i++) {
        var p = polygon.pop();
        tmp.push(p);
    }
    for (var i = 0; i !== N; i++) {
        polygon[i] = tmp[i];
    }
}
/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
function polygonIsReflex(polygon, i) {
    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
}
var tmpLine1 = [], tmpLine2 = [];
/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee(polygon, a, b) {
    var p, dist, l1 = tmpLine1, l2 = tmpLine2;
    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
        return false;
    }
    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
    for (var i = 0; i !== polygon.length; ++i) { // for each edge
        if ((i + 1) % polygon.length === a || i === a) { // ignore incident edges
            continue;
        }
        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge
            l1[0] = polygonAt(polygon, a);
            l1[1] = polygonAt(polygon, b);
            l2[0] = polygonAt(polygon, i);
            l2[1] = polygonAt(polygon, i + 1);
            p = lineInt(l1, l2);
            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }
    return true;
}
/**
 * Check if two vertices in the polygon can see each other
 * @method canSee2
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee2(polygon, a, b) {
    // for each edge
    for (var i = 0; i !== polygon.length; ++i) {
        // ignore incident edges
        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {
            continue;
        }
        if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {
            return false;
        }
    }
    return true;
}
/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
function polygonCopy(polygon, i, j, targetPoly) {
    var p = targetPoly !== null && targetPoly !== void 0 ? targetPoly : [];
    polygonClear(p);
    if (i < j) {
        // Insert all vertices from i to j
        for (var k = i; k <= j; k++) {
            p.push(polygon[k]);
        }
    }
    else {
        // Insert vertices 0 to j
        for (var k = 0; k <= j; k++) {
            p.push(polygon[k]);
        }
        // Insert vertices i to end
        for (var k = i; k < polygon.length; k++) {
            p.push(polygon[k]);
        }
    }
    return p;
}
/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
function polygonGetCutEdges(polygon) {
    var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];
    var nDiags = Infinity;
    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(polygon, i)) {
            for (var j = 0; j < polygon.length; ++j) {
                if (polygonCanSee(polygon, i, j)) {
                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));
                    for (var k = 0; k < tmp2.length; k++) {
                        tmp1.push(tmp2[k]);
                    }
                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        var p = [polygonAt(polygon, i), polygonAt(polygon, j)];
                        min.push(p);
                    }
                }
            }
        }
    }
    return min;
}
/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
function polygonDecomp(polygon) {
    var edges = polygonGetCutEdges(polygon);
    if (edges.length > 0) {
        return polygonSlice(polygon, edges);
    }
    else {
        return [polygon];
    }
}
/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @warning The inner workings of this function was massively modified when switching to typescript. Needs thorough testing.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
function polygonSlice(polygon, cutEdges) {
    if (cutEdges.length === 0) {
        return [polygon];
    }
    if (cutEdges[0].length === 2) {
        var polys = [polygon];
        for (var i = 0; i < cutEdges.length; i++) {
            var cutEdge = [cutEdges[i]];
            // Cut all polys
            for (var j = 0; j < polys.length; j++) {
                var poly = polys[j];
                var result = polygonSlice(poly, cutEdge);
                if (result) {
                    // Found poly! Cut and quit
                    polys.splice(j, 1);
                    polys.push(result[0]);
                    polys.push(result[1]);
                    break;
                }
            }
        }
        return polys;
    }
    else {
        // Was given one edge
        var cutEdge = cutEdges;
        var i = polygon.indexOf(cutEdge[0][0]);
        var j = polygon.indexOf(cutEdge[0][1]);
        if (i !== -1 && j !== -1) {
            return [polygonCopy(polygon, i, j),
                polygonCopy(polygon, j, i)];
        }
        else {
            return new Array();
        }
    }
}
/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
function polygonIsSimple(polygon) {
    var path = polygon, i;
    // Check
    for (i = 0; i < path.length - 1; i++) {
        for (var j = 0; j < i - 1; j++) {
            if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
                return false;
            }
        }
    }
    // Check the segment between the last and the first point to all others
    for (i = 1; i < path.length - 2; i++) {
        if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
            return false;
        }
    }
    return true;
}
function getIntersectionPoint(p1, p2, q1, q2, delta) {
    if (delta === void 0) { delta = 0; }
    var a1 = p2[1] - p1[1];
    var b1 = p1[0] - p2[0];
    var c1 = (a1 * p1[0]) + (b1 * p1[1]);
    var a2 = q2[1] - q1[1];
    var b2 = q1[0] - q2[0];
    var c2 = (a2 * q1[0]) + (b2 * q1[1]);
    var det = (a1 * b2) - (a2 * b1);
    var pt = new Float32Array(2);
    if (!scalar_eq(det, 0, delta)) {
        pt[0] = ((b2 * c1) - (b1 * c2)) / det;
        pt[1] = ((a1 * c2) - (a2 * c1)) / det;
        return pt;
    }
    else {
        pt[0] = 0;
        pt[1] = 0;
        return pt;
    }
}
/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
    if (result === void 0) { result = new Array(); }
    if (reflexVertices === void 0) { reflexVertices = []; }
    if (steinerPoints === void 0) { steinerPoints = []; }
    if (delta === void 0) { delta = 25; }
    if (maxlevel === void 0) { maxlevel = 100; }
    if (level === void 0) { level = 0; }
    // TODO: should upperInt really be initialized here? It looks like it's overwritten.
    var upperInt = new Float32Array(2), lowerInt = new Float32Array(2), p = new Float32Array(2); // Points
    upperInt[0] = 0;
    upperInt[1] = 0;
    lowerInt[0] = 0;
    lowerInt[1] = 0;
    p[0] = 0;
    p[1] = 0;
    var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0; // scalars
    var upperIndex = 0, lowerIndex = 0, closestIndex = 0; // Integers
    var lowerPoly = new Array(), upperPoly = new Array(); // polygons
    var poly = polygon, v = polygon;
    if (v.length < 3) {
        return result;
    }
    level++;
    if (level > maxlevel) {
        //console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }
    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(poly, i)) {
            reflexVertices.push(poly[i]);
            upperDist = lowerDist = Infinity;
            for (var j = 0; j < polygon.length; ++j) {
                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection
                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly
                        d = sqdist(poly[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
                        d = sqdist(poly[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }
            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex === (upperIndex + 1) % polygon.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+polygon.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);
                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly, i, upperIndex + 1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    if (lowerIndex !== 0) {
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        polygonAppend(upperPoly, poly, lowerIndex, poly.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly, 0, i + 1);
                }
                else {
                    if (i !== 0) {
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        polygonAppend(lowerPoly, poly, i, poly.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly, lowerIndex, i + 1);
                }
            }
            else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+polygon.length+")\n");
                if (lowerIndex > upperIndex) {
                    upperIndex += polygon.length;
                }
                closestDist = Infinity;
                if (upperIndex < lowerIndex) {
                    return result;
                }
                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&
                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                        if (d < closestDist && polygonCanSee2(poly, i, j)) {
                            closestDist = d;
                            closestIndex = j % polygon.length;
                        }
                    }
                }
                if (i < closestIndex) {
                    polygonAppend(lowerPoly, poly, i, closestIndex + 1);
                    if (closestIndex !== 0) {
                        polygonAppend(upperPoly, poly, closestIndex, v.length);
                    }
                    polygonAppend(upperPoly, poly, 0, i + 1);
                }
                else {
                    if (i !== 0) {
                        polygonAppend(lowerPoly, poly, i, v.length);
                    }
                    polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
                    polygonAppend(upperPoly, poly, closestIndex, i + 1);
                }
            }
            // solve smallest poly first
            if (lowerPoly.length < upperPoly.length) {
                polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
            }
            else {
                polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
            }
            return result;
        }
    }
    result.push(polygon);
    return result;
}
/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
function polygonRemoveCollinearPoints(polygon, precision) {
    var num = 0;
    for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {
        if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {
            // Remove the middle point
            polygon.splice(i % polygon.length, 1);
            num++;
        }
    }
    return num;
}
/**
 * Remove duplicate points in the polygon.
 * @method removeDuplicatePoints
 * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.
 */
function polygonRemoveDuplicatePoints(polygon, precision) {
    for (var i = polygon.length - 1; i >= 1; --i) {
        var pi = polygon[i];
        for (var j = i - 1; j >= 0; --j) {
            if (points_eq(pi, polygon[j], precision)) {
                polygon.splice(i, 1);
                continue;
            }
        }
    }
}
/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function scalar_eq(a, b, precision) {
    precision = precision || 0;
    return Math.abs(a - b) <= precision;
}
/**
 * Check if two points are equal
 * @static
 * @method points_eq
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function points_eq(a, b, precision) {
    return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);
}
exports.default = {
    decomp: polygonDecomp,
    quickDecomp: polygonQuickDecomp,
    isSimple: polygonIsSimple,
    removeCollinearPoints: polygonRemoveCollinearPoints,
    removeDuplicatePoints: polygonRemoveDuplicatePoints,
    makeCCW: polygonMakeCCW
};

},{}],27:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
    PolyK library
    url: http://polyk.ivank.net
    Released under MIT licence.

    Copyright (c) 2012 Ivan Kuckir

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
*/
var PolyK = /** @class */ (function () {
    function PolyK() {
    }
    /*
        Is Polygon self-intersecting?

        O(n^2)
    */
    /*
    IsSimple(p)
    {
        var n = p.length>>1;
        if(n<4) return true;
        var a1 = new this._P(), a2 = new this._P();
        var b1 = new this._P(), b2 = new this._P();
        var c = new this._P();

        for(var i=0; i<n; i++)
        {
            a1.x = p[2*i  ];
            a1.y = p[2*i+1];
            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }
            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }

            for(var j=0; j<n; j++)
            {
                if(Math.abs(i-j) < 2) continue;
                if(j==n-1 && i==0) continue;
                if(i==n-1 && j==0) continue;

                b1.x = p[2*j  ];
                b1.y = p[2*j+1];
                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }
                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }

                if(this._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;
            }
        }
        return true;
    }

    IsConvex(p)
    {
        if(p.length<6) return true;
        var l = p.length - 4;
        for(var i=0; i<l; i+=2)
            if(!this._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;
        if(!this._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;
        if(!this._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;
        return true;
    }
    */
    PolyK.prototype.GetArea = function (p) {
        if (p.length < 6)
            return 0;
        var l = p.length - 2;
        var sum = 0;
        for (var i = 0; i < l; i += 2)
            sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
        sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
        return -sum * 0.5;
    };
    /*
    GetAABB(p)
    {
        var minx = Infinity;
        var miny = Infinity;
        var maxx = -minx;
        var maxy = -miny;
        for(var i=0; i<p.length; i+=2)
        {
            minx = Math.min(minx, p[i  ]);
            maxx = Math.max(maxx, p[i  ]);
            miny = Math.min(miny, p[i+1]);
            maxy = Math.max(maxy, p[i+1]);
        }
        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};
    }
    */
    PolyK.prototype.Triangulate = function (p) {
        var n = p.length >> 1;
        if (n < 3)
            return [];
        var tgs = [];
        var avl = [];
        for (var i = 0; i < n; i++)
            avl.push(i);
        var i = 0;
        var al = n;
        while (al > 3) {
            var i0 = avl[(i + 0) % al];
            var i1 = avl[(i + 1) % al];
            var i2 = avl[(i + 2) % al];
            var ax = p[2 * i0], ay = p[2 * i0 + 1];
            var bx = p[2 * i1], by = p[2 * i1 + 1];
            var cx = p[2 * i2], cy = p[2 * i2 + 1];
            var earFound = false;
            if (this._convex(ax, ay, bx, by, cx, cy)) {
                earFound = true;
                for (var j = 0; j < al; j++) {
                    var vi = avl[j];
                    if (vi == i0 || vi == i1 || vi == i2)
                        continue;
                    if (this._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
                        earFound = false;
                        break;
                    }
                }
            }
            if (earFound) {
                tgs.push(i0);
                tgs.push(i1);
                tgs.push(i2);
                avl.splice((i + 1) % al, 1);
                al--;
                i = 0;
            }
            else if (i++ > 3 * al)
                break; // no convex angles :(
        }
        tgs.push(avl[0]);
        tgs.push(avl[1]);
        tgs.push(avl[2]);
        return tgs;
    };
    /*
    ContainsPoint(p, px, py)
    {
        var n = p.length>>1;
        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;
        var depth = 0;
        for(var i=0; i<n; i++)
        {
            ax = bx;  ay = by;
            bx = p[2*i  ] - px;
            by = p[2*i+1] - py;
            if(ay< 0 && by< 0) continue;    // both "up" or both "donw"
            if(ay>=0 && by>=0) continue;    // both "up" or both "donw"
            if(ax< 0 && bx< 0) continue;

            var lx = ax + (bx-ax)*(-ay)/(by-ay);
            if(lx>0) depth++;
        }
        return (depth & 1) == 1;
    }

    Slice(p, ax, ay, bx, by)
    {
        if(this.ContainsPoint(p, ax, ay) || this.ContainsPoint(p, bx, by)) return [p.slice(0)];

        var a = new this._P(ax, ay);
        var b = new this._P(bx, by);
        var iscs = [];  // intersections
        var ps = [];    // points
        for(var i=0; i<p.length; i+=2) ps.push(new this._P(p[i], p[i+1]));

        for(var i=0; i<ps.length; i++)
        {
            var isc = new this._P(0,0);
            isc = this._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);

            if(isc)
            {
                isc.flag = true;
                iscs.push(isc);
                ps.splice(i+1,0,isc);
                i++;
            }
        }
        if(iscs.length == 0) return [p.slice(0)];
        var comp(u,v) {return this._P.dist(a,u) - this._P.dist(a,v); }
        iscs.sort(comp);

        var pgs = [];
        var dir = 0;
        while(iscs.length > 0)
        {
            var n = ps.length;
            var i0 = iscs[0];
            var i1 = iscs[1];
            var ind0 = ps.indexOf(i0);
            var ind1 = ps.indexOf(i1);
            var solved = false;

            if(this._firstWithFlag(ps, ind0) == ind1) solved = true;
            else
            {
                i0 = iscs[1];
                i1 = iscs[0];
                ind0 = ps.indexOf(i0);
                ind1 = ps.indexOf(i1);
                if(this._firstWithFlag(ps, ind0) == ind1) solved = true;
            }
            if(solved)
            {
                dir--;
                var pgn = this._getPoints(ps, ind0, ind1);
                pgs.push(pgn);
                ps = this._getPoints(ps, ind1, ind0);
                i0.flag = i1.flag = false;
                iscs.splice(0,2);
                if(iscs.length == 0) pgs.push(ps);
            }
            else { dir++; iscs.reverse(); }
            if(dir>1) break;
        }
        var result = [];
        for(var i=0; i<pgs.length; i++)
        {
            var pg = pgs[i];
            var npg = [];
            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);
            result.push(npg);
        }
        return result;
    }

    Raycast(p, x, y, dx, dy, isc)
    {
        var l = p.length - 2;
        var tp = this._tp;
        var a1 = tp[0], a2 = tp[1],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;
        a2.x = x+dx; a2.y = y+dy;

        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            var nisc = this._RayLineIntersection(a1, a2, b1, b2, c);
            if(nisc) this._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        var nisc = this._RayLineIntersection(a1, a2, b1, b2, c);
        if(nisc) this._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);

        return (isc.dist != Infinity) ? isc : null;
    }

    ClosestEdge(p, x, y, isc)
    {
        var l = p.length - 2;
        var tp = this._tp;
        var a1 = tp[0],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;

        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            this._pointLineDist(a1, b1, b2, i>>1, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        this._pointLineDist(a1, b1, b2, l>>1, isc);

        var idst = 1/isc.dist;
        isc.norm.x = (x-isc.point.x)*idst;
        isc.norm.y = (y-isc.point.y)*idst;
        return isc;
    }

    _pointLineDist(p, a, b, edge, isc)
    {
        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;

        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;

        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var param = dot / len_sq;

        var xx, yy;

        if (param < 0 || (x1 == x2 && y1 == y2)) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        var dx = x - xx;
        var dy = y - yy;
        var dst = Math.sqrt(dx * dx + dy * dy);
        if(dst<isc.dist)
        {
            isc.dist = dst;
            isc.edge = edge;
            isc.point.x = xx;
            isc.point.y = yy;
        }
    }

    _updateISC(dx, dy, a1, b1, b2, c, edge, isc)
    {
        var nrl = this._P.dist(a1, c);
        if(nrl<isc.dist)
        {
            var ibl = 1/this._P.dist(b1, b2);
            var nx = -(b2.y-b1.y)*ibl;
            var ny =  (b2.x-b1.x)*ibl;
            var ddot = 2*(dx*nx+dy*ny);
            isc.dist = nrl;
            isc.norm.x = nx;
            isc.norm.y = ny;
            isc.refl.x = -ddot*nx+dx;
            isc.refl.y = -ddot*ny+dy;
            isc.edge = edge;
        }
    }

    _getPoints(ps, ind0, ind1)
    {
        var n = ps.length;
        var nps = [];
        if(ind1<ind0) ind1 += n;
        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);
        return nps;
    }

    _firstWithFlag(ps, ind)
    {
        var n = ps.length;
        while(true)
        {
            ind = (ind+1)%n;
            if(ps[ind].flag) return ind;
        }
    }
    */
    PolyK.prototype._PointInTriangle = function (px, py, ax, ay, bx, by, cx, cy) {
        var v0x = cx - ax;
        var v0y = cy - ay;
        var v1x = bx - ax;
        var v1y = by - ay;
        var v2x = px - ax;
        var v2y = py - ay;
        var dot00 = v0x * v0x + v0y * v0y;
        var dot01 = v0x * v1x + v0y * v1y;
        var dot02 = v0x * v2x + v0y * v2y;
        var dot11 = v1x * v1x + v1y * v1y;
        var dot12 = v1x * v2x + v1y * v2y;
        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        // Check if point is in triangle
        return (u >= 0) && (v >= 0) && (u + v < 1);
    };
    /*
    _RayLineIntersection(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        var iDen = 1/Den;
        I.x = ( A*dbx - dax*B ) * iDen;
        I.y = ( A*dby - day*B ) * iDen;

        if(!this._InRect(I, b1, b2)) return null;
        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;
        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;
        return I;
    }

    _GetLineIntersection(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        I.x = ( A*dbx - dax*B ) / Den;
        I.y = ( A*dby - day*B ) / Den;

        if(this._InRect(I, a1, a2) && this._InRect(I, b1, b2)) return I;
        return null;
    }

    _InRect(a, b, c)
    {
        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));
        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));

        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)
        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))
        return true;
        return false;
    }
    */
    PolyK.prototype._convex = function (ax, ay, bx, by, cx, cy) {
        return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;
    };
    return PolyK;
}());
exports.default = new PolyK();

},{}],28:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
/**
 * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.
 * @class vec2
 */
var Vec2 = /** @class */ (function () {
    function Vec2() {
    }
    /**
     * Make a cross product and only return the z component
     * @method crossLength
     * @static
     * @param  {Array} a
     * @param  {Array} b
     * @return {Number}
     */
    Vec2.prototype.crossLength = function (a, b) {
        return a[0] * b[1] - a[1] * b[0];
    };
    ;
    /**
     * Cross product between a vector and the Z component of a vector
     * @method crossVZ
     * @static
     * @param  {Array} out
     * @param  {Array} vec
     * @param  {Number} zcomp
     * @return {Array}
     */
    Vec2.prototype.crossVZ = function (out, vec, zcomp) {
        this.rotate(out, vec, -Math.PI / 2); // Rotate according to the right hand rule
        this.scale(out, out, zcomp); // Scale with z
        return out;
    };
    ;
    /**
     * Cross product between a vector and the Z component of a vector
     * @method crossZV
     * @static
     * @param  {Array} out
     * @param  {Number} zcomp
     * @param  {Array} vec
     * @return {Array}
     */
    Vec2.prototype.crossZV = function (out, zcomp, vec) {
        this.rotate(out, vec, Math.PI / 2); // Rotate according to the right hand rule
        this.scale(out, out, zcomp); // Scale with z
        return out;
    };
    ;
    /**
     * Rotate a vector by an angle
     * @method rotate
     * @static
     * @param  {Array} out
     * @param  {Array} a
     * @param  {Number} angle
     * @return {Array}
     */
    Vec2.prototype.rotate = function (out, a, angle) {
        if (angle !== 0) {
            var c = Math.cos(angle), s = Math.sin(angle), x = a[0], y = a[1];
            out[0] = c * x - s * y;
            out[1] = s * x + c * y;
        }
        else {
            out[0] = a[0];
            out[1] = a[1];
        }
        return out;
    };
    ;
    /**
     * Rotate a vector 90 degrees clockwise
     * @method rotate90cw
     * @static
     * @param  {Array} out
     * @param  {Array} a
     * @return {Array}
     */
    Vec2.prototype.rotate90cw = function (out, a) {
        var x = a[0];
        var y = a[1];
        out[0] = y;
        out[1] = -x;
        return out;
    };
    ;
    /**
     * Transform a point position to local frame.
     * @method toLocalFrame
     * @param  {Array} out
     * @param  {Array} worldPoint
     * @param  {Array} framePosition
     * @param  {Number} frameAngle
     * @return {Array}
     */
    Vec2.prototype.toLocalFrame = function (out, worldPoint, framePosition, frameAngle) {
        var c = Math.cos(-frameAngle), s = Math.sin(-frameAngle), x = worldPoint[0] - framePosition[0], y = worldPoint[1] - framePosition[1];
        out[0] = c * x - s * y;
        out[1] = s * x + c * y;
        return out;
    };
    ;
    /**
     * Transform a point position to global frame.
     * @method toGlobalFrame
     * @param  {Array} out
     * @param  {Array} localPoint
     * @param  {Array} framePosition
     * @param  {Number} frameAngle
     */
    Vec2.prototype.toGlobalFrame = function (out, localPoint, framePosition, frameAngle) {
        var c = Math.cos(frameAngle), s = Math.sin(frameAngle), x = localPoint[0], y = localPoint[1], addX = framePosition[0], addY = framePosition[1];
        out[0] = c * x - s * y + addX;
        out[1] = s * x + c * y + addY;
    };
    ;
    /**
     * Transform a vector to local frame.
     * @method vectorToLocalFrame
     * @param  {Array} out
     * @param  {Array} worldVector
     * @param  {Number} frameAngle
     * @return {Array}
     */
    Vec2.prototype.vectorToLocalFrame = function (out, worldVector, frameAngle) {
        var c = Math.cos(-frameAngle), s = Math.sin(-frameAngle), x = worldVector[0], y = worldVector[1];
        out[0] = c * x - s * y;
        out[1] = s * x + c * y;
        return out;
    };
    ;
    /*
     * Transform a vector to global frame.
     * @method vectorToGlobalFrame
     * @param  {Array} out
     * @param  {Array} localVector
     * @param  {Number} frameAngle
     */
    //vectorToGlobalFrame = vec2.rotate;
    /**
     * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php
     * @method centroid
     * @static
     * @param  {Array} out
     * @param  {Array} a
     * @param  {Array} b
     * @param  {Array} c
     * @return  {Array} The "out" vector.
     */
    Vec2.prototype.centroid = function (out, a, b, c) {
        this.add(out, a, b);
        this.add(out, out, c);
        this.scale(out, out, 1 / 3);
        return out;
    };
    ;
    /**
     * Creates a new, empty vec2
     * @static
     * @method create
     * @return {Array} a new 2D vector
     */
    Vec2.prototype.create = function () {
        var out = new Float32Array(2);
        out[0] = 0;
        out[1] = 0;
        return out;
    };
    ;
    /**
     * Creates a new vec2 initialized with values from an existing vector
     * @static
     * @method clone
     * @param {Array} a vector to clone
     * @return {Array} a new 2D vector
     */
    Vec2.prototype.clone = function (a) {
        var out = new Float32Array(2);
        out[0] = a[0];
        out[1] = a[1];
        return out;
    };
    ;
    /**
     * Creates a new vec2 initialized with the given values
     * @static
     * @method fromValues
     * @param {Number} x X component
     * @param {Number} y Y component
     * @return {Array} a new 2D vector
     */
    Vec2.prototype.fromValues = function (x, y) {
        var out = new Float32Array(2);
        out[0] = x;
        out[1] = y;
        return out;
    };
    ;
    /**
     * Copy the values from one vec2 to another
     * @static
     * @method copy
     * @param {Array} out the receiving vector
     * @param {Array} a the source vector
     * @return {Array} out
     */
    Vec2.prototype.copy = function (out, a) {
        out[0] = a[0];
        out[1] = a[1];
        return out;
    };
    ;
    /**
     * Set the components of a vec2 to the given values
     * @static
     * @method set
     * @param {Array} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @return {Array} out
     */
    Vec2.prototype.set = function (out, x, y) {
        out[0] = x;
        out[1] = y;
        return out;
    };
    ;
    /**
     * Adds two vec2's
     * @static
     * @method add
     * @param {Array} out the receiving vector
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Array} out
     */
    Vec2.prototype.add = function (out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        return out;
    };
    ;
    /**
     * Subtracts two vec2's
     * @static
     * @method subtract
     * @param {Array} out the receiving vector
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Array} out
     */
    Vec2.prototype.subtract = function (out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        return out;
    };
    ;
    /**
     * Multiplies two vec2's
     * @static
     * @method multiply
     * @param {Array} out the receiving vector
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Array} out
     */
    Vec2.prototype.multiply = function (out, a, b) {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        return out;
    };
    ;
    /**
     * Divides two vec2's
     * @static
     * @method divide
     * @param {Array} out the receiving vector
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Array} out
     */
    Vec2.prototype.divide = function (out, a, b) {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        return out;
    };
    ;
    /**
     * Scales a vec2 by a scalar number
     * @static
     * @method scale
     * @param {Array} out the receiving vector
     * @param {Array} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @return {Array} out
     */
    Vec2.prototype.scale = function (out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        return out;
    };
    ;
    /**
     * Calculates the euclidian distance between two vec2's
     * @static
     * @method distance
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Number} distance between a and b
     */
    Vec2.prototype.distance = function (a, b) {
        var x = b[0] - a[0], y = b[1] - a[1];
        return Math.sqrt(x * x + y * y);
    };
    ;
    /**
     * Calculates the squared euclidian distance between two vec2's
     * @static
     * @method squaredDistance
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Number} squared distance between a and b
     */
    Vec2.prototype.squaredDistance = function (a, b) {
        var x = b[0] - a[0], y = b[1] - a[1];
        return x * x + y * y;
    };
    ;
    /**
     * Calculates the length of a vec2
     * @static
     * @method length
     * @param {Array} a vector to calculate length of
     * @return {Number} length of a
     */
    Vec2.prototype.length = function (a) {
        var x = a[0], y = a[1];
        return Math.sqrt(x * x + y * y);
    };
    ;
    /**
     * Calculates the squared length of a vec2
     * @static
     * @method squaredLength
     * @param {Array} a vector to calculate squared length of
     * @return {Number} squared length of a
     */
    Vec2.prototype.squaredLength = function (a) {
        var x = a[0], y = a[1];
        return x * x + y * y;
    };
    ;
    /**
     * Negates the components of a vec2
     * @static
     * @method negate
     * @param {Array} out the receiving vector
     * @param {Array} a vector to negate
     * @return {Array} out
     */
    Vec2.prototype.negate = function (out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        return out;
    };
    ;
    /**
     * Normalize a vec2
     * @static
     * @method normalize
     * @param {Array} out the receiving vector
     * @param {Array} a vector to normalize
     * @return {Array} out
     */
    Vec2.prototype.normalize = function (out, a) {
        var x = a[0], y = a[1];
        var len = x * x + y * y;
        if (len > 0) {
            //TODO: evaluate use of glm_invsqrt here?
            len = 1 / Math.sqrt(len);
            out[0] = a[0] * len;
            out[1] = a[1] * len;
        }
        return out;
    };
    ;
    /**
     * Calculates the dot product of two vec2's
     * @static
     * @method dot
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Number} dot product of a and b
     */
    Vec2.prototype.dot = function (a, b) {
        return a[0] * b[0] + a[1] * b[1];
    };
    ;
    /**
     * Returns a string representation of a vector
     * @static
     * @method str
     * @param {Array} vec vector to represent as a string
     * @return {String} string representation of the vector
     */
    Vec2.prototype.str = function (a) {
        throw "vec2.str is not supported in the typescript version of p2.";
        return 'vec2(' + a[0] + ', ' + a[1] + ')';
    };
    ;
    /**
     * Linearly interpolate/mix two vectors.
     * @static
     * @method lerp
     * @param {Array} out
     * @param {Array} a First vector
     * @param {Array} b Second vector
     * @param {number} t Lerp factor
     * @return {array}
     */
    Vec2.prototype.lerp = function (out, a, b, t) {
        var ax = a[0], ay = a[1];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        return out;
    };
    ;
    /**
     * Reflect a vector along a normal.
     * @static
     * @method reflect
     * @param {Array} out
     * @param {Array} vector
     * @param {Array} normal
     */
    Vec2.prototype.reflect = function (out, vector, normal) {
        var dot = vector[0] * normal[0] + vector[1] * normal[1];
        out[0] = vector[0] - 2 * normal[0] * dot;
        out[1] = vector[1] - 2 * normal[1] * dot;
    };
    ;
    /**
     * Get the intersection point between two line segments.
     * @static
     * @method getLineSegmentsIntersection
     * @param  {Array} out
     * @param  {Array} p0
     * @param  {Array} p1
     * @param  {Array} p2
     * @param  {Array} p3
     * @return {boolean} True if there was an intersection, otherwise false.
     */
    Vec2.prototype.getLineSegmentsIntersection = function (out, p0, p1, p2, p3) {
        var t = vec2.getLineSegmentsIntersectionFraction(p0, p1, p2, p3);
        if (t < 0) {
            return false;
        }
        else {
            out[0] = p0[0] + (t * (p1[0] - p0[0]));
            out[1] = p0[1] + (t * (p1[1] - p0[1]));
            return true;
        }
    };
    ;
    /**
     * Get the intersection fraction between two line segments. If successful, the intersection is at p0 + t * (p1 - p0)
     * @static
     * @method getLineSegmentsIntersectionFraction
     * @param  {Array} p0
     * @param  {Array} p1
     * @param  {Array} p2
     * @param  {Array} p3
     * @return {number} A number between 0 and 1 if there was an intersection, otherwise -1.
     */
    Vec2.prototype.getLineSegmentsIntersectionFraction = function (p0, p1, p2, p3) {
        var s1_x = p1[0] - p0[0];
        var s1_y = p1[1] - p0[1];
        var s2_x = p3[0] - p2[0];
        var s2_y = p3[1] - p2[1];
        var s, t;
        s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);
        t = (s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);
        if (s >= 0 && s <= 1 && t >= 0 && t <= 1) { // Collision detected
            return t;
        }
        return -1; // No collision
    };
    ;
    return Vec2;
}());
var vec2 = new Vec2();
exports.default = vec2;

},{}],29:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var add = vec2_1.default.add, sub = vec2_1.default.subtract, vec2create = vec2_1.default.create;
var aabb_1 = __importDefault(_dereq_("../collision/aabb"));
var poly_decomp_1 = __importDefault(_dereq_("../math/poly-decomp"));
var Convex_1 = __importDefault(_dereq_("../shapes/Convex"));
var ray_1 = __importDefault(_dereq_("../collision/ray"));
var raycast_result_1 = __importDefault(_dereq_("../collision/raycast-result"));
var event_emitter_1 = __importDefault(_dereq_("../events/event-emitter"));
//decomp = require('poly-decomp')
var integrate_fhMinv = vec2create();
var integrate_velodt = vec2create();
var _tmp = vec2create();
var _idCounter = 0;
var Body = /** @class */ (function (_super) {
    __extends(Body, _super);
    /**
     * A rigid body. Has got a center of mass, position, velocity and a number of
     * shapes that are used for collisions.
     *
     * @class Body
     * @constructor
     * @extends EventEmitter
     * @param {Object} [options]
     * @param {Boolean} [options.allowSleep=true]
     * @param {Number} [options.angle=0]
     * @param {Number} [options.angularDamping=0.1]
     * @param {Number} [options.angularForce=0]
     * @param {Number} [options.angularVelocity=0]
     * @param {Number} [options.ccdIterations=10]
     * @param {Number} [options.ccdSpeedThreshold=-1]
     * @param {Boolean} [options.collisionResponse]
     * @param {Number} [options.damping=0.1]
     * @param {Boolean} [options.fixedRotation=false]
     * @param {Boolean} [options.fixedX=false]
     * @param {Boolean} [options.fixedY=false]
     * @param {Array} [options.force]
     * @param {Number} [options.gravityScale=1]
     * @param {Number} [options.mass=0] A number >= 0. If zero, the .type will be set to Body.STATIC.
     * @param {Array} [options.position]
     * @param {Number} [options.sleepSpeedLimit]
     * @param {Number} [options.sleepTimeLimit]
     * @param {Number} [options.type] See {{#crossLink "Body/type:property"}}{{/crossLink}}
     * @param {Array} [options.velocity]
     *
     * @example
     *
     *     // Create a typical dynamic body
     *     var body = new Body({
     *         mass: 1, // non-zero mass will set type to Body.DYNAMIC
     *         position: [0, 5],
     *         angle: 0,
     *         velocity: [0, 0],
     *         angularVelocity: 0
     *     });
     *
     *     // Add a circular shape to the body
     *     var circleShape = new Circle({ radius: 0.5 });
     *     body.addShape(circleShape);
     *
     *     // Add the body to the world
     *     world.addBody(body);
     *
     * @example
     *
     *     // Create a static plane body
     *     var planeBody = new Body({
     *         mass: 0, // zero mass will set type to Body.STATIC
     *         position: [0, 0]
     *     });
     *     var planeShape = new Plane();
     *     planeBody.addShape(planeShape);
     *     world.addBody(planeBody);
     *
     * @example
     *
     *     // Create a moving kinematic box body
     *     var platformBody = new Body({
     *         type: Body.KINEMATIC,
     *         position: [0, 3],
     *         velocity: [1, 0]
     *     });
     *     var boxShape = new Box({ width: 2, height: 0.5 });
     *     platformBody.addShape(boxShape);
     *     world.addBody(platformBody);
     */
    function Body(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        var _this = _super.call(this) || this;
        /**
         * The body identifier. Read only!
         * @readonly
         * @property id
         * @type {Number}
        */
        _this.id = -1;
        /**
         * Index of the body in the World .bodies array. Is set to -1 if the body isn't added to a World.
         * @readonly
         * @property index
         * @type {Number}
         */
        _this.index = 0;
        /**
         * The world that this body is added to (read only). This property is set to NULL if the body is not added to any world.
         * @readonly
         * @property world
         * @type {World}
         */
        _this.world = null;
        /**
         * The shapes of the body.
         *
         * @property shapes
         * @type {Array}
         */
        _this.shapes = [];
        /**
         * The mass of the body. If you change this number, you should call {{#crossLink "Body/updateMassProperties:method"}}{{/crossLink}}.
         *
         * @property mass
         * @type {number}
         *
         * @example
         *     body.mass = 1;
         *     body.updateMassProperties();
         */
        _this.mass = 0;
        /**
         * The inverse mass of the body.
         *
         * @readonly
         * @property invMass
         * @type {number}
         */
        _this.invMass = 0;
        /**
         * The inertia of the body around the Z axis.
         * @readonly
         * @property inertia
         * @type {number}
         */
        _this.inertia = 0;
        /**
         * The inverse inertia of the body.
         * @readonly
         * @property invInertia
         * @type {number}
         */
        _this.invInertia = 0;
        _this.invMassSolve = 0;
        _this.invInertiaSolve = 0;
        /**
         * Set to true if you want to fix the rotation of the body.
         *
         * @property fixedRotation
         * @type {Boolean}
         *
         * @example
         *     // Fix rotation during runtime
         *     body.fixedRotation = true;
         *     body.updateMassProperties();
         */
        _this.fixedRotation = true;
        /**
         * Set to true if you want to fix the body movement along the X axis. The body will still be able to move along Y.
         * @property {Boolean} fixedX
         *
         * @example
         *     // Fix X movement on body creation
         *     var body = new Body({ mass: 1, fixedX: true });
         *
         * @example
         *     // Fix X movement during runtime
         *     body.fixedX = true;
         *     body.updateMassProperties();
         */
        _this.fixedX = false;
        /**
         * Set to true if you want to fix the body movement along the Y axis. The body will still be able to move along X. See .fixedX
         * @property {Boolean} fixedY
         */
        _this.fixedY = false;
        /**
         * Angular constraint velocity that was added to the body during last step.
         * @readonly
         * @property wlambda
         * @type {Array} // This was array before the port, but hte assignment was always 0.
         */
        _this.wlambda = 0;
        /**
         * The angle of the body, in radians.
         * @property angle
         * @type {number}
         * @example
         *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.
         *     // If you need a value between 0 and 2*pi, use the following function to normalize it.
         *     function normalizeAngle(angle){
         *         angle = angle % (2*Math.PI);
         *         if(angle < 0){
         *             angle += (2*Math.PI);
         *         }
         *         return angle;
         *     }
         */
        _this.angle = 0;
        /**
         * The previous angle of the body.
         * @readonly
         * @property previousAngle
         * @type {Number}
         */
        _this.previousAngle = 0;
        /**
         * The interpolated angle of the body. Use this for rendering.
         * @readonly
         * @property interpolatedAngle
         * @type {Number}
         */
        _this.interpolatedAngle = 0;
        /**
         * The angular velocity of the body, in radians per second.
         * @property angularVelocity
         * @type {number}
         */
        _this.angularVelocity = 0;
        /**
         * The angular force acting on the body. See {{#crossLink "Body/force:property"}}{{/crossLink}}.
         * @property angularForce
         * @type {number}
         */
        _this.angularForce = 0;
        /**
         * The angular force acting on the body. Should be a value between 0 and 1.
         * @property angularDamping
         * @type {Number}
         * @default 0.1
         */
        _this.angularDamping = 0.1;
        /**
         * The type of motion this body has. Should be one of: {{#crossLink "Body/STATIC:property"}}Body.STATIC{{/crossLink}}, {{#crossLink "Body/DYNAMIC:property"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink "Body/KINEMATIC:property"}}Body.KINEMATIC{{/crossLink}}.
         *
         * * Static bodies do not move, and they do not respond to forces or collision.
         * * Dynamic bodies body can move and respond to collisions and forces.
         * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.
         *
         * @property type
         * @type {number}
         *
         * @example
         *     // Bodies are static by default. Static bodies will never move.
         *     var body = new Body();
         *     console.log(body.type == Body.STATIC); // true
         *
         * @example
         *     // By setting the mass of a body to a nonzero number, the body
         *     // will become dynamic and will move and interact with other bodies.
         *     var dynamicBody = new Body({
         *         mass : 1
         *     });
         *     console.log(dynamicBody.type == Body.DYNAMIC); // true
         *
         * @example
         *     // Kinematic bodies will only move if you change their velocity.
         *     var kinematicBody = new Body({
         *         type: Body.KINEMATIC // Type can be set via the options object.
         *     });
         */
        _this.type = Body.STATIC;
        /**
         * Bounding circle radius. Update with {{#crossLink "Body/updateBoundingRadius:method"}}{{/crossLink}}.
         * @readonly
         * @property boundingRadius
         * @type {Number}
         */
        _this.boundingRadius = 0;
        /**
         * Indicates if the AABB needs update. Update it with {{#crossLink "Body/updateAABB:method"}}{{/crossLink}}.
         * @property aabbNeedsUpdate
         * @type {Boolean}
         * @see updateAABB
         *
         * @example
         *     // Force update the AABB
         *     body.aabbNeedsUpdate = true;
         *     body.updateAABB();
         *     console.log(body.aabbNeedsUpdate); // false
         */
        _this.aabbNeedsUpdate = true;
        /**
         * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink "World"}}{{/crossLink}} before anything will happen.
         * @property allowSleep
         * @type {Boolean}
         * @default true
         */
        _this.allowSleep = true;
        _this.wantsToSleep = false;
        /**
         * One of {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}}, {{#crossLink "Body/SLEEPY:property"}}Body.SLEEPY{{/crossLink}} and {{#crossLink "Body/SLEEPING:property"}}Body.SLEEPING{{/crossLink}}.
         *
         * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).
         *
         * @property sleepState
         * @type {Number}
         * @default Body.AWAKE
         */
        _this.sleepState = Body.AWAKE;
        /**
         * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
         * @property sleepSpeedLimit
         * @type {Number}
         * @default 0.2
         */
        _this.sleepSpeedLimit = 0.2;
        /**
         * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
         * @property sleepTimeLimit
         * @type {Number}
         * @default 1
         */
        _this.sleepTimeLimit = 1;
        /**
         * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.
         * @property {Number} gravityScale
         * @default 1
         */
        _this.gravityScale = 1;
        /**
         * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.
         * @property {Boolean} collisionResponse
         */
        _this.collisionResponse = true;
        /**
         * How long the body has been sleeping.
         * @readonly
         * @property {Number} idleTime
         */
        _this.idleTime = 0;
        /**
         * The last time when the body went to SLEEPY state.
         * @readonly
         * @property {Number} timeLastSleepy
         * @private
         */
        _this.timeLastSleepy = 0;
        /**
         * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.
         * @property {number} ccdSpeedThreshold
         * @default -1
         */
        _this.ccdSpeedThreshold = -1;
        /**
         * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.
         * @property {number} ccdIterations
         * @default 10
         */
        _this.ccdIterations = 10;
        /**
         * @property {number} islandId
         */
        _this.islandId = -1;
        _this.concavePath = [];
        // Should be private, but used by world.
        _this._wakeUpAfterNarrowphase = false;
        _this._shapeAABB = new aabb_1.default();
        _this.id = (_a = options === null || options === void 0 ? void 0 : options.id) !== null && _a !== void 0 ? _a : ++_idCounter;
        _this.mass = (_b = options === null || options === void 0 ? void 0 : options.mass) !== null && _b !== void 0 ? _b : 0;
        _this.fixedRotation = (_c = options === null || options === void 0 ? void 0 : options.fixedRotation) !== null && _c !== void 0 ? _c : false;
        _this.fixedX = (_d = options === null || options === void 0 ? void 0 : options.fixedX) !== null && _d !== void 0 ? _d : false;
        _this.fixedY = (_e = options === null || options === void 0 ? void 0 : options.fixedY) !== null && _e !== void 0 ? _e : false;
        _this.massMultiplier = vec2create();
        _this.position = (options === null || options === void 0 ? void 0 : options.position) ? vec2_1.default.clone(options.position) : vec2create();
        _this.interpolatedPosition = vec2_1.default.clone(_this.position);
        _this.previousPosition = vec2_1.default.clone(_this.position);
        _this.velocity = (options === null || options === void 0 ? void 0 : options.velocity) ? vec2_1.default.clone(options.velocity) : vec2create();
        _this.vlambda = vec2create();
        _this.angle = (_f = options === null || options === void 0 ? void 0 : options.angle) !== null && _f !== void 0 ? _f : 0;
        _this.previousAngle = _this.angle;
        _this.interpolatedAngle = _this.angle;
        _this.angularVelocity = (_g = options === null || options === void 0 ? void 0 : options.angularVelocity) !== null && _g !== void 0 ? _g : 0;
        _this.force = (options === null || options === void 0 ? void 0 : options.force) ? vec2_1.default.clone(options.force) : vec2create();
        _this.angularForce = (_h = options === null || options === void 0 ? void 0 : options.angularForce) !== null && _h !== void 0 ? _h : 0;
        _this.damping = (_j = options === null || options === void 0 ? void 0 : options.damping) !== null && _j !== void 0 ? _j : 0.1;
        _this.angularDamping = (_k = options === null || options === void 0 ? void 0 : options.angularDamping) !== null && _k !== void 0 ? _k : 0.1;
        _this.sleepTimeLimit = (_l = options === null || options === void 0 ? void 0 : options.sleepTimeLimit) !== null && _l !== void 0 ? _l : 1;
        if ((options === null || options === void 0 ? void 0 : options.type) !== undefined) {
            _this.type = options.type;
        }
        else if (!(options === null || options === void 0 ? void 0 : options.mass)) {
            _this.type = Body.STATIC;
        }
        else {
            _this.type = Body.DYNAMIC;
        }
        _this.aabb = new aabb_1.default();
        _this.allowSleep = (_m = options === null || options === void 0 ? void 0 : options.allowSleep) !== null && _m !== void 0 ? _m : true;
        _this.sleepSpeedLimit = (_o = options === null || options === void 0 ? void 0 : options.sleepSpeedLimit) !== null && _o !== void 0 ? _o : 0.2;
        _this.gravityScale = (_p = options === null || options === void 0 ? void 0 : options.gravityScale) !== null && _p !== void 0 ? _p : 1;
        _this.collisionResponse = (_q = options === null || options === void 0 ? void 0 : options.collisionResponse) !== null && _q !== void 0 ? _q : true;
        _this.ccdSpeedThreshold = (_r = options === null || options === void 0 ? void 0 : options.ccdSpeedThreshold) !== null && _r !== void 0 ? _r : -1;
        _this.ccdIterations = (_s = options === null || options === void 0 ? void 0 : options.ccdIterations) !== null && _s !== void 0 ? _s : 10;
        _this.updateMassProperties();
        return _this;
    }
    /**
     * @private
     * @method updateSolveMassProperties
     */
    Body.prototype.updateSolveMassProperties = function () {
        if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
            this.invMassSolve = 0;
            this.invInertiaSolve = 0;
        }
        else {
            this.invMassSolve = this.invMass;
            this.invInertiaSolve = this.invInertia;
        }
    };
    ;
    /**
     * Set the total density of the body
     * @method setDensity
     * @param {number} density
     */
    Body.prototype.setDensity = function (density) {
        var totalArea = this.getArea();
        this.mass = totalArea * density;
        this.updateMassProperties();
    };
    ;
    /**
     * Get the total area of all shapes in the body
     * @method getArea
     * @return {Number}
     */
    Body.prototype.getArea = function () {
        var totalArea = 0;
        for (var i = 0; i < this.shapes.length; i++) {
            totalArea += this.shapes[i].area;
        }
        return totalArea;
    };
    ;
    /**
     * Get the AABB from the body. The AABB is updated if necessary.
     * @method getAABB
     * @return {AABB} The AABB instance from the body.
     */
    Body.prototype.getAABB = function () {
        if (this.aabbNeedsUpdate) {
            this.updateAABB();
        }
        return this.aabb;
    };
    ;
    /**
     * Updates the AABB of the Body, and set .aabbNeedsUpdate = false.
     * @method updateAABB
     */
    Body.prototype.updateAABB = function () {
        var shapes = this.shapes, N = shapes.length, offset = _tmp, bodyAngle = this.angle;
        for (var i = 0; i !== N; i++) {
            var shape = shapes[i], angle = shape.angle + bodyAngle;
            // Get shape world offset
            vec2_1.default.toGlobalFrame(offset, shape.position, this.position, bodyAngle);
            // Get shape AABB
            shape.computeAABB(this._shapeAABB, offset, angle);
            if (i === 0) {
                this.aabb.copy(this._shapeAABB);
            }
            else {
                this.aabb.extend(this._shapeAABB);
            }
        }
        this.aabbNeedsUpdate = false;
    };
    ;
    /**
     * Update the bounding radius of the body (this.boundingRadius). Should be done if any of the shape dimensions or positions are changed.
     * @method updateBoundingRadius
     */
    Body.prototype.updateBoundingRadius = function () {
        var shapes = this.shapes, N = shapes.length, radius = 0;
        for (var i = 0; i !== N; i++) {
            var shape = shapes[i], offset = vec2_1.default.length(shape.position), r = shape.boundingRadius;
            if (offset + r > radius) {
                radius = offset + r;
            }
        }
        this.boundingRadius = radius;
    };
    ;
    /**
     * Add a shape to the body. You can pass a local transform when adding a shape,
     * so that the shape gets an offset and angle relative to the body center of mass.
     * Will automatically update the mass properties and bounding radius.
     *
     * @method addShape
     * @param  {Shape}              shape
     * @param  {Array} [offset] Local body offset of the shape.
     * @param  {Number}             [angle]  Local body angle.
     *
     * @example
     *     var body = new Body(),
     *         shape = new Circle({ radius: 1 });
     *
     *     // Add the shape to the body, positioned in the center
     *     body.addShape(shape);
     *
     *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.
     *     body.addShape(shape,[1,0]);
     *
     *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.
     *     body.addShape(shape,[0,1],Math.PI/2);
     */
    Body.prototype.addShape = function (shape, offset, angle) {
        if (angle === void 0) { angle = 0; }
        if (shape.body) {
            throw new Error('A shape can only be added to one body.');
        }
        var world = this.world;
        if (world && world.stepping) {
            throw new Error('A shape cannot be added during step.');
        }
        shape.body = this;
        // Copy the offset vector
        if (offset) {
            vec2_1.default.copy(shape.position, offset);
        }
        else {
            vec2_1.default.set(shape.position, 0, 0);
        }
        shape.angle = angle || 0;
        this.shapes.push(shape);
        this.updateMassProperties();
        this.updateBoundingRadius();
        this.aabbNeedsUpdate = true;
    };
    ;
    /**
     * Remove a shape.
     * @method removeShape
     * @param  {Shape} shape
     * @return {Boolean} True if the shape was found and removed, else false.
     */
    Body.prototype.removeShape = function (shape) {
        var world = this.world;
        if (world && world.stepping) {
            throw new Error('A shape cannot be removed during step.');
        }
        var idx = this.shapes.indexOf(shape);
        if (idx !== -1) {
            this.shapes.splice(idx, 1);
            this.aabbNeedsUpdate = true;
            shape.body = undefined;
            return true;
        }
        else {
            return false;
        }
    };
    ;
    /**
     * Updates .inertia, .invMass, .invInertia for this Body. Should be called when changing the structure or mass of the Body.
     *
     * @method updateMassProperties
     *
     * @example
     *     body.mass += 1;
     *     body.updateMassProperties();
     */
    Body.prototype.updateMassProperties = function () {
        if (this.type === Body.STATIC || this.type === Body.KINEMATIC) {
            // Consider making it infinity.
            this.mass = Infinity;
            this.invMass = 0;
            this.inertia = Infinity;
            this.invInertia = 0;
        }
        else {
            var shapes = this.shapes, N = shapes.length, I = 0;
            if (!this.fixedRotation) {
                for (var i = 0; i < N; i++) {
                    var shape = shapes[i], r2 = vec2_1.default.squaredLength(shape.position), Icm = shape.computeMomentOfInertia();
                    I += Icm + r2;
                }
                this.inertia = this.mass * I;
                this.invInertia = I > 0 ? 1 / I : 0;
            }
            else {
                this.inertia = Infinity;
                this.invInertia = 0;
            }
            // Inverse mass properties are easy
            this.invMass = 1 / this.mass;
            vec2_1.default.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1);
        }
    };
    ;
    /**
     * Apply force to a point relative to the center of mass of the body. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.angularForce.
     * @method applyForce
     * @param  {Array} force The force vector to add, oriented in world space.
     * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the force will be exerted on the center of mass.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var relativePoint = [1, 0]; // Will apply the force at [body.position[0] + 1, body.position[1]]
     *     var force = [0, 1]; // up
     *     body.applyForce(force, relativePoint);
     *     console.log(body.force); // [0, 1]
     *     console.log(body.angularForce); // 1
     */
    Body.prototype.applyForce = function (force, relativePoint) {
        // Add linear force
        add(this.force, this.force, force);
        if (relativePoint) {
            // Compute produced rotational force
            var rotForce = vec2_1.default.crossLength(relativePoint, force);
            // Add rotational force
            this.angularForce += rotForce;
        }
    };
    ;
    /**
     * Apply force to a point relative to the center of mass of the body. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.angularForce.
     * @method applyForceLocal
     * @param  {Array} localForce The force vector to add, oriented in local body space.
     * @param  {Array} [localPoint] A point relative to the body in local body space. If not given, it is set to zero and all of the force will be exerted on the center of mass.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var localPoint = [1, 0]; // x=1 locally in the body
     *     var localForce = [0, 1]; // up, locally in the body
     *     body.applyForceLocal(localForce, localPoint);
     *     console.log(body.force); // [0, 1]
     *     console.log(body.angularForce); // 1
     */
    Body.prototype.applyForceLocal = function (localForce, localPoint) {
        // These 3 lines were originally outside of this function. Not sure why.
        var Body_applyForce_forceWorld = vec2create();
        var Body_applyForce_pointWorld = vec2create();
        var Body_applyForce_pointLocal = vec2create();
        localPoint = localPoint || Body_applyForce_pointLocal;
        var worldForce = Body_applyForce_forceWorld;
        var worldPoint = Body_applyForce_pointWorld;
        this.vectorToWorldFrame(worldForce, localForce);
        this.vectorToWorldFrame(worldPoint, localPoint);
        this.applyForce(worldForce, worldPoint);
    };
    ;
    /**
     * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
     * @method applyImpulse
     * @param  {Array} impulseVector The impulse vector to add, oriented in world space.
     * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be exerted on the center of mass.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var relativePoint = [0, 0]; // center of the body
     *     var impulseVector = [0, 1]; // world up
     *     body.applyImpulse(impulseVector, relativePoint);
     */
    Body.prototype.applyImpulse = function (impulseVector, relativePoint) {
        var Body_applyImpulse_velo = vec2create(); // Was originally outside of this function. 
        if (this.type !== Body.DYNAMIC) {
            return;
        }
        // Compute produced central impulse velocity
        var velo = Body_applyImpulse_velo;
        vec2_1.default.scale(velo, impulseVector, this.invMass);
        vec2_1.default.multiply(velo, this.massMultiplier, velo);
        // Add linear impulse
        add(this.velocity, velo, this.velocity);
        if (relativePoint) {
            // Compute produced rotational impulse velocity
            var rotVelo = vec2_1.default.crossLength(relativePoint, impulseVector);
            rotVelo *= this.invInertia;
            // Add rotational Impulse
            this.angularVelocity += rotVelo;
        }
    };
    ;
    /**
     * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
     * @method applyImpulseLocal
     * @param  {Array} localImpulse The impulse vector to add, oriented in local body space.
     * @param  {Array} [localPoint] A point relative to the body in local body space. If not given, it is set to zero and all of the impulse will be exerted on the center of mass.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var localPoint = [1, 0]; // x=1, locally in the body
     *     var localImpulse = [0, 1]; // up, locally in the body
     *     body.applyImpulseLocal(localImpulse, localPoint);
     *     console.log(body.velocity); // [1, 0]
     *     console.log(body.angularVelocity); // 1
     */
    Body.prototype.applyImpulseLocal = function (localImpulse, localPoint) {
        // Originally outside of this function.
        var Body_applyImpulse_impulseWorld = vec2create();
        var Body_applyImpulse_pointWorld = vec2create();
        var Body_applyImpulse_pointLocal = vec2create();
        localPoint = localPoint || Body_applyImpulse_pointLocal;
        var worldImpulse = Body_applyImpulse_impulseWorld;
        var worldPoint = Body_applyImpulse_pointWorld;
        this.vectorToWorldFrame(worldImpulse, localImpulse);
        this.vectorToWorldFrame(worldPoint, localPoint);
        this.applyImpulse(worldImpulse, worldPoint);
    };
    ;
    /**
     * Transform a world point to local body frame.
     * @method toLocalFrame
     * @param  {Array} out          The point to store the result in
     * @param  {Array} worldPoint   The input world point
     */
    Body.prototype.toLocalFrame = function (out, worldPoint) {
        vec2_1.default.toLocalFrame(out, worldPoint, this.position, this.angle);
    };
    ;
    /**
     * Transform a local point to world frame.
     * @method toWorldFrame
     * @param  {Array} out          The point to store the result in
     * @param  {Array} localPoint   The input local point
     */
    Body.prototype.toWorldFrame = function (out, localPoint) {
        vec2_1.default.toGlobalFrame(out, localPoint, this.position, this.angle);
    };
    ;
    /**
     * Transform a world vector to local body frame.
     * @method vectorToLocalFrame
     * @param  {Array} out          The vector to store the result in
     * @param  {Array} worldVector  The input world vector
     */
    Body.prototype.vectorToLocalFrame = function (out, worldVector) {
        vec2_1.default.vectorToLocalFrame(out, worldVector, this.angle);
    };
    ;
    /**
     * Transform a local vector to world frame.
     * @method vectorToWorldFrame
     * @param  {Array} out          The vector to store the result in
     * @param  {Array} localVector  The input local vector
     */
    Body.prototype.vectorToWorldFrame = function (out, localVector) {
        vec2_1.default.rotate(out, localVector, this.angle);
    };
    ;
    /**
     * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.
     * @method fromPolygon
     * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.
     * @param {Object} [options]
     * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
     * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.
     * @param {Number} [options.removeCollinearPoints=0] Set to a number (angle threshold value) to remove collinear points, or 0 to keep all points.
     * @return {Boolean} True on success, else false.
     * @example
     *     var body = new Body();
     *     var path = [
     *         [-1, 1],
     *         [-1, 0],
     *         [1, 0],
     *         [1, 1],
     *         [0.5, 0.5]
     *     ];
     *     body.fromPolygon(path);
     *     console.log(body.shapes); // [Convex, Convex, ...]
     */
    Body.prototype.fromPolygon = function (path, options) {
        var _a, _b, _c;
        // Remove all shapes
        for (var i = this.shapes.length; i >= 0; --i) {
            this.removeShape(this.shapes[i]);
        }
        // Copy the path
        var p = [];
        for (var i = 0; i < path.length; i++) {
            p[i] = vec2_1.default.clone(path[i]);
        }
        // Make it counter-clockwise
        poly_decomp_1.default.makeCCW(p);
        if ((options === null || options === void 0 ? void 0 : options.removeCollinearPoints) != 0) {
            poly_decomp_1.default.removeCollinearPoints(p, (_a = options === null || options === void 0 ? void 0 : options.removeCollinearPoints) !== null && _a !== void 0 ? _a : 0);
        }
        // Check if any line segment intersects the path itself
        if (!(options === null || options === void 0 ? void 0 : options.skipSimpleCheck)) {
            if (!poly_decomp_1.default.isSimple(p)) {
                return false;
            }
        }
        // Save this path for later
        this.concavePath = [];
        for (var i = 0; i < p.length; i++) {
            this.concavePath[i] = vec2_1.default.clone(p[i]);
        }
        // Slow or fast decomp?
        var convexes;
        if (options === null || options === void 0 ? void 0 : options.optimalDecomp) {
            convexes = (_b = poly_decomp_1.default.decomp(p)) !== null && _b !== void 0 ? _b : new Array();
        }
        else {
            convexes = (_c = poly_decomp_1.default.quickDecomp(p)) !== null && _c !== void 0 ? _c : new Array();
        }
        var cm = vec2create();
        // Add convexes
        for (var i = 0; i !== convexes.length; i++) {
            // Create convex
            var c = new Convex_1.default(undefined, convexes[i]);
            // Move all vertices so its center of mass is in the local center of the convex
            for (var j = 0; j !== c.vertices.length; j++) {
                var v = c.vertices[j];
                sub(v, v, c.centerOfMass);
            }
            vec2_1.default.copy(cm, c.centerOfMass);
            c = new Convex_1.default(undefined, c.vertices);
            // Add the shape
            this.addShape(c, cm);
        }
        this.adjustCenterOfMass();
        this.aabbNeedsUpdate = true;
        return true;
    };
    /**
     * Moves the shape offsets so their center of mass becomes the body center of mass.
     * @method adjustCenterOfMass
     * @example
     *     var body = new Body({ position: [0, 0] });
     *     var shape = new Circle({ radius: 1 });
     *     body.addShape(shape, [1, 0], 0);
     *     body.adjustCenterOfMass();
     *     console.log(body.position); // [1, 0]
     *     console.log(shape.position); // [0, 0]
     */
    Body.prototype.adjustCenterOfMass = function () {
        var adjustCenterOfMass_tmp2 = vec2create(), adjustCenterOfMass_tmp3 = vec2create(), adjustCenterOfMass_tmp4 = vec2create();
        var offset_times_area = adjustCenterOfMass_tmp2, sum = adjustCenterOfMass_tmp3, cm = adjustCenterOfMass_tmp4, totalArea = 0;
        vec2_1.default.set(sum, 0, 0);
        for (var i = 0; i !== this.shapes.length; i++) {
            var s = this.shapes[i];
            vec2_1.default.scale(offset_times_area, s.position, s.area);
            add(sum, sum, offset_times_area);
            totalArea += s.area;
        }
        vec2_1.default.scale(cm, sum, 1 / totalArea);
        // Now move all shapes
        for (var i = 0; i !== this.shapes.length; i++) {
            var s = this.shapes[i];
            sub(s.position, s.position, cm);
        }
        // Move the body position too
        add(this.position, this.position, cm);
        // And concave path
        for (var i = 0; this.concavePath && i < this.concavePath.length; i++) {
            sub(this.concavePath[i], this.concavePath[i], cm);
        }
        this.updateMassProperties();
        this.updateBoundingRadius();
    };
    /**
     * Sets the force on the body to zero.
     * @method setZeroForce
     */
    Body.prototype.setZeroForce = function () {
        var f = this.force;
        f[0] = f[1] = this.angularForce = 0;
    };
    Body.prototype.resetConstraintVelocity = function () {
        var b = this, vlambda = b.vlambda;
        vec2_1.default.set(vlambda, 0, 0);
        b.wlambda = 0;
    };
    Body.prototype.addConstraintVelocity = function () {
        var b = this, v = b.velocity;
        add(v, v, b.vlambda);
        b.angularVelocity += b.wlambda;
    };
    /**
     * Apply damping, see <a href="http://code.google.com/p/bullet/issues/detail?id=74">this</a> for details.
     * @method applyDamping
     * @param  {number} dt Current time step
     */
    Body.prototype.applyDamping = function (dt) {
        if (this.type === Body.DYNAMIC) { // Only for dynamic bodies
            var v = this.velocity;
            vec2_1.default.scale(v, v, Math.pow(1 - this.damping, dt));
            this.angularVelocity *= Math.pow(1 - this.angularDamping, dt);
        }
    };
    /**
     * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.
     * Sets the sleepState to {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.
     * @method wakeUp
     */
    Body.prototype.wakeUp = function () {
        var s = this.sleepState;
        this.sleepState = Body.AWAKE;
        this.idleTime = 0;
        if (s !== Body.AWAKE) {
            _super.prototype.emit.call(this, wakeUpEvent);
        }
    };
    /**
     * Force body sleep
     * @method sleep
     */
    Body.prototype.sleep = function () {
        this.sleepState = Body.SLEEPING;
        this.angularVelocity = this.angularForce = 0;
        vec2_1.default.set(this.velocity, 0, 0);
        vec2_1.default.set(this.force, 0, 0);
        _super.prototype.emit.call(this, sleepEvent);
    };
    /**
     * Called every timestep to update internal sleep timer and change sleep state if needed.
     * @method sleepTick
     * @param {number} time The world time in seconds
     * @param {boolean} dontSleep
     * @param {number} dt
     */
    Body.prototype.sleepTick = function (time, dontSleep, dt) {
        if (!this.allowSleep || this.type === Body.SLEEPING) {
            return;
        }
        this.wantsToSleep = false;
        var speedSquared = vec2_1.default.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2), speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);
        // Add to idle time
        if (speedSquared >= speedLimitSquared) {
            this.idleTime = 0;
            this.sleepState = Body.AWAKE;
        }
        else {
            this.idleTime += dt;
            if (this.sleepState !== Body.SLEEPY) {
                this.sleepState = Body.SLEEPY;
                _super.prototype.emit.call(this, sleepyEvent);
            }
        }
        if (this.idleTime > this.sleepTimeLimit) {
            if (!dontSleep) {
                this.sleep();
            }
            else {
                this.wantsToSleep = true;
            }
        }
    };
    /**
     * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.
     * @method overlaps
     * @param  {Body} body
     * @return {boolean}
     */
    Body.prototype.overlaps = function (body) {
        if (!this.world)
            return false;
        return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
    };
    /**
     * Move the body forward in time given its current velocity.
     * @method integrate
     * @param  {Number} dt
     */
    Body.prototype.integrate = function (dt) {
        var minv = this.invMass, f = this.force, pos = this.position, velo = this.velocity;
        // Save old position
        vec2_1.default.copy(this.previousPosition, this.position);
        this.previousAngle = this.angle;
        // Velocity update
        if (!this.fixedRotation) {
            this.angularVelocity += this.angularForce * this.invInertia * dt;
        }
        vec2_1.default.scale(integrate_fhMinv, f, dt * minv);
        vec2_1.default.multiply(integrate_fhMinv, this.massMultiplier, integrate_fhMinv);
        add(velo, integrate_fhMinv, velo);
        // CCD
        if (!this.integrateToTimeOfImpact(dt)) {
            // Regular position update
            vec2_1.default.scale(integrate_velodt, velo, dt);
            add(pos, pos, integrate_velodt);
            if (!this.fixedRotation) {
                this.angle += this.angularVelocity * dt;
            }
        }
        this.aabbNeedsUpdate = true;
    };
    Body.prototype.integrateToTimeOfImpact = function (dt) {
        var _a;
        if (!this.world)
            return false;
        var result = new raycast_result_1.default();
        var ray = new ray_1.default({
            mode: ray_1.default.CLOSEST,
            skipBackfaces: true
        });
        var direction = vec2create();
        var end = vec2create();
        var startToEnd = vec2create();
        var rememberPosition = vec2create();
        if (this.ccdSpeedThreshold < 0 || vec2_1.default.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) {
            return false;
        }
        // Ignore all the ignored body pairs
        // This should probably be done somewhere else for optimization
        var ignoreBodies = [];
        var disabledPairs = this.world.disabledBodyCollisionPairs;
        for (var i = 0; i < disabledPairs.length; i += 2) {
            var bodyA = disabledPairs[i];
            var bodyB = disabledPairs[i + 1];
            if (bodyA === this) {
                ignoreBodies.push(bodyB);
            }
            else if (bodyB === this) {
                ignoreBodies.push(bodyA);
            }
        }
        vec2_1.default.normalize(direction, this.velocity);
        vec2_1.default.scale(end, this.velocity, dt);
        add(end, end, this.position);
        sub(startToEnd, end, this.position);
        var startToEndAngle = this.angularVelocity * dt;
        var len = vec2_1.default.length(startToEnd);
        var timeOfImpact = 1;
        var hitBody = null;
        vec2_1.default.copy(ray.from, this.position);
        vec2_1.default.copy(ray.to, end);
        ray.update();
        for (var i = 0; i < this.shapes.length; i++) {
            var shape = this.shapes[i];
            result.reset();
            ray.collisionGroup = shape.collisionGroup;
            ray.collisionMask = shape.collisionMask;
            this.world.raycast(result, ray);
            hitBody = (_a = result.body) !== null && _a !== void 0 ? _a : null;
            if (!hitBody)
                continue;
            if (hitBody === this || ignoreBodies.indexOf(hitBody) !== -1) {
                hitBody = null;
            }
            if (hitBody) {
                break;
            }
        }
        if (!hitBody || !timeOfImpact) {
            return false;
        }
        result.getHitPoint(end, ray);
        sub(startToEnd, end, this.position);
        timeOfImpact = vec2_1.default.distance(end, this.position) / len; // guess
        var rememberAngle = this.angle;
        vec2_1.default.copy(rememberPosition, this.position);
        // Got a start and end point. Approximate time of impact using binary search
        var iter = 0;
        var tmin = 0;
        var tmid = timeOfImpact;
        var tmax = 1;
        while (tmax >= tmin && iter < this.ccdIterations) {
            iter++;
            // calculate the midpoint
            tmid = (tmax + tmin) / 2;
            // Move the body to that point
            vec2_1.default.scale(integrate_velodt, startToEnd, tmid);
            add(this.position, rememberPosition, integrate_velodt);
            this.angle = rememberAngle + startToEndAngle * tmid;
            this.updateAABB();
            // check overlap
            var overlaps = this.aabb.overlaps(hitBody.aabb) && this.world.narrowphase.bodiesOverlap(this, hitBody, true);
            if (overlaps) {
                // change max to search lower interval
                tmax = tmid;
            }
            else {
                // change min to search upper interval
                tmin = tmid;
            }
        }
        timeOfImpact = tmax; // Need to guarantee overlap to resolve collisions
        vec2_1.default.copy(this.position, rememberPosition);
        this.angle = rememberAngle;
        // move to TOI
        vec2_1.default.scale(integrate_velodt, startToEnd, timeOfImpact);
        add(this.position, this.position, integrate_velodt);
        if (!this.fixedRotation) {
            this.angle += startToEndAngle * timeOfImpact;
        }
        return true;
    };
    /**
     * Get velocity of a point in the body.
     * @method getVelocityAtPoint
     * @param  {Array} result A vector to store the result in
     * @param  {Array} relativePoint A world oriented vector, indicating the position of the point to get the velocity from
     * @return {Array} The result vector
     * @example
     *     var body = new Body({
     *         mass: 1,
     *         velocity: [1, 0],
     *         angularVelocity: 1
     *     });
     *     var result = [];
     *     var point = [1, 0];
     *     body.getVelocityAtPoint(result, point);
     *     console.log(result); // [1, 1]
     */
    Body.prototype.getVelocityAtPoint = function (result, relativePoint) {
        vec2_1.default.crossVZ(result, relativePoint, this.angularVelocity);
        vec2_1.default.subtract(result, this.velocity, result);
        return result;
    };
    /**
     * Dynamic body.
     * @property DYNAMIC
     * @type {Number}
     * @static
     */
    Body.DYNAMIC = 1;
    /**
     * Static body.
     * @property STATIC
     * @type {Number}
     * @static
     */
    Body.STATIC = 2;
    /**
     * Kinematic body.
     * @property KINEMATIC
     * @type {Number}
     * @static
     */
    Body.KINEMATIC = 4;
    /**
     * @property AWAKE
     * @type {Number}
     * @static
     */
    Body.AWAKE = 0;
    /**
     * @property SLEEPY
     * @type {Number}
     * @static
     */
    Body.SLEEPY = 1;
    /**
     * @property SLEEPING
     * @type {Number}
     * @static
     */
    Body.SLEEPING = 2;
    return Body;
}(event_emitter_1.default));
exports.default = Body;
/**
 * @event sleepy
 */
var sleepyEvent = {
    type: "sleepy"
};
/**
 * @event sleep
 */
var sleepEvent = {
    type: "sleep"
};
/**
 * @event wakeup
 */
var wakeUpEvent = {
    type: "wakeup"
};

},{"../collision/aabb":1,"../collision/ray":5,"../collision/raycast-result":6,"../events/event-emitter":21,"../math/poly-decomp":26,"../math/vec2":28,"../shapes/Convex":37}],30:[function(_dereq_,module,exports){
module.exports=_dereq_(29)
},{"../collision/aabb":1,"../collision/ray":5,"../collision/raycast-result":6,"../events/event-emitter":21,"../math/poly-decomp":26,"../math/vec2":28,"../shapes/Convex":37}],31:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var spring_1 = __importDefault(_dereq_("./spring"));
var applyForce_r = vec2_1.default.create(), applyForce_r_unit = vec2_1.default.create(), applyForce_u = vec2_1.default.create(), applyForce_f = vec2_1.default.create(), applyForce_worldAnchorA = vec2_1.default.create(), applyForce_worldAnchorB = vec2_1.default.create(), applyForce_ri = vec2_1.default.create(), applyForce_rj = vec2_1.default.create(), applyForce_tmp = vec2_1.default.create();
var LinearSpring = /** @class */ (function (_super) {
    __extends(LinearSpring, _super);
    /**
     * A spring, connecting two bodies.
     *
     * The Spring explicitly adds force and angularForce to the bodies.
     *
     * @class LinearSpring
     * @extends Spring
     * @constructor
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.
     * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
     * @param {number} [options.damping=1]      A number >= 0. Default: 1
     * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
     * @param {Array}  [options.worldAnchorB]
     * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
     * @param {Array}  [options.localAnchorB]
     *
     * @example
     *     var spring = new LinearSpring(bodyA, bodyB, {
     *         stiffness: 100,
     *         damping: 1,
     *         localAnchorA: [0,0], // center of bodyA
     *         localAnchorB: [0,0] // center of bodyB
     *     });
     *     world.addSpring(spring);
     */
    function LinearSpring(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, options) || this;
        _this.localAnchorA = vec2_1.default.create();
        _this.localAnchorB = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.localAnchorA) {
            vec2_1.default.copy(_this.localAnchorA, options.localAnchorA);
        }
        if (options === null || options === void 0 ? void 0 : options.localAnchorB) {
            vec2_1.default.copy(_this.localAnchorB, options.localAnchorB);
        }
        if (options === null || options === void 0 ? void 0 : options.worldAnchorA) {
            _this.setWorldAnchorA(options.worldAnchorA);
        }
        if (options === null || options === void 0 ? void 0 : options.worldAnchorB) {
            _this.setWorldAnchorB(options.worldAnchorB);
        }
        var worldAnchorA = vec2_1.default.create();
        var worldAnchorB = vec2_1.default.create();
        _this.getWorldAnchorA(worldAnchorA);
        _this.getWorldAnchorB(worldAnchorB);
        var worldDistance = vec2_1.default.distance(worldAnchorA, worldAnchorB);
        _this.restLength = (_a = options === null || options === void 0 ? void 0 : options.restLength) !== null && _a !== void 0 ? _a : worldDistance;
        return _this;
    }
    /**
     * Set the anchor point on body A, using world coordinates.
     * @method setWorldAnchorA
     * @param {Array} worldAnchorA
     */
    LinearSpring.prototype.setWorldAnchorA = function (worldAnchorA) {
        this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
    };
    /**
     * Set the anchor point on body B, using world coordinates.
     * @method setWorldAnchorB
     * @param {Array} worldAnchorB
     */
    LinearSpring.prototype.setWorldAnchorB = function (worldAnchorB) {
        this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
    };
    /**
     * Get the anchor point on body A, in world coordinates.
     * @method getWorldAnchorA
     * @param {Array} result The vector to store the result in.
     */
    LinearSpring.prototype.getWorldAnchorA = function (result) {
        this.bodyA.toWorldFrame(result, this.localAnchorA);
    };
    /**
     * Get the anchor point on body B, in world coordinates.
     * @method getWorldAnchorB
     * @param {Array} result The vector to store the result in.
     */
    LinearSpring.prototype.getWorldAnchorB = function (result) {
        this.bodyB.toWorldFrame(result, this.localAnchorB);
    };
    /**
     * Apply the spring force to the connected bodies.
     * @private
     * @method applyForce
     */
    LinearSpring.prototype.applyForce = function () {
        var k = this.stiffness, d = this.damping, l = this.restLength, bodyA = this.bodyA, bodyB = this.bodyB, r = applyForce_r, r_unit = applyForce_r_unit, u = applyForce_u, f = applyForce_f, tmp = applyForce_tmp;
        var worldAnchorA = applyForce_worldAnchorA, worldAnchorB = applyForce_worldAnchorB, ri = applyForce_ri, rj = applyForce_rj;
        // Get world anchors
        this.getWorldAnchorA(worldAnchorA);
        this.getWorldAnchorB(worldAnchorB);
        // Get offset points
        vec2_1.default.subtract(ri, worldAnchorA, bodyA.position);
        vec2_1.default.subtract(rj, worldAnchorB, bodyB.position);
        // Compute distance vector between world anchor points
        vec2_1.default.subtract(r, worldAnchorB, worldAnchorA);
        var rlen = vec2_1.default.length(r);
        vec2_1.default.normalize(r_unit, r);
        // Compute relative velocity of the anchor points, u
        vec2_1.default.subtract(u, bodyB.velocity, bodyA.velocity);
        vec2_1.default.crossZV(tmp, bodyB.angularVelocity, rj);
        vec2_1.default.add(u, u, tmp);
        vec2_1.default.crossZV(tmp, bodyA.angularVelocity, ri);
        vec2_1.default.subtract(u, u, tmp);
        // F = - k * ( x - L ) - D * ( u )
        vec2_1.default.scale(f, r_unit, -k * (rlen - l) - d * vec2_1.default.dot(u, r_unit));
        // Add forces to bodies
        vec2_1.default.subtract(bodyA.force, bodyA.force, f);
        vec2_1.default.add(bodyB.force, bodyB.force, f);
        // Angular force
        var ri_x_f = vec2_1.default.crossLength(ri, f);
        var rj_x_f = vec2_1.default.crossLength(rj, f);
        bodyA.angularForce -= ri_x_f;
        bodyB.angularForce += rj_x_f;
    };
    return LinearSpring;
}(spring_1.default));
exports.default = LinearSpring;

},{"../math/vec2":28,"./spring":33}],32:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var spring_1 = __importDefault(_dereq_("./spring"));
var RotationalSpring = /** @class */ (function (_super) {
    __extends(RotationalSpring, _super);
    /**
     * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.
     *
     * The spring can be combined with a {{#crossLink "RevoluteConstraint"}}{{/crossLink}} to make, for example, a mouse trap.
     *
     * @class RotationalSpring
     * @extends Spring
     * @constructor
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.
     * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.
     * @param {number} [options.damping=1] A number >= 0.
     *
     * @example
     *     var spring = new RotationalSpring(bodyA, bodyB, {
     *         stiffness: 100,
     *         damping: 1
     *     });
     *     world.addSpring(spring);
     */
    function RotationalSpring(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, options) || this;
        /**
         * Rest angle of the spring.
         * @property restAngle
         * @type {number}
         */
        _this.restAngle = (_a = options === null || options === void 0 ? void 0 : options.restAngle) !== null && _a !== void 0 ? _a : bodyB.angle - bodyA.angle;
        return _this;
    }
    /**
     * Apply the spring force to the connected bodies.
     * @method applyForce
     */
    RotationalSpring.prototype.applyForce = function () {
        var k = this.stiffness, d = this.damping, l = this.restAngle, bodyA = this.bodyA, bodyB = this.bodyB, x = bodyB.angle - bodyA.angle, u = bodyB.angularVelocity - bodyA.angularVelocity;
        var torque = -k * (x - l) - d * u;
        bodyA.angularForce -= torque;
        bodyB.angularForce += torque;
    };
    ;
    return RotationalSpring;
}(spring_1.default));
exports.default = RotationalSpring;

},{"./spring":33}],33:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Spring = /** @class */ (function () {
    /**
     * Base class for {{#crossLink "LinearSpring"}}{{/crossLink}} and {{#crossLink "RotationalSpring"}}{{/crossLink}}. Not supposed to be used directly.
     *
     * @class Spring
     * @constructor
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
     * @param {number} [options.damping=1]      A number >= 0. Default: 1
     * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
     * @param {Array}  [options.localAnchorB]
     * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
     * @param {Array}  [options.worldAnchorB]
     */
    function Spring(bodyA, bodyB, options) {
        var _a, _b;
        this.stiffness = (_a = options === null || options === void 0 ? void 0 : options.stiffness) !== null && _a !== void 0 ? _a : 100;
        this.damping = (_b = options === null || options === void 0 ? void 0 : options.damping) !== null && _b !== void 0 ? _b : 1;
        this.bodyA = bodyA;
        this.bodyB = bodyB;
    }
    return Spring;
}());
exports.default = Spring;

},{}],34:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var body_1 = __importDefault(_dereq_("./body"));
var constraint_1 = __importDefault(_dereq_("../constraints/constraint"));
var friction_equation_1 = __importDefault(_dereq_("../equations/friction-equation"));
var worldVelocity = vec2_1.default.create();
var relativePoint = vec2_1.default.create();
var tmpVec = vec2_1.default.create();
var TopDownVehicle = /** @class */ (function () {
    /**
     * @class TopDownVehicle
     * @constructor
     *
     * @deprecated This class will be moved out of the core library in future versions.
     *
     * @param {Body} chassisBody A dynamic body, already added to the world.
     * @param {Object} [options]
     *
     * @example
     *
     *     // Create a dynamic body for the chassis
     *     var chassisBody = new Body({
     *         mass: 1
     *     });
     *     var boxShape = new Box({ width: 0.5, height: 1 });
     *     chassisBody.addShape(boxShape);
     *     world.addBody(chassisBody);
     *
     *     // Create the vehicle
     *     var vehicle = new TopDownVehicle(chassisBody);
     *
     *     // Add one front wheel and one back wheel - we don't actually need four :)
     *     var frontWheel = vehicle.addWheel({
     *         localPosition: [0, 0.5] // front
     *     });
     *     frontWheel.setSideFriction(4);
     *
     *     // Back wheel
     *     var backWheel = vehicle.addWheel({
     *         localPosition: [0, -0.5] // back
     *     });
     *     backWheel.setSideFriction(3); // Less side friction on back wheel makes it easier to drift
     *     vehicle.addToWorld(world);
     *
     *     // Steer value zero means straight forward. Positive is left and negative right.
     *     frontWheel.steerValue = Math.PI / 16;
     *
     *     // Engine force forward
     *     backWheel.engineForce = 10;
     *     backWheel.setBrakeForce(0);
     */
    function TopDownVehicle(chassisBody, options) {
        var _this = this;
        // A dummy body to constrain the chassis to
        this.groundBody = new body_1.default({ mass: 0 });
        this.wheels = [];
        this.chassisBody = chassisBody;
        this.preStepCallback = function () {
            _this.update();
        };
    }
    /**
     * @method addToWorld
     * @param {World} world
     */
    TopDownVehicle.prototype.addToWorld = function (world) {
        this.world = world;
        world.addBody(this.groundBody);
        world.on("preStep", this.preStepCallback, this);
        for (var i = 0; i < this.wheels.length; i++) {
            var wheel = this.wheels[i];
            world.addConstraint(wheel);
        }
    };
    ;
    /**
     * @method removeFromWorld
     * @param {World} world
     */
    TopDownVehicle.prototype.removeFromWorld = function () {
        var world = this.world;
        if (world) {
            world.removeBody(this.groundBody);
            world.off('preStep', this.preStepCallback);
            for (var i = 0; i < this.wheels.length; i++) {
                var wheel = this.wheels[i];
                world.removeConstraint(wheel);
            }
            this.world = undefined;
        }
    };
    ;
    /**
     * @method addWheel
     * @param {object} [wheelOptions]
     * @return {WheelConstraint}
     */
    TopDownVehicle.prototype.addWheel = function (wheelOptions) {
        var wheel = new WheelConstraint(this, wheelOptions);
        this.wheels.push(wheel);
        return wheel;
    };
    ;
    /**
     * @method update
     */
    TopDownVehicle.prototype.update = function () {
        for (var i = 0; i < this.wheels.length; i++) {
            this.wheels[i].update();
        }
    };
    ;
    return TopDownVehicle;
}());
exports.default = TopDownVehicle;
var WheelConstraint = /** @class */ (function (_super) {
    __extends(WheelConstraint, _super);
    /**
     * @class WheelConstraint
     * @constructor
     * @extends {Constraint}
     * @param {Vehicle} vehicle
     * @param {object} [options]
     * @param {Array} [options.localForwardVector] The local wheel forward vector in local body space. Default is zero.
     * @param {Array} [options.localPosition] The local position of the wheen in the chassis body. Default is zero - the center of the body.
     * @param {Array} [options.sideFriction=5] The max friction force in the sideways direction.
     */
    function WheelConstraint(vehicle, options) {
        var _a;
        var _this = 
        // TODO: I have no idea what kind of constraint this is supposed to be. It seems this was undefined in the original code.
        _super.call(this, vehicle.chassisBody, vehicle.groundBody, 0) || this;
        _this.steerValue = 0;
        /**
         * @property {number} engineForce
         */
        _this.engineForce = 0;
        _this.vehicle = vehicle;
        _this.forwardEquation = new friction_equation_1.default(vehicle.chassisBody, vehicle.groundBody);
        _this.sideEquation = new friction_equation_1.default(vehicle.chassisBody, vehicle.groundBody);
        _this.setSideFriction((_a = options === null || options === void 0 ? void 0 : options.sideFriction) !== null && _a !== void 0 ? _a : 5);
        /**
         * @property {Array} localForwardVector
         */
        _this.localForwardVector = vec2_1.default.fromValues(0, 1);
        if (options === null || options === void 0 ? void 0 : options.localForwardVector) {
            vec2_1.default.copy(_this.localForwardVector, options.localForwardVector);
        }
        /**
         * @property {Array} localPosition
         */
        _this.localPosition = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.localPosition) {
            vec2_1.default.copy(_this.localPosition, options.localPosition);
        }
        _this.equations.push(_this.forwardEquation);
        _this.equations.push(_this.sideEquation);
        _this.setBrakeForce(0);
        return _this;
    }
    /**
     * @method setBrakeForce
     */
    WheelConstraint.prototype.setBrakeForce = function (force) {
        this.forwardEquation.setSlipForce(force);
    };
    /**
     * @method setSideFriction
     */
    WheelConstraint.prototype.setSideFriction = function (force) {
        this.sideEquation.setSlipForce(force);
    };
    /**
     * @method getSpeed
     */
    WheelConstraint.prototype.getSpeed = function () {
        var body = this.vehicle.chassisBody;
        body.vectorToWorldFrame(relativePoint, this.localForwardVector);
        body.getVelocityAtPoint(worldVelocity, relativePoint);
        return vec2_1.default.dot(worldVelocity, relativePoint);
    };
    /**
     * @method update
     */
    WheelConstraint.prototype.update = function () {
        var body = this.vehicle.chassisBody;
        var forwardEquation = this.forwardEquation;
        var sideEquation = this.sideEquation;
        var steerValue = this.steerValue;
        // Directional
        body.vectorToWorldFrame(forwardEquation.t, this.localForwardVector);
        vec2_1.default.rotate(sideEquation.t, this.localForwardVector, Math.PI / 2);
        body.vectorToWorldFrame(sideEquation.t, sideEquation.t);
        vec2_1.default.rotate(forwardEquation.t, forwardEquation.t, steerValue);
        vec2_1.default.rotate(sideEquation.t, sideEquation.t, steerValue);
        // Attachment point
        body.toWorldFrame(forwardEquation.contactPointB, this.localPosition);
        vec2_1.default.copy(sideEquation.contactPointB, forwardEquation.contactPointB);
        body.vectorToWorldFrame(forwardEquation.contactPointA, this.localPosition);
        vec2_1.default.copy(sideEquation.contactPointA, forwardEquation.contactPointA);
        // Add engine force
        vec2_1.default.normalize(tmpVec, forwardEquation.t);
        vec2_1.default.scale(tmpVec, tmpVec, this.engineForce);
        this.vehicle.chassisBody.applyForce(tmpVec, forwardEquation.contactPointA);
    };
    return WheelConstraint;
}(constraint_1.default));

},{"../constraints/constraint":8,"../equations/friction-equation":18,"../math/vec2":28,"./body":30}],35:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var vec2 = require('../math/vec2')
// ,   Shape = require('./Shape')
// ,   shallowClone = require('../utils/Utils').shallowClone
// ,   Convex = require('./Convex');
var Convex_1 = __importDefault(_dereq_("./Convex"));
var shape_1 = __importDefault(_dereq_("./shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Box = /** @class */ (function (_super) {
    __extends(Box, _super);
    /**
     * Box shape class.
     * @class Box
     * @constructor
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {Number} [options.width=1] Total width of the box
     * @param {Number} [options.height=1] Total height of the box
     * @extends Convex
     * @example
     *     var body = new Body({ mass: 1 });
     *     var boxShape = new Box({
     *         width: 2,
     *         height: 1
     *     });
     *     body.addShape(boxShape);
     */
    function Box(options) {
        var _a, _b;
        var _this = this;
        var width = (_a = options === null || options === void 0 ? void 0 : options.width) !== null && _a !== void 0 ? _a : 1;
        var height = (_b = options === null || options === void 0 ? void 0 : options.height) !== null && _b !== void 0 ? _b : 1;
        var hw = width / 2;
        var hh = height / 2;
        _this = _super.call(this, shape_1.default.BOX, [
            vec2_1.default.fromValues(-hw, -hh),
            vec2_1.default.fromValues(hw, -hh),
            vec2_1.default.fromValues(hw, hh),
            vec2_1.default.fromValues(-hw, hh)
        ], options) || this;
        _this.height = height;
        _this.width = width;
        return _this;
    }
    /**
     * Compute moment of inertia
     * @method computeMomentOfInertia
     * @return {Number}
     */
    Box.prototype.computeMomentOfInertia = function () {
        var w = this.width, h = this.height;
        return (h * h + w * w) / 12;
    };
    ;
    /**
     * Update the bounding radius
     * @method updateBoundingRadius
     */
    Box.prototype.updateBoundingRadius = function () {
        var w = this.width, h = this.height;
        this.boundingRadius = Math.sqrt(w * w + h * h) / 2;
        return this.boundingRadius;
    };
    ;
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Box.prototype.computeAABB = function (out, position, angle) {
        var c = Math.abs(Math.cos(angle)), s = Math.abs(Math.sin(angle)), w = this.width, h = this.height;
        var height = (w * s + h * c) * 0.5;
        var width = (h * s + w * c) * 0.5;
        var l = out.lowerBound;
        var u = out.upperBound;
        var px = position[0];
        var py = position[1];
        l[0] = px - width;
        l[1] = py - height;
        u[0] = px + width;
        u[1] = py + height;
    };
    ;
    Box.prototype.updateArea = function () {
        this.area = this.width * this.height;
        return this.area;
    };
    ;
    Box.prototype.pointTest = function (localPoint) {
        return Math.abs(localPoint[0]) <= this.width * 0.5 && Math.abs(localPoint[1]) <= this.height * 0.5;
    };
    ;
    return Box;
}(Convex_1.default));
exports.default = Box;

},{"../math/vec2":28,"./Convex":37,"./shape":46}],36:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,    vec2 = require('../math/vec2')
// ,    shallowClone = require('../utils/Utils').shallowClone;
var Shape_1 = __importDefault(_dereq_("./Shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Ray_intersectSphere_intersectionPoint = vec2_1.default.create();
var Ray_intersectSphere_normal = vec2_1.default.create();
var Circle = /** @class */ (function (_super) {
    __extends(Circle, _super);
    /**
     * Circle shape class.
     * @class Circle
     * @extends Shape
     * @constructor
     * @param {options} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {number} [options.radius=1] The radius of this circle
     *
     * @example
     *     var body = new Body({ mass: 1 });
     *     var circleShape = new Circle({
     *         radius: 1
     *     });
     *     body.addShape(circleShape);
     */
    function Circle(options) {
        var _a;
        var _this = _super.call(this, Shape_1.default.CIRCLE, options) || this;
        /**
         * The radius of the circle.
         * @property radius
         * @type {number}
         */
        _this.radius = (_a = options === null || options === void 0 ? void 0 : options.radius) !== null && _a !== void 0 ? _a : 1;
        return _this;
    }
    /**
     * @method computeMomentOfInertia
     * @return {Number}
     */
    Circle.prototype.computeMomentOfInertia = function () {
        var r = this.radius;
        return r * r / 2;
    };
    /**
     * @method updateBoundingRadius
     * @return {Number}
     */
    Circle.prototype.updateBoundingRadius = function () {
        this.boundingRadius = this.radius;
        return this.boundingRadius;
    };
    /**
     * @method updateArea
     * @return {Number}
     */
    Circle.prototype.updateArea = function () {
        this.area = Math.PI * this.radius * this.radius;
        return this.area;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Circle.prototype.computeAABB = function (out, position /*, angle: f32*/) {
        var r = this.radius;
        vec2_1.default.set(out.upperBound, r, r);
        vec2_1.default.set(out.lowerBound, -r, -r);
        if (position) {
            vec2_1.default.add(out.lowerBound, out.lowerBound, position);
            vec2_1.default.add(out.upperBound, out.upperBound, position);
        }
    };
    /**
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Circle.prototype.raycast = function (result, ray, position /*, angle: f32*/) {
        var from = ray.from, to = ray.to, r = this.radius;
        var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
        var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
        var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);
        var delta = Math.pow(b, 2) - 4 * a * c;
        var intersectionPoint = Ray_intersectSphere_intersectionPoint;
        var normal = Ray_intersectSphere_normal;
        if (delta < 0) {
            // No intersection
            return;
        }
        else if (delta === 0) {
            // single intersection point
            vec2_1.default.lerp(intersectionPoint, from, to, delta);
            vec2_1.default.subtract(normal, intersectionPoint, position);
            vec2_1.default.normalize(normal, normal);
            ray.reportIntersection(result, delta, normal, -1);
        }
        else {
            var sqrtDelta = Math.sqrt(delta);
            var inv2a = 1 / (2 * a);
            var d1 = (-b - sqrtDelta) * inv2a;
            var d2 = (-b + sqrtDelta) * inv2a;
            if (d1 >= 0 && d1 <= 1) {
                vec2_1.default.lerp(intersectionPoint, from, to, d1);
                vec2_1.default.subtract(normal, intersectionPoint, position);
                vec2_1.default.normalize(normal, normal);
                ray.reportIntersection(result, d1, normal, -1);
                if (result.shouldStop(ray)) {
                    return;
                }
            }
            if (d2 >= 0 && d2 <= 1) {
                vec2_1.default.lerp(intersectionPoint, from, to, d2);
                vec2_1.default.subtract(normal, intersectionPoint, position);
                vec2_1.default.normalize(normal, normal);
                ray.reportIntersection(result, d2, normal, -1);
            }
        }
    };
    Circle.prototype.pointTest = function (localPoint) {
        var radius = this.radius;
        return vec2_1.default.squaredLength(localPoint) <= radius * radius;
    };
    return Circle;
}(Shape_1.default));
exports.default = Circle;

},{"../math/vec2":28,"./Shape":38}],37:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Shape_1 = __importDefault(_dereq_("./Shape"));
var polyk_1 = __importDefault(_dereq_("../math/polyk"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var dot = vec2_1.default.dot;
var updateCenterOfMass_centroid = vec2_1.default.create(), updateCenterOfMass_centroid_times_mass = vec2_1.default.create(), updateCenterOfMass_a = vec2_1.default.create(), updateCenterOfMass_b = vec2_1.default.create(), updateCenterOfMass_c = vec2_1.default.create();
var tmpVec1 = vec2_1.default.create();
var intersectConvex_rayStart = vec2_1.default.create();
var intersectConvex_rayEnd = vec2_1.default.create();
var intersectConvex_normal = vec2_1.default.create();
var pic_r0 = vec2_1.default.create();
var pic_r1 = vec2_1.default.create();
var tmpVec2 = vec2_1.default.create();
var worldAxis = tmpVec2;
var Convex = /** @class */ (function (_super) {
    __extends(Convex, _super);
    /**
     * Convex shape class.
     * @class Convex
     * @constructor
     * @extends Shape
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {Array} [options.vertices] An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];
     *     var convexShape = new Convex({
     *         vertices: vertices
     *     });
     *     body.addShape(convexShape);
     */
    function Convex(type, vertices, options) {
        var _this = _super.call(this, type !== null && type !== void 0 ? type : Shape_1.default.CONVEX, options) || this;
        // Copy the verts
        _this.vertices = [];
        var newVertices = vertices !== null && vertices !== void 0 ? vertices : [];
        _this.vertices = [];
        _this.normals = [];
        for (var i = 0; i < newVertices.length; i++) {
            _this.vertices.push(vec2_1.default.clone(newVertices[i]));
            _this.normals.push(vec2_1.default.create());
        }
        _this.updateNormals();
        _this.centerOfMass = vec2_1.default.create();
        _this.triangles = [];
        if (_this.vertices.length) {
            _this.updateTriangles();
            _this.updateCenterOfMass();
        }
        /**
         * The bounding radius of the convex
         * @property boundingRadius
         * @type {Number}
         */
        _this.boundingRadius = 0;
        _this.updateBoundingRadius();
        _this.updateArea();
        if (_this.area < 0) {
            throw new Error("Convex vertices must be given in counter-clockwise winding.");
        }
        return _this;
    }
    Convex.prototype.updateNormals = function () {
        var vertices = this.vertices;
        var normals = this.normals;
        for (var i = 0; i < vertices.length; i++) {
            var worldPoint0 = vertices[i];
            var worldPoint1 = vertices[(i + 1) % vertices.length];
            var normal = normals[i];
            vec2_1.default.subtract(normal, worldPoint1, worldPoint0);
            // Get normal - just rotate 90 degrees since vertices are given in CCW
            vec2_1.default.rotate90cw(normal, normal);
            vec2_1.default.normalize(normal, normal);
        }
    };
    /**
     * Project a Convex onto a world-oriented axis
     * @method projectOntoAxis
     * @static
     * @param  {Array} offset
     * @param  {Array} localAxis
     * @param  {Array} result
     */
    Convex.prototype.projectOntoLocalAxis = function (localAxis, result) {
        var max = -Infinity, min = Infinity, v, value, localAxis = tmpVec1;
        // Get projected position of all vertices
        for (var i = 0; i < this.vertices.length; i++) {
            v = this.vertices[i];
            value = dot(v, localAxis);
            if (value > max) {
                max = value;
            }
            if (value < min) {
                min = value;
            }
        }
        if (min > max) {
            var t = min;
            min = max;
            max = t;
        }
        vec2_1.default.set(result, min, max);
    };
    Convex.prototype.ConvexprojectOntoWorldAxis = function (localAxis, shapeOffset, shapeAngle, result) {
        this.projectOntoLocalAxis(localAxis, result);
        // Project the position of the body onto the axis - need to add this to the result
        if (shapeAngle !== 0) {
            vec2_1.default.rotate(worldAxis, localAxis, shapeAngle);
        }
        else {
            worldAxis = localAxis;
        }
        var offset = dot(shapeOffset, worldAxis);
        vec2_1.default.set(result, result[0] + offset, result[1] + offset);
    };
    /**
     * Update the .triangles property
     * @method updateTriangles
     */
    Convex.prototype.updateTriangles = function () {
        this.triangles.length = 0;
        // Rewrite on polyk notation, array of numbers
        var polykVerts = [];
        for (var i = 0; i < this.vertices.length; i++) {
            var v = this.vertices[i];
            polykVerts.push(v[0]);
            polykVerts.push(v[1]);
        }
        // Triangulate
        var triangles = polyk_1.default.Triangulate(polykVerts);
        // Loop over all triangles, add their inertia contributions to I
        for (var i = 0; i < triangles.length; i += 3) {
            var id1 = triangles[i], id2 = triangles[i + 1], id3 = triangles[i + 2];
            // Add to triangles
            var T = new Float32Array(3);
            T[0] = id1;
            T[1] = id2;
            T[2] = id3;
            this.triangles.push(T);
        }
    };
    /**
     * Update the .centerOfMass property.
     * @method updateCenterOfMass
     */
    Convex.prototype.updateCenterOfMass = function () {
        var triangles = this.triangles, verts = this.vertices, cm = this.centerOfMass, centroid = updateCenterOfMass_centroid, a = updateCenterOfMass_a, b = updateCenterOfMass_b, c = updateCenterOfMass_c, centroid_times_mass = updateCenterOfMass_centroid_times_mass;
        vec2_1.default.set(cm, 0, 0);
        var totalArea = 0;
        for (var i = 0; i !== triangles.length; i++) {
            var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
            vec2_1.default.centroid(centroid, a, b, c);
            // Get mass for the triangle (density=1 in this case)
            // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors
            var m = Convex.triangleArea(a, b, c);
            totalArea += m;
            // Add to center of mass
            vec2_1.default.scale(centroid_times_mass, centroid, m);
            vec2_1.default.add(cm, cm, centroid_times_mass);
        }
        vec2_1.default.scale(cm, cm, 1 / totalArea);
    };
    /**
     * Compute the moment of inertia of the Convex.
     * @method computeMomentOfInertia
     * @return {Number}
     * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/
     */
    Convex.prototype.computeMomentOfInertia = function () {
        var denom = 0.0, numer = 0.0, N = this.vertices.length;
        for (var j = N - 1, i = 0; i < N; j = i, i++) {
            var p0 = this.vertices[j];
            var p1 = this.vertices[i];
            var a = Math.abs(vec2_1.default.crossLength(p0, p1));
            var b = dot(p1, p1) + dot(p1, p0) + dot(p0, p0);
            denom += a * b;
            numer += a;
        }
        return (1.0 / 6.0) * (denom / numer);
    };
    /**
     * Updates the .boundingRadius property
     * @method updateBoundingRadius
     */
    Convex.prototype.updateBoundingRadius = function () {
        var verts = this.vertices, r2 = 0;
        if (!verts)
            return 0;
        for (var i = 0; i !== verts.length; i++) {
            var l2 = vec2_1.default.squaredLength(verts[i]);
            if (l2 > r2) {
                r2 = l2;
            }
        }
        this.boundingRadius = Math.sqrt(r2);
        return this.boundingRadius;
    };
    /**
     * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.
     * @static
     * @method triangleArea
     * @param {Array} a
     * @param {Array} b
     * @param {Array} c
     * @return {Number}
     * @deprecated
     */
    Convex.triangleArea = function (a, b, c) {
        return (((b[0] - a[0]) * (c[1] - a[1])) - ((c[0] - a[0]) * (b[1] - a[1]))) * 0.5;
    };
    /**
     * Update the .area
     * @method updateArea
     */
    Convex.prototype.updateArea = function () {
        if (!this.vertices)
            return 0;
        this.updateTriangles();
        this.area = 0;
        var triangles = this.triangles, verts = this.vertices;
        for (var i = 0; i !== triangles.length; i++) {
            var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
            // Get mass for the triangle (density=1 in this case)
            var m = Convex.triangleArea(a, b, c);
            this.area += m;
        }
        return this.area;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out
     * @param  {Array}  position
     * @param  {Number} angle
     * @todo: approximate with a local AABB?
     */
    Convex.prototype.computeAABB = function (out, position, angle) {
        out.setFromPoints(this.vertices, position, angle, 0);
    };
    /**
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Convex.prototype.raycast = function (result, ray, position, angle) {
        var rayStart = intersectConvex_rayStart;
        var rayEnd = intersectConvex_rayEnd;
        var normal = intersectConvex_normal;
        var vertices = this.vertices;
        // Transform to local shape space
        vec2_1.default.toLocalFrame(rayStart, ray.from, position, angle);
        vec2_1.default.toLocalFrame(rayEnd, ray.to, position, angle);
        var n = vertices.length;
        for (var i = 0; i < n && !result.shouldStop(ray); i++) {
            var q1 = vertices[i];
            var q2 = vertices[(i + 1) % n];
            var delta = vec2_1.default.getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);
            if (delta >= 0) {
                vec2_1.default.subtract(normal, q2, q1);
                vec2_1.default.rotate(normal, normal, -Math.PI / 2 + angle);
                vec2_1.default.normalize(normal, normal);
                ray.reportIntersection(result, delta, normal, i);
            }
        }
    };
    Convex.prototype.pointTest = function (localPoint) {
        var r0 = pic_r0, r1 = pic_r1, verts = this.vertices, lastCross = null, numVerts = verts.length;
        for (var i = 0; i < numVerts + 1; i++) {
            var v0 = verts[i % numVerts], v1 = verts[(i + 1) % numVerts];
            vec2_1.default.subtract(r0, v0, localPoint);
            vec2_1.default.subtract(r1, v1, localPoint);
            var cross = vec2_1.default.crossLength(r0, r1);
            if (lastCross === null) {
                lastCross = cross;
            }
            // If we got a different sign of the distance vector, the point is out of the polygon
            if (cross * lastCross < 0) {
                return false;
            }
            lastCross = cross;
        }
        return true;
    };
    return Convex;
}(Shape_1.default));
exports.default = Convex;

},{"../math/polyk":27,"../math/vec2":28,"./Shape":38}],38:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Shape = /** @class */ (function () {
    /**
     * Base class for shapes. Not to be used directly.
     * @class Shape
     * @constructor
     * @param {object} [options]
     * @param {number} [options.angle=0]
     * @param {number} [options.collisionGroup=1]
     * @param {number} [options.collisionMask=1]
     * @param {number} [options.id] Optional - specify an ID for this shape. Possibly useful for replacing shapes. Careful to avoid duplicates!
     * @param {boolean} [options.collisionResponse=true]
     * @param {Material} [options.material=null]
     * @param {array} [options.position]
     * @param {boolean} [options.sensor=false]
     * @param {object} [options.type=0]
     */
    function Shape(type, options) {
        var _a, _b, _c, _d, _e, _f;
        /**
         * Body-local position of the shape.
         * @property {Array} position
         */
        this.position = vec2_1.default.create();
        /**
         * Body-local angle of the shape.
         * @property {number} angle
         */
        this.angle = 0;
        /**
         * The type of the shape. One of:
         *
         * <ul>
         * <li><a href="Shape.html#property_CIRCLE">Shape.CIRCLE</a></li>
         * <li><a href="Shape.html#property_PARTICLE">Shape.PARTICLE</a></li>
         * <li><a href="Shape.html#property_PLANE">Shape.PLANE</a></li>
         * <li><a href="Shape.html#property_CONVEX">Shape.CONVEX</a></li>
         * <li><a href="Shape.html#property_LINE">Shape.LINE</a></li>
         * <li><a href="Shape.html#property_BOX">Shape.BOX</a></li>
         * <li><a href="Shape.html#property_CAPSULE">Shape.CAPSULE</a></li>
         * <li><a href="Shape.html#property_HEIGHTFIELD">Shape.HEIGHTFIELD</a></li>
         * </ul>
         *
         * @property {number} type
         */
        this.type = 0;
        /**
         * Shape object identifier. Read only.
         * @readonly
         * @type {Number}
         * @property id
         */
        this.id = 0;
        /**
         * Bounding circle radius of this shape
         * @readonly
         * @property boundingRadius
         * @type {Number}
         */
        this.boundingRadius = 0;
        /**
         * Collision group that this shape belongs to (bit mask). See <a href="http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/">this tutorial</a>.
         * @property collisionGroup
         * @type {Number}
         * @example
         *     // Setup bits for each available group
         *     var PLAYER = Math.pow(2,0),
         *         ENEMY =  Math.pow(2,1),
         *         GROUND = Math.pow(2,2)
         *
         *     // Put shapes into their groups
         *     player1Shape.collisionGroup = PLAYER;
         *     player2Shape.collisionGroup = PLAYER;
         *     enemyShape  .collisionGroup = ENEMY;
         *     groundShape .collisionGroup = GROUND;
         *
         *     // Assign groups that each shape collide with.
         *     // Note that the players can collide with ground and enemies, but not with other players.
         *     player1Shape.collisionMask = ENEMY | GROUND;
         *     player2Shape.collisionMask = ENEMY | GROUND;
         *     enemyShape  .collisionMask = PLAYER | GROUND;
         *     groundShape .collisionMask = PLAYER | ENEMY;
         *
         * @example
         *     // How collision check is done
         *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){
         *         // The shapes will collide
         *     }
         */
        this.collisionGroup = 1;
        /**
         * Area of this shape.
         * @property area
         * @type {Number}
         */
        this.area = 0;
        if (options === null || options === void 0 ? void 0 : options.position) {
            vec2_1.default.copy(this.position, options.position);
        }
        this.angle = (_a = options === null || options === void 0 ? void 0 : options.angle) !== null && _a !== void 0 ? _a : 0;
        this.type = type;
        this.id = (_b = options === null || options === void 0 ? void 0 : options.id) !== null && _b !== void 0 ? _b : ++Shape.idCounter;
        this.collisionGroup = (_c = options === null || options === void 0 ? void 0 : options.collisionGroup) !== null && _c !== void 0 ? _c : 1;
        this.collisionResponse = (_d = options === null || options === void 0 ? void 0 : options.collisionResponse) !== null && _d !== void 0 ? _d : true;
        this.collisionMask = (_e = options === null || options === void 0 ? void 0 : options.collisionMask) !== null && _e !== void 0 ? _e : 1;
        this.material = options === null || options === void 0 ? void 0 : options.material;
        this.sensor = (_f = options === null || options === void 0 ? void 0 : options.sensor) !== null && _f !== void 0 ? _f : false;
        if (this.type) {
            this.updateBoundingRadius();
        }
        this.updateArea();
    }
    /**
     * Test if a point is inside this shape.
     * @method pointTest
     * @param {array} localPoint
     * @return {boolean}
     */
    Shape.prototype.pointTest = function (localPoint) { return false; };
    /**
     * Transform a world point to local shape space (assumed the shape is transformed by both itself and the body).
     * @method worldPointToLocal
     * @param {array} out
     * @param {array} worldPoint
     */
    Shape.prototype.worldPointToLocal = function (out, worldPoint) {
        var shapeWorldPosition = vec2_1.default.create();
        var body = this.body;
        if (!body)
            return;
        vec2_1.default.rotate(shapeWorldPosition, this.position, body.angle);
        vec2_1.default.add(shapeWorldPosition, shapeWorldPosition, body.position);
        vec2_1.default.toLocalFrame(out, worldPoint, shapeWorldPosition, body.angle + this.angle);
    };
    Shape.idCounter = 0;
    /**
     * @static
     * @property {Number} CIRCLE
     */
    Shape.CIRCLE = 1;
    /**
     * @static
     * @property {Number} PARTICLE
     */
    Shape.PARTICLE = 2;
    /**
     * @static
     * @property {Number} PLANE
     */
    Shape.PLANE = 4;
    /**
     * @static
     * @property {Number} CONVEX
     */
    Shape.CONVEX = 8;
    /**
     * @static
     * @property {Number} LINE
     */
    Shape.LINE = 16;
    /**
     * @static
     * @property {Number} BOX
     */
    Shape.BOX = 32;
    /**
     * @static
     * @property {Number} CAPSULE
     */
    Shape.CAPSULE = 64;
    /**
     * @static
     * @property {Number} HEIGHTFIELD
     */
    Shape.HEIGHTFIELD = 128;
    return Shape;
}());
exports.default = Shape;

},{"../math/vec2":28}],39:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,   shallowClone = require('../utils/Utils').shallowClone
// ,   vec2 = require('../math/vec2');
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var utils_1 = __importDefault(_dereq_("../utils/utils"));
var shape_1 = __importDefault(_dereq_("./shape"));
var shallowClone = utils_1.default.shallowClone;
function boxI(w, h) {
    return w * h * (Math.pow(w, 2) + Math.pow(h, 2)) / 12;
}
function semiA(r) {
    return Math.PI * Math.pow(r, 2) / 2;
}
// http://www.efunda.com/math/areas/CircleHalf.cfm
function semiI(r) {
    return ((Math.PI / 4) - (8 / (9 * Math.PI))) * Math.pow(r, 4);
}
function semiC(r) {
    return (4 * r) / (3 * Math.PI);
}
// https://en.wikipedia.org/wiki/Second_moment_of_area#Parallel_axis_theorem
function capsuleA(l, r) {
    return l * 2 * r + Math.PI * Math.pow(r, 2);
}
function capsuleI(l, r) {
    var d = l / 2 + semiC(r);
    return boxI(l, 2 * r) + 2 * (semiI(r) + semiA(r) * Math.pow(d, 2));
}
var intersectCapsule_hitPointWorld = vec2_1.default.create();
var intersectCapsule_normal = vec2_1.default.create();
var intersectCapsule_l0 = vec2_1.default.create();
var intersectCapsule_l1 = vec2_1.default.create();
var intersectCapsule_unit_y = vec2_1.default.fromValues(0, 1);
var Capsule = /** @class */ (function (_super) {
    __extends(Capsule, _super);
    /**
     * Capsule shape.
     * @class Capsule
     * @constructor
     * @extends Shape
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {Number} [options.length=1] The distance between the end points, extends along the X axis.
     * @param {Number} [options.radius=1] Radius of the capsule.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var capsuleShape = new Capsule({
     *         length: 1,
     *         radius: 2
     *     });
     *     body.addShape(capsuleShape);
     */
    function Capsule(options) {
        var _a, _b;
        var _this = _super.call(this, shape_1.default.CAPSULE, options) || this;
        _this.length = (_a = options === null || options === void 0 ? void 0 : options.length) !== null && _a !== void 0 ? _a : 1;
        _this.radius = (_b = options === null || options === void 0 ? void 0 : options.radius) !== null && _b !== void 0 ? _b : 1;
        return _this;
    }
    /**
     * Compute the mass moment of inertia of the Capsule.
     * @method conputeMomentOfInertia
     * @return {Number}
     * @todo
     */
    Capsule.prototype.computeMomentOfInertia = function () {
        // http://www.efunda.com/math/areas/rectangle.cfm
        var r = this.radius, l = this.length, area = capsuleA(l, r);
        return (area > 0) ? capsuleI(l, r) / area : 0;
    };
    /**
     * @method updateBoundingRadius
     */
    Capsule.prototype.updateBoundingRadius = function () {
        this.boundingRadius = this.radius + this.length / 2;
        return this.boundingRadius;
    };
    /**
     * @method updateArea
     */
    Capsule.prototype.updateArea = function () {
        this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
        return this.area;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Capsule.prototype.computeAABB = function (out, position, angle) {
        var r = vec2_1.default.create();
        var radius = this.radius;
        // Compute center position of one of the the circles, world oriented, but with local offset
        vec2_1.default.set(r, this.length / 2, 0);
        if (angle !== 0) {
            vec2_1.default.rotate(r, r, angle);
        }
        // Get bounds
        vec2_1.default.set(out.upperBound, Math.max(r[0] + radius, -r[0] + radius), Math.max(r[1] + radius, -r[1] + radius));
        vec2_1.default.set(out.lowerBound, Math.min(r[0] - radius, -r[0] - radius), Math.min(r[1] - radius, -r[1] - radius));
        // Add offset
        vec2_1.default.add(out.lowerBound, out.lowerBound, position);
        vec2_1.default.add(out.upperBound, out.upperBound, position);
    };
    /**
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Capsule.prototype.raycast = function (result, ray, position, angle) {
        var from = ray.from;
        var to = ray.to;
        var hitPointWorld = intersectCapsule_hitPointWorld;
        var normal = intersectCapsule_normal;
        var l0 = intersectCapsule_l0;
        var l1 = intersectCapsule_l1;
        // The sides
        var halfLen = this.length / 2;
        for (var i = 0; i < 2; i++) {
            // get start and end of the line
            var y = this.radius * (i * 2 - 1);
            vec2_1.default.set(l0, -halfLen, y);
            vec2_1.default.set(l1, halfLen, y);
            vec2_1.default.toGlobalFrame(l0, l0, position, angle);
            vec2_1.default.toGlobalFrame(l1, l1, position, angle);
            var delta = vec2_1.default.getLineSegmentsIntersectionFraction(from, to, l0, l1);
            if (delta >= 0) {
                vec2_1.default.rotate(normal, intersectCapsule_unit_y, angle);
                vec2_1.default.scale(normal, normal, (i * 2 - 1));
                ray.reportIntersection(result, delta, normal, -1);
                if (result.shouldStop(ray)) {
                    return;
                }
            }
        }
        // Circles
        var diagonalLengthSquared = Math.pow(this.radius, 2) + Math.pow(halfLen, 2);
        for (var i = 0; i < 2; i++) {
            vec2_1.default.set(l0, halfLen * (i * 2 - 1), 0);
            vec2_1.default.toGlobalFrame(l0, l0, position, angle);
            var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
            var b = 2 * ((to[0] - from[0]) * (from[0] - l0[0]) + (to[1] - from[1]) * (from[1] - l0[1]));
            var c = Math.pow(from[0] - l0[0], 2) + Math.pow(from[1] - l0[1], 2) - Math.pow(this.radius, 2);
            var delta = Math.pow(b, 2) - 4 * a * c;
            if (delta < 0) {
                // No intersection
                continue;
            }
            else if (delta === 0) {
                // single intersection point
                vec2_1.default.lerp(hitPointWorld, from, to, delta);
                if (vec2_1.default.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                    vec2_1.default.subtract(normal, hitPointWorld, l0);
                    vec2_1.default.normalize(normal, normal);
                    ray.reportIntersection(result, delta, normal, -1);
                    if (result.shouldStop(ray)) {
                        return;
                    }
                }
            }
            else {
                var sqrtDelta = Math.sqrt(delta);
                var inv2a = 1 / (2 * a);
                var d1 = (-b - sqrtDelta) * inv2a;
                var d2 = (-b + sqrtDelta) * inv2a;
                if (d1 >= 0 && d1 <= 1) {
                    vec2_1.default.lerp(hitPointWorld, from, to, d1);
                    if (vec2_1.default.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                        vec2_1.default.subtract(normal, hitPointWorld, l0);
                        vec2_1.default.normalize(normal, normal);
                        ray.reportIntersection(result, d1, normal, -1);
                        if (result.shouldStop(ray)) {
                            return;
                        }
                    }
                }
                if (d2 >= 0 && d2 <= 1) {
                    vec2_1.default.lerp(hitPointWorld, from, to, d2);
                    if (vec2_1.default.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                        vec2_1.default.subtract(normal, hitPointWorld, l0);
                        vec2_1.default.normalize(normal, normal);
                        ray.reportIntersection(result, d2, normal, -1);
                        if (result.shouldStop(ray)) {
                            return;
                        }
                    }
                }
            }
        }
    };
    Capsule.prototype.pointTest = function (localPoint) {
        var radius = this.radius;
        var halfLength = this.length * 0.5;
        if ((Math.abs(localPoint[0]) <= halfLength && Math.abs(localPoint[1]) <= radius)) {
            return true;
        }
        if (Math.pow(localPoint[0] - halfLength, 2) + Math.pow(localPoint[1], 2) <= radius * radius) {
            return true;
        }
        if (Math.pow(localPoint[0] + halfLength, 2) + Math.pow(localPoint[1], 2) <= radius * radius) {
            return true;
        }
        return false;
    };
    return Capsule;
}(shape_1.default));
exports.default = Capsule;

},{"../math/vec2":28,"../utils/utils":56,"./shape":46}],40:[function(_dereq_,module,exports){
module.exports=_dereq_(36)
},{"../math/vec2":28,"./Shape":38}],41:[function(_dereq_,module,exports){
module.exports=_dereq_(37)
},{"../math/polyk":27,"../math/vec2":28,"./Shape":38}],42:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,    vec2 = require('../math/vec2')
// ,    shallowClone = require('../utils/Utils').shallowClone;
var Shape_1 = __importDefault(_dereq_("./Shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var intersectHeightfield_worldNormal = vec2_1.default.create();
var intersectHeightfield_l0 = vec2_1.default.create();
var intersectHeightfield_l1 = vec2_1.default.create();
var intersectHeightfield_localFrom = vec2_1.default.create();
var intersectHeightfield_localTo = vec2_1.default.create();
var Heightfield = /** @class */ (function (_super) {
    __extends(Heightfield, _super);
    /**
     * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance "elementWidth".
     * @class Heightfield
     * @extends Shape
     * @constructor
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {array} [options.heights] An array of Y values that will be used to construct the terrain.
     * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
     * @param {Number} [options.maxValue] Maximum value.
     * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.
     *
     * @example
     *     // Generate some height data (y-values).
     *     var heights = [];
     *     for(var i = 0; i < 1000; i++){
     *         var y = 0.5 * Math.cos(0.2 * i);
     *         heights.push(y);
     *     }
     *
     *     // Create the heightfield shape
     *     var shape = new Heightfield({
     *         heights: heights,
     *         elementWidth: 1 // Distance between the data points in X direction
     *     });
     *     var body = new Body();
     *     body.addShape(shape);
     *     world.addBody(body);
     *
     * @todo Should use a scale property with X and Y direction instead of just elementWidth
     */
    function Heightfield(options) {
        var _a;
        var _this = _super.call(this, Shape_1.default.HEIGHTFIELD, options) || this;
        /**
         * An array of numbers, or height values, that are spread out along the x axis.
         * @property {array} heights
         */
        _this.heights = [];
        /**
         * Max value of the heights
         * @property {number} maxValue
         */
        _this.maxValue = 0;
        /**
         * Max value of the heights
         * @property {number} minValue
         */
        _this.minValue = 0;
        /**
         * The width of each element
         * @property {number} elementWidth
         */
        _this.elementWidth = 0;
        _this.heights = (options === null || options === void 0 ? void 0 : options.heights) ? options.heights.slice(0) : [];
        _this.elementWidth = (_a = options === null || options === void 0 ? void 0 : options.elementWidth) !== null && _a !== void 0 ? _a : 0.1;
        if ((options === null || options === void 0 ? void 0 : options.maxValue) && (options === null || options === void 0 ? void 0 : options.minValue)) {
            _this.maxValue = options === null || options === void 0 ? void 0 : options.maxValue;
            _this.minValue = options === null || options === void 0 ? void 0 : options.minValue;
        }
        else
            _this.updateMaxMinValues();
        return _this;
    }
    /**
     * Update the .minValue and the .maxValue
     * @method updateMaxMinValues
     */
    Heightfield.prototype.updateMaxMinValues = function () {
        var data = this.heights;
        var maxValue = data[0];
        var minValue = data[0];
        for (var i = 0; i !== data.length; i++) {
            var v = data[i];
            if (v > maxValue) {
                maxValue = v;
            }
            if (v < minValue) {
                minValue = v;
            }
        }
        this.maxValue = maxValue;
        this.minValue = minValue;
    };
    /**
     * @method computeMomentOfInertia
     * @return {Number}
     */
    Heightfield.prototype.computeMomentOfInertia = function () {
        return Infinity;
    };
    Heightfield.prototype.updateBoundingRadius = function () {
        this.boundingRadius = Infinity;
        return this.boundingRadius;
    };
    Heightfield.prototype.updateArea = function () {
        var data = this.heights, area = 0;
        for (var i = 0; i < data.length - 1; i++) {
            area += (data[i] + data[i + 1]) / 2 * this.elementWidth;
        }
        this.area = area;
        return this.area;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Heightfield.prototype.computeAABB = function (out, position, angle) {
        var points = [
            vec2_1.default.create(),
            vec2_1.default.create(),
            vec2_1.default.create(),
            vec2_1.default.create()
        ];
        vec2_1.default.set(points[0], 0, this.maxValue);
        vec2_1.default.set(points[1], this.elementWidth * this.heights.length, this.maxValue);
        vec2_1.default.set(points[2], this.elementWidth * this.heights.length, this.minValue);
        vec2_1.default.set(points[3], 0, this.minValue);
        out.setFromPoints(points, position, angle);
    };
    /**
     * Get a line segment in the heightfield
     * @method getLineSegment
     * @param  {array} start Where to store the resulting start point
     * @param  {array} end Where to store the resulting end point
     * @param  {number} i
     */
    Heightfield.prototype.getLineSegment = function (start, end, i) {
        var data = this.heights;
        var width = this.elementWidth;
        vec2_1.default.set(start, i * width, data[i]);
        vec2_1.default.set(end, (i + 1) * width, data[i + 1]);
    };
    Heightfield.prototype.getSegmentIndex = function (position) {
        return Math.floor(position[0] / this.elementWidth);
    };
    Heightfield.prototype.getClampedSegmentIndex = function (position) {
        var i = this.getSegmentIndex(position);
        i = Math.min(this.heights.length, Math.max(i, 0)); // clamp
        return i;
    };
    /**
     * @method raycast
     * @param  {RayResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Heightfield.prototype.raycast = function (result, ray, position, angle) {
        var from = ray.from;
        var to = ray.to;
        var worldNormal = intersectHeightfield_worldNormal;
        var l0 = intersectHeightfield_l0;
        var l1 = intersectHeightfield_l1;
        var localFrom = intersectHeightfield_localFrom;
        var localTo = intersectHeightfield_localTo;
        // get local ray start and end
        vec2_1.default.toLocalFrame(localFrom, from, position, angle);
        vec2_1.default.toLocalFrame(localTo, to, position, angle);
        // Get the segment range
        var i0 = this.getClampedSegmentIndex(localFrom);
        var i1 = this.getClampedSegmentIndex(localTo);
        if (i0 > i1) {
            var tmp = i0;
            i0 = i1;
            i1 = tmp;
        }
        // The segments
        for (var i = 0; i < this.heights.length - 1; i++) {
            this.getLineSegment(l0, l1, i);
            var t = vec2_1.default.getLineSegmentsIntersectionFraction(localFrom, localTo, l0, l1);
            if (t >= 0) {
                vec2_1.default.subtract(worldNormal, l1, l0);
                vec2_1.default.rotate(worldNormal, worldNormal, angle + Math.PI / 2);
                vec2_1.default.normalize(worldNormal, worldNormal);
                ray.reportIntersection(result, t, worldNormal, -1);
                if (result.shouldStop(ray)) {
                    return;
                }
            }
        }
    };
    return Heightfield;
}(Shape_1.default));
exports.default = Heightfield;

},{"../math/vec2":28,"./Shape":38}],43:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,   shallowClone = require('../utils/Utils').shallowClone
// ,   vec2 = require('../math/vec2');
var Shape_1 = __importDefault(_dereq_("./Shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var raycast_normal = vec2_1.default.create();
var raycast_l0 = vec2_1.default.create();
var raycast_l1 = vec2_1.default.create();
var raycast_unit_y = vec2_1.default.fromValues(0, 1);
var Line = /** @class */ (function (_super) {
    __extends(Line, _super);
    /**
     * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
     * @class Line
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {Number} [options.length=1] The total length of the line
     * @extends Shape
     * @constructor
     * @example
     *     var body = new Body();
     *     var lineShape = new Line({
     *         length: 1
     *     });
     *     body.addShape(lineShape);
     */
    function Line(options) {
        var _a;
        var _this = _super.call(this, Shape_1.default.LINE, options) || this;
        /**
         * Length of this line
         * @property {Number} length
         * @default 1
         */
        _this.length = 1;
        _this.length = (_a = options === null || options === void 0 ? void 0 : options.length) !== null && _a !== void 0 ? _a : 1;
        return _this;
    }
    Line.prototype.computeMomentOfInertia = function () {
        return Math.pow(this.length, 2) / 12;
    };
    ;
    Line.prototype.updateBoundingRadius = function () {
        this.boundingRadius = this.length / 2;
        return this.boundingRadius;
    };
    ;
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Line.prototype.computeAABB = function (out, position, angle) {
        var points = [vec2_1.default.create(), vec2_1.default.create()];
        var l2 = this.length / 2;
        vec2_1.default.set(points[0], -l2, 0);
        vec2_1.default.set(points[1], l2, 0);
        out.setFromPoints(points, position, angle, 0);
    };
    ;
    Line.prototype.updateArea = function () { return 0; };
    /**
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @param  {number} angle
     * @param  {array} position
     */
    Line.prototype.raycast = function (result, ray, position, angle) {
        var from = ray.from;
        var to = ray.to;
        var l0 = raycast_l0;
        var l1 = raycast_l1;
        // get start and end of the line
        var halfLen = this.length / 2;
        vec2_1.default.set(l0, -halfLen, 0);
        vec2_1.default.set(l1, halfLen, 0);
        vec2_1.default.toGlobalFrame(l0, l0, position, angle);
        vec2_1.default.toGlobalFrame(l1, l1, position, angle);
        var fraction = vec2_1.default.getLineSegmentsIntersectionFraction(l0, l1, from, to);
        if (fraction >= 0) {
            var normal = raycast_normal;
            vec2_1.default.rotate(normal, raycast_unit_y, angle); // todo: this should depend on which side the ray comes from
            ray.reportIntersection(result, fraction, normal, -1);
        }
    };
    ;
    return Line;
}(Shape_1.default));
exports.default = Line;

},{"../math/vec2":28,"./Shape":38}],44:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,   shallowClone = require('../utils/Utils').shallowClone
// ,   copy = require('../math/vec2').copy;
var Shape_1 = __importDefault(_dereq_("./Shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var copy = vec2_1.default.copy;
var Particle = /** @class */ (function (_super) {
    __extends(Particle, _super);
    /**
     * Particle shape class.
     * @class Particle
     * @constructor
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @extends Shape
     * @example
     *     var body = new Body();
     *     var shape = new Particle();
     *     body.addShape(shape);
     */
    function Particle(options) {
        return _super.call(this, Shape_1.default.PARTICLE, options) || this;
    }
    Particle.prototype.computeMomentOfInertia = function () {
        return 0; // Can't rotate a particle
    };
    ;
    Particle.prototype.updateBoundingRadius = function () {
        this.boundingRadius = 0;
        return 0;
    };
    ;
    Particle.prototype.updateArea = function () { return 0; };
    /**
     * @method computeAABB
     * @param  {AABB}   out
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Particle.prototype.computeAABB = function (out, position /*, angle*/) {
        copy(out.lowerBound, position);
        copy(out.upperBound, position);
    };
    ;
    Particle.prototype.raycast = function (result, ray, position, angle) { 1; };
    return Particle;
}(Shape_1.default));
exports.default = Particle;

},{"../math/vec2":28,"./Shape":38}],45:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var shape_1 = __importDefault(_dereq_("./shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var intersectPlane_planePointToFrom = vec2_1.default.create();
var intersectPlane_normal = vec2_1.default.create();
var intersectPlane_len = vec2_1.default.create();
var Plane = /** @class */ (function (_super) {
    __extends(Plane, _super);
    /**
     * Plane shape class. The plane is facing in the Y direction.
     * @class Plane
     * @extends Shape
     * @constructor
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @example
     *     var body = new Body();
     *     var shape = new Plane();
     *     body.addShape(shape);
     */
    function Plane(options) {
        return _super.call(this, shape_1.default.PLANE, options) || this;
    }
    /**
     * Compute moment of inertia
     * @method computeMomentOfInertia
     */
    Plane.prototype.computeMomentOfInertia = function () {
        return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here
    };
    /**
     * Update the bounding radius
     * @method updateBoundingRadius
     */
    Plane.prototype.updateBoundingRadius = function () {
        this.boundingRadius = Infinity;
        return Infinity;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Plane.prototype.computeAABB = function (out, position, angle) {
        var a = angle % (2 * Math.PI);
        var set = vec2_1.default.set;
        var max = 1e7;
        var lowerBound = out.lowerBound;
        var upperBound = out.upperBound;
        // Set max bounds
        set(lowerBound, -max, -max);
        set(upperBound, max, max);
        if (a === 0) {
            // y goes from -inf to 0
            upperBound[1] = position[1];
        }
        else if (a === Math.PI / 2) {
            // x goes from 0 to inf
            lowerBound[0] = position[0];
        }
        else if (a === Math.PI) {
            // y goes from 0 to inf
            lowerBound[1] = position[1];
        }
        else if (a === 3 * Math.PI / 2) {
            // x goes from -inf to 0
            upperBound[0] = position[0];
        }
    };
    Plane.prototype.updateArea = function () {
        this.area = Infinity;
        return Infinity;
    };
    /**
     * @method raycast
     * @param  {RayResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Plane.prototype.raycast = function (result, ray, position, angle) {
        var from = ray.from;
        var to = ray.to;
        var direction = ray.direction;
        var planePointToFrom = intersectPlane_planePointToFrom;
        var normal = intersectPlane_normal;
        var len = intersectPlane_len;
        // Get plane normal
        vec2_1.default.set(normal, 0, 1);
        vec2_1.default.rotate(normal, normal, angle);
        vec2_1.default.subtract(len, from, position);
        var planeToFrom = vec2_1.default.dot(len, normal);
        vec2_1.default.subtract(len, to, position);
        var planeToTo = vec2_1.default.dot(len, normal);
        if (planeToFrom * planeToTo > 0) {
            // "from" and "to" are on the same side of the plane... bail out
            return;
        }
        if (vec2_1.default.squaredDistance(from, to) < planeToFrom * planeToFrom) {
            return;
        }
        var n_dot_dir = vec2_1.default.dot(normal, direction);
        vec2_1.default.subtract(planePointToFrom, from, position);
        var t = -vec2_1.default.dot(normal, planePointToFrom) / n_dot_dir / ray.length;
        ray.reportIntersection(result, t, normal, -1);
    };
    ;
    Plane.prototype.pointTest = function (localPoint) {
        return localPoint[1] <= 0;
    };
    return Plane;
}(shape_1.default));
exports.default = Plane;

},{"../math/vec2":28,"./shape":46}],46:[function(_dereq_,module,exports){
module.exports=_dereq_(38)
},{"../math/vec2":28}],47:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var solver_1 = __importDefault(_dereq_("./solver"));
var friction_equation_1 = __importDefault(_dereq_("../equations/friction-equation"));
// Sets the .multiplier property of each equation
function updateMultipliers(equations, invDt) {
    var l = equations.length;
    while (l--) {
        var eq = equations[l];
        eq.multiplier = eq.lambda * invDt;
    }
}
function iterateEquation(eq) {
    // Compute iteration
    var B = eq.B, eps = eq.epsilon, invC = eq.invC, lambdaj = eq.lambda, GWlambda = eq.computeGWlambda(), maxForce_dt = eq.maxForceDt, minForce_dt = eq.minForceDt;
    var deltalambda = invC * (B - GWlambda - eps * lambdaj);
    // Clamp if we are not within the min/max interval
    var lambdaj_plus_deltalambda = lambdaj + deltalambda;
    if (lambdaj_plus_deltalambda < minForce_dt) {
        deltalambda = minForce_dt - lambdaj;
    }
    else if (lambdaj_plus_deltalambda > maxForce_dt) {
        deltalambda = maxForce_dt - lambdaj;
    }
    eq.lambda += deltalambda;
    eq.addToWlambda(deltalambda);
    return deltalambda;
}
var GSSolver = /** @class */ (function (_super) {
    __extends(GSSolver, _super);
    /**
     * Iterative Gauss-Seidel constraint equation solver.
     *
     * @class GSSolver
     * @constructor
     * @extends Solver
     * @param {Object} [options]
     * @param {Number} [options.iterations=10]
     * @param {Number} [options.tolerance=0]
     */
    function GSSolver(options) {
        var _a, _b, _c;
        var _this = _super.call(this, options, solver_1.default.GS) || this;
        /**
         * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.
         * @property {Number} usedIterations
         */
        _this.usedIterations = 0;
        _this.iterations = (_a = options === null || options === void 0 ? void 0 : options.iterations) !== null && _a !== void 0 ? _a : 10;
        _this.tolerance = (_b = options === null || options === void 0 ? void 0 : options.tolerance) !== null && _b !== void 0 ? _b : 1e-7;
        _this.frictionIterations = (_c = options === null || options === void 0 ? void 0 : options.frictionIterations) !== null && _c !== void 0 ? _c : 0;
        return _this;
    }
    /**
     * Solve the system of equations
     * @method solve
     * @param  {Number}  h       Time step
     * @param  {World}   world    World to solve
     */
    GSSolver.prototype.solve = function (h, world) {
        this.sortEquations();
        var iter = 0, maxIter = this.iterations, maxFrictionIter = this.frictionIterations, equations = this.equations, Neq = equations.length, tolSquared = Math.pow(this.tolerance * Neq, 2), bodies = world.bodies, Nbodies = bodies.length;
        this.usedIterations = 0;
        if (Neq) {
            for (var i = 0; i !== Nbodies; i++) {
                var b = bodies[i];
                // Update solve mass
                b.updateSolveMassProperties();
            }
        }
        for (var i_1 = 0; i_1 !== Neq; i_1++) {
            var c_1 = equations[i_1];
            c_1.lambda = 0;
            if (c_1.timeStep !== h || c_1.needsUpdate) {
                c_1.timeStep = h;
                c_1.update();
            }
            c_1.B = c_1.computeB(c_1.a, c_1.b, h);
            c_1.invC = c_1.computeInvC(c_1.epsilon);
            c_1.maxForceDt = c_1.maxForce * h;
            c_1.minForceDt = c_1.minForce * h;
        }
        var c, deltalambdaTot, j;
        if (Neq !== 0) {
            for (i = 0; i !== Nbodies; i++) {
                var b = bodies[i];
                // Reset vlambda
                b.resetConstraintVelocity();
            }
            if (maxFrictionIter) {
                // Iterate over contact equations to get normal forces
                for (iter = 0; iter !== maxFrictionIter; iter++) {
                    // Accumulate the total error for each iteration.
                    deltalambdaTot = 0.0;
                    for (j = 0; j !== Neq; j++) {
                        c = equations[j];
                        var deltalambda = iterateEquation(c);
                        deltalambdaTot += Math.abs(deltalambda);
                    }
                    this.usedIterations++;
                    // If the total error is small enough - stop iterate
                    if (deltalambdaTot * deltalambdaTot <= tolSquared) {
                        break;
                    }
                }
                updateMultipliers(equations, 1 / h);
                // Set computed friction force
                for (j = 0; j !== Neq; j++) {
                    var eq = equations[j];
                    if (eq instanceof friction_equation_1.default) {
                        var f = 0.0;
                        for (var k = 0; k !== eq.contactEquations.length; k++) {
                            f += eq.contactEquations[k].multiplier;
                        }
                        f *= eq.frictionCoefficient / eq.contactEquations.length;
                        eq.maxForce = f;
                        eq.minForce = -f;
                        eq.maxForceDt = f * h;
                        eq.minForceDt = -f * h;
                    }
                }
            }
            // Iterate over all equations
            for (iter = 0; iter !== maxIter; iter++) {
                // Accumulate the total error for each iteration.
                deltalambdaTot = 0.0;
                for (j = 0; j !== Neq; j++) {
                    c = equations[j];
                    var deltalambda = iterateEquation(c);
                    deltalambdaTot += Math.abs(deltalambda);
                }
                this.usedIterations++;
                // If the total error is small enough - stop iterate
                if (deltalambdaTot * deltalambdaTot < tolSquared) {
                    break;
                }
            }
            // Add result to velocity
            for (i = 0; i !== Nbodies; i++) {
                bodies[i].addConstraintVelocity();
            }
            updateMultipliers(equations, 1 / h);
        }
    };
    ;
    return GSSolver;
}(solver_1.default));
exports.default = GSSolver;

},{"../equations/friction-equation":18,"./solver":48}],48:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var event_emitter_1 = __importDefault(_dereq_("../events/event-emitter"));
var Solver = /** @class */ (function (_super) {
    __extends(Solver, _super);
    /**
     * Base class for constraint solvers.
     * @class Solver
     * @constructor
     * @extends EventEmitter
     */
    function Solver(options, type) {
        var _a;
        var _this = _super.call(this) || this;
        _this.type = type;
        /**
         * Current equations in the solver.
         *
         * @property equations
         * @type {Array}
         */
        _this.equations = [];
        /**
         * Function that is used to sort all equations before each solve.
         * @property equationSortFunction
         * @type {function|boolean}
         */
        _this.equationSortFunction = (_a = options === null || options === void 0 ? void 0 : options.equationSortFunction) !== null && _a !== void 0 ? _a : undefined;
        return _this;
    }
    /**
     * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.
     * @method sortEquations
     */
    Solver.prototype.sortEquations = function () {
        if (this.equationSortFunction) {
            this.equations.sort(this.equationSortFunction);
        }
    };
    ;
    /**
     * Add an equation to be solved.
     *
     * @method addEquation
     * @param {Equation} eq
     */
    Solver.prototype.addEquation = function (eq) {
        if (eq.enabled) {
            this.equations.push(eq);
        }
    };
    ;
    /**
     * Add equations. Same as .addEquation, but this time the argument is an array of Equations
     *
     * @method addEquations
     * @param {Array} eqs
     */
    Solver.prototype.addEquations = function (eqs) {
        for (var i = 0, N = eqs.length; i !== N; i++) {
            var eq = eqs[i];
            if (eq.enabled) {
                this.equations.push(eq);
            }
        }
    };
    ;
    /**
     * Remove an equation.
     *
     * @method removeEquation
     * @param {Equation} eq
     */
    Solver.prototype.removeEquation = function (eq) {
        var i = this.equations.indexOf(eq);
        if (i !== -1) {
            this.equations.splice(i, 1);
        }
    };
    ;
    /**
     * Remove all currently added equations.
     *
     * @method removeAllEquations
     */
    Solver.prototype.removeAllEquations = function () {
        this.equations.length = 0;
    };
    ;
    /**
     * Gauss-Seidel solver.
     * @property GS
     * @type {Number}
     * @static
     */
    Solver.GS = 1;
    return Solver;
}(event_emitter_1.default));
exports.default = Solver;

},{"../events/event-emitter":21}],49:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var pool_1 = __importDefault(_dereq_("./pool"));
var contact_equation_1 = __importDefault(_dereq_("../equations/contact-equation"));
var ContactEquationPool = /** @class */ (function (_super) {
    __extends(ContactEquationPool, _super);
    /**
     * @class
     */
    function ContactEquationPool(options) {
        return _super.call(this, options) || this;
    }
    /**
     * @method create
     * @return {ContactEquation}
     */
    ContactEquationPool.prototype.create = function () {
        return new contact_equation_1.default();
    };
    /**
     * @method destroy
     * @param {ContactEquation} equation
     * @return {ContactEquationPool}
     */
    ContactEquationPool.prototype.destroy = function (equation) {
        equation.bodyA = equation.bodyB = null;
        return this;
    };
    return ContactEquationPool;
}(pool_1.default));
exports.default = ContactEquationPool;

},{"../equations/contact-equation":16,"./pool":54}],50:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var pool_1 = __importDefault(_dereq_("./pool"));
var friction_equation_1 = __importDefault(_dereq_("../equations/friction-equation"));
var FrictionEquationPool = /** @class */ (function (_super) {
    __extends(FrictionEquationPool, _super);
    /**
     * @class
     */
    function FrictionEquationPool(options) {
        return _super.call(this, options) || this;
    }
    /**
     * @method create
     * @return {FrictionEquation}
     */
    FrictionEquationPool.prototype.create = function () {
        return new friction_equation_1.default();
    };
    ;
    /**
     * @method destroy
     * @param {FrictionEquation} equation
     * @return {FrictionEquationPool}
     */
    FrictionEquationPool.prototype.destroy = function (equation) {
        equation.bodyA = equation.bodyB = null;
        return this;
    };
    ;
    return FrictionEquationPool;
}(pool_1.default));
exports.default = FrictionEquationPool;

},{"../equations/friction-equation":18,"./pool":54}],51:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var pool_1 = __importDefault(_dereq_("./pool"));
var overlap_keeper_record_1 = __importDefault(_dereq_("./overlap-keeper-record"));
var OverlapKeeperRecordPool = /** @class */ (function (_super) {
    __extends(OverlapKeeperRecordPool, _super);
    /**
     * @class
     */
    function OverlapKeeperRecordPool(options) {
        return _super.call(this, options) || this;
    }
    /**
     * @method create
     * @return {OverlapKeeperRecord}
     */
    OverlapKeeperRecordPool.prototype.create = function () {
        return new overlap_keeper_record_1.default();
    };
    ;
    /**
     * @method destroy
     * @param {OverlapKeeperRecord} record
     * @return {OverlapKeeperRecordPool}
     */
    OverlapKeeperRecordPool.prototype.destroy = function (record) {
        record.set(undefined, undefined, undefined, undefined);
        return this;
    };
    ;
    return OverlapKeeperRecordPool;
}(pool_1.default));
exports.default = OverlapKeeperRecordPool;

},{"./overlap-keeper-record":52,"./pool":54}],52:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OverlapKeeperRecord = /** @class */ (function () {
    /**
     * Overlap data container for the OverlapKeeper
     * @class OverlapKeeperRecord
     * @constructor
     * @param {Body} bodyA
     * @param {Shape} shapeA
     * @param {Body} bodyB
     * @param {Shape} shapeB
     */
    function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB) {
        this.set(bodyA, shapeA, bodyB, shapeB);
    }
    /**
     * Set the data for the record
     * @method set
     * @param {Body} bodyA
     * @param {Shape} shapeA
     * @param {Body} bodyB
     * @param {Shape} shapeB
     */
    OverlapKeeperRecord.prototype.set = function (bodyA, shapeA, bodyB, shapeB) {
        this.shapeA = shapeA;
        this.shapeB = shapeB;
        this.bodyA = bodyA;
        this.bodyB = bodyB;
    };
    ;
    return OverlapKeeperRecord;
}());
exports.default = OverlapKeeperRecord;

},{}],53:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var tuple_dictionary_1 = __importDefault(_dereq_("./tuple-dictionary"));
var overlap_keeper_record_pool_1 = __importDefault(_dereq_("./overlap-keeper-record-pool"));
var OverlapKeeper = /** @class */ (function () {
    /**
     * Keeps track of overlaps in the current state and the last step state.
     * @class OverlapKeeper
     * @constructor
     */
    function OverlapKeeper() {
        this.overlappingShapesLastState = new tuple_dictionary_1.default();
        this.overlappingShapesCurrentState = new tuple_dictionary_1.default();
        this.recordPool = new overlap_keeper_record_pool_1.default({ size: 16 });
        this.tmpDict = new tuple_dictionary_1.default();
        this.tmpArray1 = [];
    }
    /**
     * Ticks one step forward in time. This will move the current overlap state to the "old" overlap state, and create a new one as current.
     * @method tick
     */
    OverlapKeeper.prototype.tick = function () {
        var last = this.overlappingShapesLastState;
        var current = this.overlappingShapesCurrentState;
        // Save old objects into pool
        var l = last.keys.length;
        while (l--) {
            var key = last.keys[l];
            var lastObject = last.getByKey(key);
            if (lastObject) {
                // The record is only used in the "last" dict, and will be removed. We might as well pool it.
                this.recordPool.release(lastObject);
            }
        }
        // Clear last object
        last.reset();
        // Transfer from new object to old
        last.copy(current);
        // Clear current object
        current.reset();
    };
    /**
     * @method setOverlapping
     * @param {Body} bodyA
     * @param {Body} shapeA
     * @param {Body} bodyB
     * @param {Body} shapeB
     */
    OverlapKeeper.prototype.setOverlapping = function (bodyA, shapeA, bodyB, shapeB) {
        var current = this.overlappingShapesCurrentState;
        // Store current contact state
        if (!current.get(shapeA.id, shapeB.id)) {
            var data = this.recordPool.get();
            data.set(bodyA, shapeA, bodyB, shapeB);
            current.set(shapeA.id, shapeB.id, data);
        }
    };
    OverlapKeeper.prototype.getNewOverlaps = function (result) {
        return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
    };
    OverlapKeeper.prototype.getEndOverlaps = function (result) {
        return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
    };
    /**
     * Checks if two bodies are currently overlapping.
     * @method bodiesAreOverlapping
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {boolean}
     */
    OverlapKeeper.prototype.bodiesAreOverlapping = function (bodyA, bodyB) {
        var current = this.overlappingShapesCurrentState;
        var l = current.keys.length;
        while (l--) {
            var key = current.keys[l];
            var data = current.data[key];
            if ((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA) {
                return true;
            }
        }
        return false;
    };
    OverlapKeeper.prototype.getDiff = function (dictA, dictB, result) {
        var result = result || [];
        var last = dictA;
        var current = dictB;
        result.length = 0;
        var l = current.keys.length;
        while (l--) {
            var key = current.keys[l];
            var data = current.data[key];
            if (!data) {
                throw new Error('Key ' + key + ' had no data!');
            }
            var lastData = last.data[key];
            if (!lastData) {
                // Not overlapping in last state, but in current.
                result.push(data);
            }
        }
        return result;
    };
    OverlapKeeper.prototype.isNewOverlap = function (shapeA, shapeB) {
        var last = this.overlappingShapesLastState;
        var current = this.overlappingShapesCurrentState;
        // Not in last but in new
        return !last.get(shapeA.id, shapeB.id) && !!current.get(shapeA.id, shapeB.id);
    };
    OverlapKeeper.prototype.getNewBodyOverlaps = function (result) {
        this.tmpArray1.length = 0;
        var overlaps = this.getNewOverlaps(this.tmpArray1);
        return this.getBodyDiff(overlaps, result);
    };
    OverlapKeeper.prototype.getEndBodyOverlaps = function (result) {
        this.tmpArray1.length = 0;
        var overlaps = this.getEndOverlaps(this.tmpArray1);
        return this.getBodyDiff(overlaps, result);
    };
    OverlapKeeper.prototype.getBodyDiff = function (overlaps, result) {
        result = result || [];
        var accumulator = this.tmpDict;
        var l = overlaps.length;
        while (l--) {
            var data = overlaps[l];
            // Since we use body id's for the accumulator, these will be a subset of the original one
            accumulator.set(data.bodyA.id | 0, data.bodyB.id | 0, data);
        }
        l = accumulator.keys.length;
        while (l--) {
            var data = accumulator.getByKey(accumulator.keys[l]);
            if (data) {
                result.push(data.bodyA);
                result.push(data.bodyB);
            }
        }
        accumulator.reset();
        return result;
    };
    return OverlapKeeper;
}());
exports.default = OverlapKeeper;

},{"./overlap-keeper-record-pool":51,"./tuple-dictionary":55}],54:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Pool = /** @class */ (function () {
    /**
     * Object pooling utility.
     * @class Pool
     * @constructor
     */
    function Pool(options) {
        /**
         * @property {Array} objects
         * @type {Array}
         */
        this.objects = [];
        if (options === null || options === void 0 ? void 0 : options.size) {
            this.resize(options === null || options === void 0 ? void 0 : options.size);
        }
    }
    /**
     * @method resize
     * @param {number} size
     * @return {Pool} Self, for chaining
     */
    Pool.prototype.resize = function (size) {
        var objects = this.objects;
        while (objects.length > size) {
            objects.pop();
        }
        while (objects.length < size) {
            objects.push(this.create());
        }
        return this;
    };
    /**
     * Get an object from the pool or create a new instance.
     * @method get
     * @return {Object}
     */
    Pool.prototype.get = function () {
        var objects = this.objects;
        return objects.length ? objects.pop() : this.create();
    };
    /**
     * Clean up and put the object back into the pool for later use.
     * @method release
     * @param {Object} object
     * @return {Pool} Self for chaining
     */
    Pool.prototype.release = function (object) {
        this.destroy(object);
        this.objects.push(object);
        return this;
    };
    return Pool;
}());
exports.default = Pool;

},{}],55:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __importDefault(_dereq_("./utils"));
var TupleDictionary = /** @class */ (function () {
    /**
     * @class TupleDictionary
     * @constructor
     */
    function TupleDictionary() {
        /**
         * The data storage
         * @property data
         * @type {Object}
         */
        this.data = {};
        /**
         * Keys that are currently used.
         * @property {Array} keys
         */
        this.keys = [];
    }
    /**
     * Generate a key given two integers
     * @method getKey
     * @param  {number} i
     * @param  {number} j
     * @return {number}
     */
    TupleDictionary.prototype.getKey = function (id1, id2) {
        if ((id1) === (id2)) {
            return -1;
        }
        // valid for values < 2^16
        return ((id1) > (id2) ?
            (id1 << 16) | (id2 & 0xFFFF) :
            (id2 << 16) | (id1 & 0xFFFF)) | 0;
    };
    /**
     * @method getByKey
     * @param  {Number} key
     * @return {Object}
     */
    TupleDictionary.prototype.getByKey = function (key) {
        key = key;
        return this.data[key];
    };
    /**
     * @method get
     * @param  {Number} i
     * @param  {Number} j
     * @return {Number}
     */
    TupleDictionary.prototype.get = function (i, j) {
        return this.data[this.getKey(i, j)];
    };
    /**
     * Set a value.
     * @method set
     * @param  {Number} i
     * @param  {Number} j
     * @param {Number} value
     */
    TupleDictionary.prototype.set = function (i, j, value) {
        if (!value) {
            throw new Error("No data!");
        }
        var key = this.getKey(i, j);
        // Check if key already exists
        if (!this.data[key]) {
            this.keys.push(key);
        }
        this.data[key] = value;
        return key;
    };
    /**
     * Remove all data.
     * @method reset
     */
    TupleDictionary.prototype.reset = function () {
        var data = this.data, keys = this.keys;
        var l = keys.length;
        while (l--) {
            delete data[keys[l]];
        }
        keys.length = 0;
    };
    /**
     * Copy another TupleDictionary. Note that all data in this dictionary will be removed.
     * @method copy
     * @param {TupleDictionary} dict The TupleDictionary to copy into this one.
     */
    TupleDictionary.prototype.copy = function (dict) {
        this.reset();
        utils_1.default.appendArray(this.keys, dict.keys);
        var l = dict.keys.length;
        while (l--) {
            var key = dict.keys[l];
            this.data[key] = dict.data[key];
        }
    };
    return TupleDictionary;
}());
exports.default = TupleDictionary;

},{"./utils":56}],56:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* global P2_ARRAY_TYPE */
/**
 * Misc utility functions
 */
var Utils = /** @class */ (function () {
    function Utils() {
    }
    /**
     * Append the values in array b to the array a. See <a href="http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131">this</a> for an explanation.
     * @method appendArray
     * @static
     * @param  {Array} a
     * @param  {Array} b
     */
    Utils.prototype.appendArray = function (a, b) {
        for (var i = 0, len = b.length; i !== len; ++i) {
            a.push(b[i]);
        }
    };
    /**
     * Garbage free Array.splice(). Does not allocate a new array.
     * @method splice
     * @static
     * @param  {Array} array
     * @param  {Number} index
     * @param  {Number} howmany
     */
    Utils.prototype.splice = function (array, index, howmany) {
        howmany = howmany || 1;
        for (var i = index, len = array.length - howmany; i < len; i++) {
            array[i] = array[i + howmany];
        }
        array.length = len;
    };
    /**
     * Remove an element from an array, if the array contains the element.
     * @method arrayRemove
     * @static
     * @param  {Array} array
     * @param  {Number} element
     */
    Utils.prototype.arrayRemove = function (array, element) {
        var idx = array.indexOf(element);
        if (idx !== -1) {
            this.splice(array, idx, 1);
        }
    };
    /**
     * Extend an object with the properties of another
     * @static
     * @method extend
     * @param  {object} a
     * @param  {object} b
     */
    Utils.prototype.extend = function (a, b) {
        for (var key in b) {
            a[key] = b[key];
        }
    };
    /**
     * Shallow clone an object. Returns a new object instance with the same properties as the input instance.
     * @static
     * @method shallowClone
     * @param  {object} obj
     */
    Utils.prototype.shallowClone = function (obj) {
        var newObj = {};
        this.extend(newObj, obj);
        return newObj;
    };
    return Utils;
}());
exports.default = new Utils();

},{}],57:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnionFind = /** @class */ (function () {
    /**
     * Weighted Quick Union-Find with Path Compression. Based on https://github.com/juzerali/unionfind, but optimized for performance.
     * @class UnionFind
     * @constructor
     * @param {number} size
     */
    function UnionFind(size) {
        this.id = [];
        this.sz = [];
        /**
         * The number of elements.
         * @property {number} size
         */
        this.size = size;
        /**
         * The number of distinct groups.
         * @property {number} count
         */
        this.count = size;
        this.resize(size);
    }
    /**
     * Initialize the UnionFind data structure with number of distinct groups to begin with. Each group will be referred to as index of the array of size size starting at 0.
     * @method resize
     * @param {number} size
     */
    UnionFind.prototype.resize = function (size) {
        this.count = this.size = size;
        var sz = this.sz;
        var id = this.id;
        for (var i = 0; i < size; i++) {
            id[i] = i;
            sz[i] = 1;
        }
    };
    /**
     * Return the root (value) of the group in which p is.
     * @method find
     * @param {number} p
     */
    UnionFind.prototype.find = function (p) {
        var id = this.id;
        while (p !== id[p]) {
            id[p] = id[id[p]];
            p = id[p];
        }
        return p;
    };
    /**
     * Combine elements in groups p and q into a single group. In other words connect the two groups.
     * @method union
     * @param {number} p
     * @param {number} q
     */
    UnionFind.prototype.union = function (p, q) {
        var i = this.find(p), j = this.find(q);
        if (i === j) {
            return;
        }
        var sz = this.sz;
        var id = this.id;
        if (sz[i] < sz[j]) {
            id[i] = j;
            sz[j] += sz[i];
        }
        else {
            id[j] = i;
            sz[i] += sz[j];
        }
        this.count--;
        return;
    };
    return UnionFind;
}());
exports.default = UnionFind;

},{}],58:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var gs_solver_1 = __importDefault(_dereq_("../solver/gs-solver"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var shape_1 = __importDefault(_dereq_("../shapes/shape"));
var event_emitter_1 = __importDefault(_dereq_("../events/event-emitter"));
var body_1 = __importDefault(_dereq_("../objects/body"));
var material_1 = __importDefault(_dereq_("../material/material"));
var contact_material_1 = __importDefault(_dereq_("../material/contact-material"));
var aabb_1 = __importDefault(_dereq_("../collision/aabb"));
var sap_broadphase_1 = __importDefault(_dereq_("../collision/sap-broadphase"));
var narrowphase_1 = __importDefault(_dereq_("../collision/narrowphase"));
var utils_1 = __importDefault(_dereq_("../utils/utils"));
//import arrayRemove from  "ayRemo"; // Get rid of this dependency!
var overlap_keeper_1 = __importDefault(_dereq_("../utils/overlap-keeper"));
var union_find_1 = __importDefault(_dereq_("./union-find"));
//import f32 from "f32";
/**
 * Fired after the step().
 * @event postStep
 */
var postStepEvent = {
    type: "postStep"
};
/**
 * Fired when a body is added to the world.
 * @event addBody
 * @param {Body} body
 */
var AddBodyEvent = /** @class */ (function () {
    function AddBodyEvent() {
        this.type = "addBody";
        this.body = null;
    }
    return AddBodyEvent;
}());
var addBodyEvent = new AddBodyEvent();
/**
 * Fired when a body is removed from the world.
 * @event removeBody
 * @param {Body} body
 */
var RemoveBodyEvent = /** @class */ (function () {
    function RemoveBodyEvent() {
        this.type = "removeBody";
        this.body = null;
    }
    return RemoveBodyEvent;
}());
var removeBodyEvent = new RemoveBodyEvent();
/**
 * Fired when a spring is added to the world.
 * @event addSpring
 * @param {Spring} spring
 */
var AddSpringEvent = /** @class */ (function () {
    function AddSpringEvent() {
        this.type = "addSpring";
        this.spring = null;
    }
    return AddSpringEvent;
}());
var addSpringEvent = new AddSpringEvent();
/**
 * Fired when a first contact is created between two bodies. This event is fired after the step has been done.
 * @event impact
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @deprecated Impact event will be removed. Use beginContact instead.
 */
var ImpactEvent = /** @class */ (function () {
    function ImpactEvent() {
        this.type = "impact";
        this.bodyA = null;
        this.bodyB = null;
        this.shapeA = null;
        this.shapeB = null;
        this.contactEquation = null;
    }
    return ImpactEvent;
}());
var impactEvent = new ImpactEvent();
/**
 * Fired after the Broadphase has collected collision pairs in the world.
 * Inside the event handler, you can modify the pairs array as you like, to
 * prevent collisions between objects that you don't want.
 * @event postBroadphase
 * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.
 */
var PostBroadphaseEvent = /** @class */ (function () {
    function PostBroadphaseEvent() {
        this.type = "postBroadphase";
        this.pairs = null;
    }
    return PostBroadphaseEvent;
}());
var postBroadphaseEvent = new PostBroadphaseEvent;
var BeginContactEvent = /** @class */ (function () {
    function BeginContactEvent() {
        this.type = "beginContact";
        this.shapeA = null;
        this.shapeB = null;
        this.bodyA = null;
        this.bodyB = null;
        this.contactEquations = [];
    }
    return BeginContactEvent;
}());
/**
 * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.
 * @event beginContact
 * @param {Shape} shapeA
 * @param {Shape} shapeB
 * @param {Body}  bodyA
 * @param {Body}  bodyB
 * @param {Array} contactEquations
 */
var beginContactEvent = new BeginContactEvent();
/**
 * Fired when two shapes stop overlapping, after the narrowphase (during step).
 * @event endContact
 * @param {Shape} shapeA
 * @param {Shape} shapeB
 * @param {Body}  bodyA
 * @param {Body}  bodyB
 */
var endContactEvent = {
    type: "endContact",
    shapeA: null,
    shapeB: null,
    bodyA: null,
    bodyB: null
};
var hitTest_tmp1 = vec2_1.default.create(), hitTest_tmp2 = vec2_1.default.create();
/**
 * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.
 * @event preSolve
 * @param {Array} contactEquations  An array of contacts to be solved.
 * @param {Array} frictionEquations An array of friction equations to be solved.
 */
var PreSolveEvent = /** @class */ (function () {
    function PreSolveEvent() {
        this.type = "preSolve";
        this.contactEquations = null;
        this.frictionEquations = null;
    }
    return PreSolveEvent;
}());
var preSolveEvent = new PreSolveEvent();
function sortBodiesByIsland(a, b) {
    return a.islandId - b.islandId;
}
function sortEquationsByIsland(equationA, equationB) {
    if (!(equationA === null || equationA === void 0 ? void 0 : equationA.bodyA) || !(equationA === null || equationA === void 0 ? void 0 : equationA.bodyB) || !(equationB === null || equationB === void 0 ? void 0 : equationB.bodyA) || !(equationB === null || equationB === void 0 ? void 0 : equationB.bodyB))
        return 0;
    var islandA = equationA.bodyA.islandId > 0 ? equationA.bodyA.islandId : equationA.bodyB.islandId;
    var islandB = equationB.bodyA.islandId > 0 ? equationB.bodyA.islandId : equationB.bodyB.islandId;
    if (islandA !== islandB) {
        return islandA - islandB;
    }
    else {
        // Sort by equation type if same island
        return equationA.index - equationB.index;
    }
}
// Why not just make this a private method in world?
// What are all these props???
function runNarrowphase(world, np, bi, si, xi, ai, bj, sj, xj, aj, cm, glen) {
    var xiw = vec2_1.default.create();
    var xjw = vec2_1.default.create();
    // Check collision groups and masks
    if (!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)) {
        return;
    }
    // Get world position and angle of each shape
    vec2_1.default.toGlobalFrame(xiw, xi, bi.position, bi.angle);
    vec2_1.default.toGlobalFrame(xjw, xj, bj.position, bj.angle);
    if (vec2_1.default.distance(xiw, xjw) > si.boundingRadius + sj.boundingRadius) {
        return;
    }
    var aiw = ai + bi.angle;
    var ajw = aj + bj.angle;
    np.enableFriction = cm.friction > 0;
    var reducedMass;
    if (bi.type === body_1.default.STATIC || bi.type === body_1.default.KINEMATIC) {
        reducedMass = bj.mass;
    }
    else if (bj.type === body_1.default.STATIC || bj.type === body_1.default.KINEMATIC) {
        reducedMass = bi.mass;
    }
    else {
        reducedMass = (bi.mass * bj.mass) / (bi.mass + bj.mass);
    }
    np.slipForce = cm.friction * glen * reducedMass;
    np.currentContactMaterial = cm;
    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
    var sensor = si.sensor || sj.sensor;
    var numFrictionBefore = np.frictionEquations.length;
    var numContacts = np.testContact(bi, si, xiw, bj, sj, xjw, sensor);
    var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;
    if (numContacts) {
        if (bi.allowSleep &&
            bi.type === body_1.default.DYNAMIC &&
            bi.sleepState === body_1.default.SLEEPING &&
            bj.sleepState === body_1.default.AWAKE &&
            bj.type !== body_1.default.STATIC) {
            var speedSquaredB = vec2_1.default.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity, 2);
            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);
            if (speedSquaredB >= speedLimitSquaredB * 2) {
                bi._wakeUpAfterNarrowphase = true;
            }
        }
        if (bj.allowSleep &&
            bj.type === body_1.default.DYNAMIC &&
            bj.sleepState === body_1.default.SLEEPING &&
            bi.sleepState === body_1.default.AWAKE &&
            bi.type !== body_1.default.STATIC) {
            var speedSquaredA = vec2_1.default.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity, 2);
            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);
            if (speedSquaredA >= speedLimitSquaredA * 2) {
                bj._wakeUpAfterNarrowphase = true;
            }
        }
        world.overlapKeeper.setOverlapping(bi, si, bj, sj);
        if (world.has('beginContact') && world.overlapKeeper.isNewOverlap(si, sj)) {
            // Report new shape overlap
            var e = beginContactEvent;
            e.shapeA = si;
            e.shapeB = sj;
            e.bodyA = bi;
            e.bodyB = bj;
            // Reset contact equations
            e.contactEquations.length = 0;
            if (!sensor) {
                for (var i = np.contactEquations.length - numContacts; i < np.contactEquations.length; i++) {
                    e.contactEquations.push(np.contactEquations[i]);
                }
            }
            world.emit(e);
        }
        // divide the max friction force by the number of contacts
        if (!sensor && numFrictionEquations > 1) { // Why divide by 1?
            for (var i = np.frictionEquations.length - numFrictionEquations; i < np.frictionEquations.length; i++) {
                var f = np.frictionEquations[i];
                f.setSlipForce(f.getSlipForce() / numFrictionEquations);
            }
        }
    }
}
function setGlobalEquationParams(world, params) {
    var _a, _b;
    var constraints = world.constraints;
    for (var i = 0; i !== constraints.length; i++) {
        var c = constraints[i];
        var eqs = c.equations;
        for (var j = 0; j !== eqs.length; j++) {
            var eq = eqs[j];
            eq.relaxation = (_a = params === null || params === void 0 ? void 0 : params.relaxation) !== null && _a !== void 0 ? _a : eq.relaxation;
            eq.stiffness = (_b = params === null || params === void 0 ? void 0 : params.stiffness) !== null && _b !== void 0 ? _b : eq.stiffness;
            eq.needsUpdate = true;
        }
    }
}
var World = /** @class */ (function (_super) {
    __extends(World, _super);
    /**
     * The dynamics world, where all bodies and constraints live.
     *
     * @class World
     * @constructor
     * @param {Object} [options]
     * @param {Solver} [options.solver] Defaults to GSSolver.
     * @param {Array} [options.gravity] Defaults to y=-9.78.
     * @param {Broadphase} [options.broadphase] Defaults to SAPBroadphase
     * @param {Boolean} [options.islandSplit=true]
     * @extends EventEmitter
     *
     * @example
     *     var world = new World({
     *         gravity: [0, -10],
     *         broadphase: new SAPBroadphase()
     *     });
     *     world.addBody(new Body());
     */
    function World(options) {
        var _a, _b, _c, _d;
        var _this = _super.call(this) || this;
        /**
         * All springs in the world. To add a spring to the world, use {{#crossLink "World/addSpring:method"}}{{/crossLink}}.
         *
         * @property springs
         * @type {Array}
         */
        _this.springs = [];
        /**
         * All bodies in the world. To add a body to the world, use {{#crossLink "World/addBody:method"}}{{/crossLink}}.
         * @property {Array} bodies
         */
        _this.bodies = [];
        /**
         * Disabled body collision pairs. See {{#crossLink "World/disableBodyCollision:method"}}.
         * @private
         * @property {Array} disabledBodyCollisionPairs
         */
        _this.disabledBodyCollisionPairs = [];
        /**
         * The narrowphase to use to generate contacts.
         *
         * @property narrowphase
         * @type {Narrowphase}
         */
        _this.narrowphase = new narrowphase_1.default();
        /**
         * Gravity in the world. This is applied on all bodies in the beginning of each step().
         *
         * @property gravity
         * @type {Array}
         */
        _this.gravity = vec2_1.default.fromValues(0, -9.78);
        /**
         * Gravity to use when approximating the friction max force (mu*mass*gravity).
         * @property {Number} frictionGravity
         */
        _this.frictionGravity = 10;
        /**
         * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.
         * @property {Boolean} useWorldGravityAsFrictionGravity
         * @default true
         */
        _this.useWorldGravityAsFrictionGravity = true;
        /**
         * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.
         * @property {Boolean} useFrictionGravityOnZeroGravity
         * @default true
         */
        _this.useFrictionGravityOnZeroGravity = true;
        /**
         * User-added constraints.
         *
         * @property constraints
         * @type {Array}
         */
        _this.constraints = [];
        /**
         * Dummy default material in the world, used in .defaultContactMaterial
         * @property {Material} defaultMaterial
         */
        _this.defaultMaterial = new material_1.default();
        /**
         * For keeping track of what time step size we used last step
         * @property lastTimeStep
         * @type {Number}
         */
        _this.lastTimeStep = 1 / 60;
        /**
         * Enable to automatically apply spring forces each step.
         * @property applySpringForces
         * @type {Boolean}
         * @default true
         */
        _this.applySpringForces = true;
        /**
         * Enable to automatically apply body damping each step.
         * @property applyDamping
         * @type {Boolean}
         * @default true
         */
        _this.applyDamping = true;
        /**
         * Enable to automatically apply gravity each step.
         * @property applyGravity
         * @type {Boolean}
         * @default true
         */
        _this.applyGravity = true;
        /**
         * Enable/disable constraint solving in each step.
         * @property solveConstraints
         * @type {Boolean}
         * @default true
         */
        _this.solveConstraints = true;
        /**
         * The ContactMaterials added to the World.
         * @property contactMaterials
         * @type {Array}
         */
        _this.contactMaterials = [];
        /**
         * World time.
         * @property time
         * @type {Number}
         */
        _this.time = 0.0;
        _this.accumulator = 0;
        /**
         * Is true during step().
         * @property {Boolean} stepping
         */
        _this.stepping = false;
        /**
         * Whether to enable island splitting. Island splitting can be an advantage for both precision and performance.
         * @property {Boolean} islandSplit
         * @default false
         */
        _this.islandSplit = true;
        /**
         * Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
         * @property emitImpactEvent
         * @type {Boolean}
         * @default true
         * @deprecated Impact event will be removed. Use beginContact instead.
         */
        _this.emitImpactEvent = true;
        /**
         * How to deactivate bodies during simulation. Possible modes are: {{#crossLink "World/NO_SLEEPING:property"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink "World/BODY_SLEEPING:property"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink "World/ISLAND_SLEEPING:property"}}World.ISLAND_SLEEPING{{/crossLink}}.
         * If sleeping is enabled, you might need to {{#crossLink "Body/wakeUp:method"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink "Body/allowSleep:property"}}Body.allowSleep{{/crossLink}}.
         * @property sleepMode
         * @type {number}
         * @default World.NO_SLEEPING
         */
        _this.sleepMode = World.NO_SLEEPING;
        /**
         * @property {UnionFind} unionFind
         */
        _this.unionFind = new union_find_1.default(1);
        // Id counters
        _this._constraintIdCounter = 0;
        _this._bodyIdCounter = 0;
        /**
         * @property {OverlapKeeper} overlapKeeper
         */
        _this.overlapKeeper = new overlap_keeper_1.default();
        _this.solver = (_a = options === null || options === void 0 ? void 0 : options.solver) !== null && _a !== void 0 ? _a : new gs_solver_1.default();
        if (options === null || options === void 0 ? void 0 : options.gravity) {
            vec2_1.default.copy(_this.gravity, options.gravity);
        }
        _this.frictionGravity = (_b = vec2_1.default.length(_this.gravity)) !== null && _b !== void 0 ? _b : 10;
        _this.broadphase = (_c = options === null || options === void 0 ? void 0 : options.broadphase) !== null && _c !== void 0 ? _c : new sap_broadphase_1.default();
        _this.broadphase.setWorld(_this);
        _this.defaultContactMaterial = new contact_material_1.default(_this.defaultMaterial, _this.defaultMaterial);
        _this.islandSplit = (_d = options === null || options === void 0 ? void 0 : options.islandSplit) !== null && _d !== void 0 ? _d : true;
        return _this;
    }
    /**
     * Add a constraint to the simulation. Note that both bodies connected to the constraint must be added to the world first. Also note that you can't run this method during step.
     *
     * @method addConstraint
     * @param {Constraint} constraint
     * @example
     *     var constraint = new LockConstraint(bodyA, bodyB);
     *     world.addConstraint(constraint);
     */
    World.prototype.addConstraint = function (constraint) {
        if (this.stepping) {
            throw new Error('Constraints cannot be added during step.');
        }
        var bodies = this.bodies;
        if (bodies.indexOf(constraint.bodyA) === -1) {
            throw new Error('Cannot add Constraint: bodyA is not added to the World.');
        }
        if (bodies.indexOf(constraint.bodyB) === -1) {
            throw new Error('Cannot add Constraint: bodyB is not added to the World.');
        }
        this.constraints.push(constraint);
    };
    /**
     * Add a ContactMaterial to the simulation.
     * @method addContactMaterial
     * @param {ContactMaterial} contactMaterial
     */
    World.prototype.addContactMaterial = function (contactMaterial) {
        this.contactMaterials.push(contactMaterial);
    };
    /**
     * Removes a contact material
     *
     * @method removeContactMaterial
     * @param {ContactMaterial} cm
     */
    World.prototype.removeContactMaterial = function (cm) {
        utils_1.default.arrayRemove(this.contactMaterials, cm);
    };
    /**
     * Get a contact material given two materials
     * @method getContactMaterial
     * @param {Material} materialA
     * @param {Material} materialB
     * @return {ContactMaterial} The matching ContactMaterial, or false on fail.
     * @todo Use faster hash map to lookup from material id's
     */
    World.prototype.getContactMaterial = function (materialA, materialB) {
        var cmats = this.contactMaterials;
        for (var i = 0, N = cmats.length; i !== N; i++) {
            var cm = cmats[i];
            if ((cm.materialA === materialA && cm.materialB === materialB) || (cm.materialA === materialB && cm.materialB === materialA)) {
                return cm;
            }
        }
        return null;
    };
    /**
     * Removes a constraint. Note that you can't run this method during step.
     *
     * @method removeConstraint
     * @param {Constraint} constraint
     */
    World.prototype.removeConstraint = function (constraint) {
        if (this.stepping) {
            throw new Error('Constraints cannot be removed during step.');
        }
        utils_1.default.arrayRemove(this.constraints, constraint);
    };
    /**
     * Step the physics world forward in time.
     *
     * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
     *
     * @method step
     * @param {Number} dt                       The fixed time step size to use.
     * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.
     * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
     *
     * @example
     *     // Simple fixed timestepping without interpolation
     *     var fixedTimeStep = 1 / 60;
     *     var world = new World();
     *     var body = new Body({ mass: 1 });
     *     world.addBody(body);
     *
     *     function animate(){
     *         requestAnimationFrame(animate);
     *         world.step(fixedTimeStep);
     *         renderBody(body.position, body.angle);
     *     }
     *
     *     // Start animation loop
     *     requestAnimationFrame(animate);
     *
     * @example
     *     // Fixed timestepping with interpolation
     *     var maxSubSteps = 10;
     *     var lastTimeSeconds;
     *
     *     function animate(time){
     *         requestAnimationFrame(animate);
     *         var timeSeconds = time / 1000;
     *
     *         if(lastTimeSeconds){
     *             var deltaTime = timeSeconds - lastTimeSeconds;
     *             world.step(fixedTimeStep, deltaTime, maxSubSteps);
     *         }
     *
     *         lastTimeSeconds = timeSeconds;
     *
     *         renderBody(body.interpolatedPosition, body.interpolatedAngle);
     *     }
     *
     *     // Start animation loop
     *     requestAnimationFrame(animate);
     *
     * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
     */
    World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {
        maxSubSteps = maxSubSteps || 10;
        timeSinceLastCalled = timeSinceLastCalled || 0;
        if (timeSinceLastCalled === 0) { // Fixed, simple stepping
            this.internalStep(dt);
            // Increment time
            this.time += dt;
        }
        else {
            this.accumulator += timeSinceLastCalled;
            var substeps = 0;
            while (this.accumulator >= dt && substeps < maxSubSteps) {
                // Do fixed steps to catch up
                this.internalStep(dt);
                this.time += dt;
                this.accumulator -= dt;
                substeps++;
            }
            var t = (this.accumulator % dt) / dt;
            for (var j = 0; j !== this.bodies.length; j++) {
                var b = this.bodies[j];
                vec2_1.default.lerp(b.interpolatedPosition, b.previousPosition, b.position, t);
                b.interpolatedAngle = b.previousAngle + t * (b.angle - b.previousAngle);
            }
        }
    };
    /**
     * Make a fixed step.
     * @method internalStep
     * @param  {number} dt
     * @private
     */
    World.prototype.internalStep = function (dt) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var step_mg = vec2_1.default.create();
        var endOverlaps = [];
        this.stepping = true;
        var Nsprings = this.springs.length, springs = this.springs, bodies = this.bodies, g = this.gravity, solver = this.solver, Nbodies = this.bodies.length, broadphase = this.broadphase, np = this.narrowphase, constraints = this.constraints, mg = step_mg, add = vec2_1.default.add;
        this.overlapKeeper.tick();
        this.lastTimeStep = dt;
        // Update approximate friction gravity.
        if (this.useWorldGravityAsFrictionGravity) {
            var gravityLen = vec2_1.default.length(this.gravity);
            if (!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)) {
                // Nonzero gravity. Use it.
                this.frictionGravity = gravityLen;
            }
        }
        // Add gravity to bodies
        if (this.applyGravity) {
            for (var i = 0; i !== Nbodies; i++) {
                var b = bodies[i], fi = b.force;
                if (b.type !== body_1.default.DYNAMIC || b.sleepState === body_1.default.SLEEPING) {
                    continue;
                }
                vec2_1.default.scale(mg, g, b.mass * b.gravityScale); // F=m*g
                add(fi, fi, mg);
            }
        }
        // Add spring forces
        if (this.applySpringForces) {
            for (var i = 0; i !== Nsprings; i++) {
                var s = springs[i];
                s.applyForce();
            }
        }
        if (this.applyDamping) {
            for (var i = 0; i !== Nbodies; i++) {
                var b = bodies[i];
                if (b.type === body_1.default.DYNAMIC) {
                    b.applyDamping(dt);
                }
            }
        }
        // Broadphase
        var result = broadphase.getCollisionPairs(this);
        // Remove ignored collision pairs
        var ignoredPairs = this.disabledBodyCollisionPairs;
        for (var i = ignoredPairs.length - 2; i >= 0; i -= 2) {
            for (var j = result.length - 2; j >= 0; j -= 2) {
                if ((ignoredPairs[i] === result[j] && ignoredPairs[i + 1] === result[j + 1]) ||
                    (ignoredPairs[i + 1] === result[j] && ignoredPairs[i] === result[j + 1])) {
                    result.splice(j, 2);
                }
            }
        }
        // Remove constrained pairs with collideConnected == false
        var Nconstraints = constraints.length;
        for (i = 0; i !== Nconstraints; i++) {
            var c = constraints[i];
            if (!c.collideConnected) {
                for (var j = result.length - 2; j >= 0; j -= 2) {
                    if ((c.bodyA === result[j] && c.bodyB === result[j + 1]) ||
                        (c.bodyB === result[j] && c.bodyA === result[j + 1])) {
                        result.splice(j, 2);
                    }
                }
            }
        }
        // postBroadphase event
        postBroadphaseEvent.pairs = result;
        this.emit(postBroadphaseEvent);
        postBroadphaseEvent.pairs = null;
        // Narrowphase
        np.reset();
        var defaultContactMaterial = this.defaultContactMaterial;
        var frictionGravity = this.frictionGravity;
        for (var i = 0, Nresults = result.length; i !== Nresults; i += 2) {
            var bi = result[i], bj = result[i + 1];
            // Loop over all shapes of body i
            for (var k = 0, Nshapesi = bi.shapes.length; k !== Nshapesi; k++) {
                var si = bi.shapes[k], xi = si.position, ai = si.angle;
                // All shapes of body j
                for (var l = 0, Nshapesj = bj.shapes.length; l !== Nshapesj; l++) {
                    var sj = bj.shapes[l], xj = sj.position, aj = sj.angle;
                    var contactMaterial = null;
                    if (si.material && sj.material) {
                        contactMaterial = this.getContactMaterial(si.material, sj.material);
                    }
                    runNarrowphase(this, np, bi, si, xi, ai, bj, sj, xj, aj, contactMaterial !== null && contactMaterial !== void 0 ? contactMaterial : defaultContactMaterial, frictionGravity);
                }
            }
        }
        // Wake up bodies
        for (var i = 0; i !== Nbodies; i++) {
            var body = bodies[i];
            if (body._wakeUpAfterNarrowphase) {
                body.wakeUp();
                body._wakeUpAfterNarrowphase = false;
            }
        }
        // Emit end overlap events
        if (_super.prototype.has.call(this, "endContact")) {
            this.overlapKeeper.getEndOverlaps(endOverlaps);
            var e = endContactEvent;
            var l = endOverlaps.length;
            while (l--) {
                var data = endOverlaps[l];
                e.shapeA = data.shapeA;
                e.shapeB = data.shapeB;
                e.bodyA = data.bodyA;
                e.bodyB = data.bodyB;
                this.emit(e);
            }
            endOverlaps.length = 0;
        }
        preSolveEvent.contactEquations = np.contactEquations;
        preSolveEvent.frictionEquations = np.frictionEquations;
        this.emit(preSolveEvent);
        preSolveEvent.contactEquations = preSolveEvent.frictionEquations = null;
        // update constraint equations
        var Nconstraints = constraints.length;
        for (i = 0; i !== Nconstraints; i++) {
            constraints[i].update();
        }
        if (np.contactEquations.length || np.frictionEquations.length || Nconstraints) {
            // Get all equations
            var equations = [];
            utils_1.default.appendArray(equations, np.contactEquations);
            utils_1.default.appendArray(equations, np.frictionEquations);
            for (i = 0; i !== Nconstraints; i++) {
                utils_1.default.appendArray(equations, constraints[i].equations);
            }
            if (this.islandSplit) {
                // Initialize the UnionFind
                var unionFind = this.unionFind;
                unionFind.resize(this.bodies.length + 1);
                // Update equation index
                for (var i = 0; i < equations.length; i++) {
                    equations[i].index = i;
                }
                // Unite bodies if they are connected by an equation
                for (var i = 0; i < equations.length; i++) {
                    var bodyA = equations[i].bodyA;
                    var bodyB = equations[i].bodyB;
                    if (!bodyA || !bodyB)
                        continue;
                    if (bodyA.type === body_1.default.DYNAMIC && bodyB.type === body_1.default.DYNAMIC) {
                        unionFind.union(bodyA.index, bodyB.index);
                    }
                }
                // Find the body islands
                for (var i = 0; i < bodies.length; i++) {
                    var body = bodies[i];
                    body.islandId = body.type === body_1.default.DYNAMIC ? unionFind.find(body.index) : -1;
                }
                // Sort equations by island
                equations = equations.sort(sortEquationsByIsland);
                var equationIndex = 0;
                while (equationIndex < equations.length) {
                    var equation = equations[equationIndex++];
                    solver.addEquation(equation);
                    if (!equation.bodyA || !equation.bodyB)
                        continue;
                    var currentIslandId = equation.bodyA.islandId > 0 ? equation.bodyA.islandId : equation.bodyB.islandId;
                    var nextIslandId = -1;
                    var ei = equations[equationIndex];
                    if (ei) {
                        if (ei.bodyA && ei.bodyB)
                            continue;
                        nextIslandId = ((_b = (_a = ei.bodyA) === null || _a === void 0 ? void 0 : _a.islandId) !== null && _b !== void 0 ? _b : 0) > 0 ? (_d = (_c = ei.bodyA) === null || _c === void 0 ? void 0 : _c.islandId) !== null && _d !== void 0 ? _d : 0 : (_f = (_e = ei.bodyB) === null || _e === void 0 ? void 0 : _e.islandId) !== null && _f !== void 0 ? _f : 0;
                    }
                    if (nextIslandId !== currentIslandId || equationIndex === equations.length) {
                        // Solve this island
                        if (this.solveConstraints) {
                            solver.solve(dt, this);
                        }
                        solver.removeAllEquations();
                    }
                }
            }
            else {
                // Solve all as one island
                solver.addEquations(equations);
                if (this.solveConstraints) {
                    solver.solve(dt, this);
                }
                solver.removeAllEquations();
            }
        }
        // Step forward
        for (var i = 0; i !== Nbodies; i++) {
            var body = bodies[i];
            if (body.type === body_1.default.DYNAMIC || body.type === body_1.default.KINEMATIC) {
                body.integrate(dt);
            }
        }
        // Reset force
        for (var i = 0; i !== Nbodies; i++) {
            bodies[i].setZeroForce();
        }
        // Emit impact event
        if (this.emitImpactEvent && this.has('impact')) {
            var ev = impactEvent;
            for (var i = 0; i !== np.contactEquations.length; i++) {
                var eq = np.contactEquations[i];
                if (eq.firstImpact) {
                    ev.bodyA = (_g = eq.bodyA) !== null && _g !== void 0 ? _g : null;
                    ev.bodyB = (_h = eq.bodyB) !== null && _h !== void 0 ? _h : null;
                    ev.shapeA = eq.shapeA;
                    ev.shapeB = eq.shapeB;
                    ev.contactEquation = eq;
                    this.emit(ev);
                }
            }
        }
        // Sleeping update
        if (this.sleepMode === World.BODY_SLEEPING) {
            for (i = 0; i !== Nbodies; i++) {
                bodies[i].sleepTick(this.time, false, dt);
            }
        }
        else if (this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit) {
            // Tell all bodies to sleep tick but dont sleep yet
            for (i = 0; i !== Nbodies; i++) {
                bodies[i].sleepTick(this.time, true, dt);
            }
            // Sleep islands
            var bodiesSortedByIsland = bodies.sort(sortBodiesByIsland);
            var islandEnd = 1;
            for (var islandStart = 0; islandStart < bodiesSortedByIsland.length; islandStart = islandEnd) {
                var islandId = bodiesSortedByIsland[islandStart].islandId;
                // Get islandEnd index
                /* jshint ignore:start */
                for (islandEnd = islandStart + 1; islandEnd < bodiesSortedByIsland.length && bodiesSortedByIsland[islandEnd].islandId === islandId; islandEnd++) { }
                /* jshint ignore:end */
                // Don't check static objects
                if (islandId === -1) {
                    continue;
                }
                var islandShouldSleep = true;
                for (var i = islandStart; i < islandEnd; i++) {
                    if (!bodiesSortedByIsland[i].wantsToSleep) {
                        islandShouldSleep = false;
                        break;
                    }
                }
                if (islandShouldSleep) {
                    for (var i = islandStart; i < islandEnd; i++) {
                        bodiesSortedByIsland[i].sleep();
                    }
                }
            }
        }
        this.stepping = false;
        _super.prototype.emit.call(this, postStepEvent);
    };
    /**
     * Add a spring to the simulation. Note that this operation can't be done during step.
     *
     * @method addSpring
     * @param {Spring} spring
     */
    World.prototype.addSpring = function (spring) {
        if (this.stepping) {
            throw new Error('Springs cannot be added during step.');
        }
        this.springs.push(spring);
        addSpringEvent.spring = spring;
        this.emit(addSpringEvent);
        addSpringEvent.spring = null;
    };
    /**
     * Remove a spring. Note that this operation can't be done during step.
     *
     * @method removeSpring
     * @param {Spring} spring
     */
    World.prototype.removeSpring = function (spring) {
        if (this.stepping) {
            throw new Error('Springs cannot be removed during step.');
        }
        utils_1.default.arrayRemove(this.springs, spring);
    };
    /**
     * Add a body to the simulation. Note that you can't add a body during step: you have to wait until after the step (see the postStep event).
     * Also note that bodies can only be added to one World at a time.
     *
     * @method addBody
     * @param {Body} body
     *
     * @example
     *     var world = new World(),
     *         body = new Body();
     *     world.addBody(body);
     */
    World.prototype.addBody = function (body) {
        if (this.stepping) {
            throw new Error('Bodies cannot be added during step.');
        }
        // Already added?
        if (body.world) {
            throw new Error('Body is already added to a World.');
        }
        body.index = this.bodies.length;
        this.bodies.push(body);
        body.world = this;
        addBodyEvent.body = body;
        this.emit(addBodyEvent);
        addBodyEvent.body = null;
    };
    /**
     * Remove a body from the simulation. Note that bodies cannot be removed during step (for example, inside the beginContact event). In that case you need to wait until the step is done (see the postStep event).
     *
     * Also note that any constraints connected to the body must be removed before the body.
     *
     * @method removeBody
     * @param {Body} body
     *
     * @example
     *     var removeBody;
     *     world.on("beginContact",function(event){
     *         // We cannot remove the body here since the world is still stepping.
     *         // Instead, schedule the body to be removed after the step is done.
     *         removeBody = body;
     *     });
     *     world.on("postStep",function(event){
     *         if(removeBody){
     *             // Safely remove the body from the world.
     *             world.removeBody(removeBody);
     *             removeBody = null;
     *         }
     *     });
     */
    World.prototype.removeBody = function (body) {
        if (this.stepping) {
            throw new Error('Bodies cannot be removed during step.');
        }
        // TODO: would it be smart to have a .constraints array on the body?
        var constraints = this.constraints;
        var l = constraints.length;
        while (l--) {
            if (constraints[l].bodyA === body || constraints[l].bodyB === body) {
                throw new Error('Cannot remove Body from World: it still has constraints connected to it.');
            }
        }
        body.world = null;
        var bodies = this.bodies;
        utils_1.default.arrayRemove(bodies, body);
        body.index = -1;
        var l = bodies.length;
        while (l--) {
            bodies[l].index = l;
        }
        // Emit removeBody event
        removeBodyEvent.body = body;
        body.resetConstraintVelocity();
        this.emit(removeBodyEvent);
        removeBodyEvent.body = null;
        // Remove disabled body collision pairs that involve body
        var pairs = this.disabledBodyCollisionPairs;
        var i = 0;
        while (i < pairs.length) {
            if (pairs[i] === body || pairs[i + 1] === body) {
                pairs.splice(i, 2);
            }
            else {
                i += 2;
            }
        }
    };
    /**
     * Get a body by its id.
     * @method getBodyById
     * @param {number} id
     * @return {Body} The body, or false if it was not found.
     */
    World.prototype.getBodyById = function (id) {
        var bodies = this.bodies;
        for (var i = 0; i < bodies.length; i++) {
            var b = bodies[i];
            if (b.id === id) {
                return b;
            }
        }
        return null;
    };
    /**
     * Disable collision between two bodies
     * @method disableBodyCollision
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    World.prototype.disableBodyCollision = function (bodyA, bodyB) {
        this.disabledBodyCollisionPairs.push(bodyA);
        this.disabledBodyCollisionPairs.push(bodyB);
    };
    /**
     * Enable collisions between the given two bodies, if they were previously disabled using .disableBodyCollision().
     * @method enableBodyCollision
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    World.prototype.enableBodyCollision = function (bodyA, bodyB) {
        var pairs = this.disabledBodyCollisionPairs;
        for (var i = 0; i < pairs.length; i += 2) {
            if ((pairs[i] === bodyA && pairs[i + 1] === bodyB) || (pairs[i + 1] === bodyA && pairs[i] === bodyB)) {
                pairs.splice(i, 2);
                return;
            }
        }
    };
    /**
     * Removes all bodies, constraints, springs, and contact materials from the world.
     * @method clear
     */
    World.prototype.clear = function () {
        // Remove all solver equations
        this.solver.removeAllEquations();
        // Remove all constraints
        var cs = this.constraints;
        var i = cs.length;
        while (i--) {
            this.removeConstraint(cs[i]);
        }
        // Remove all bodies
        var bodies = this.bodies;
        i = bodies.length;
        while (i--) {
            this.removeBody(bodies[i]);
        }
        // Remove all springs
        var springs = this.springs;
        i = springs.length;
        while (i--) {
            this.removeSpring(springs[i]);
        }
        // Remove all contact materials
        var cms = this.contactMaterials;
        i = cms.length;
        while (i--) {
            this.removeContactMaterial(cms[i]);
        }
    };
    /**
     * Test if a world point overlaps bodies
     * @method hitTest
     * @param  {Array} worldPoint Point to use for intersection tests
     * @param  {Array} bodies A list of objects to check for intersection
     * @param  {Number} precision Used for matching against particles and lines. Adds some margin to these infinitesimal objects.
     * @return {Array} Array of bodies that overlap the point
     * @todo Should use an api similar to the raycast function
     * @todo Should probably implement a .containsPoint method for all shapes. Would be more efficient
     * @todo Should use the broadphase
     * @todo Returning the hit shape would be fine - it carries a reference to the body now
     */
    World.prototype.hitTest = function (worldPoint, bodies, precision) {
        precision = precision || 0;
        // Create a dummy particle body with a particle shape to test against the bodies
        var shapeWorldPosition = hitTest_tmp1, shapeLocalPoint = hitTest_tmp2;
        var result = [];
        // Check bodies
        for (var i = 0, N = bodies.length; i !== N; i++) {
            var body = bodies[i];
            for (var j = 0, NS = body.shapes.length; j !== NS; j++) {
                var shape = body.shapes[j];
                // Get local point position in the shape
                shape.worldPointToLocal(shapeLocalPoint, worldPoint);
                if (shape.pointTest(shapeLocalPoint)) {
                    result.push(body);
                }
                else {
                    // Get shape world position
                    vec2_1.default.rotate(shapeWorldPosition, shape.position, body.angle);
                    vec2_1.default.add(shapeWorldPosition, shapeWorldPosition, body.position);
                    if (shape.type === shape_1.default.PARTICLE && vec2_1.default.squaredDistance(shapeWorldPosition, worldPoint) < precision * precision) {
                        result.push(body);
                    }
                }
            }
        }
        return result;
    };
    /**
     * Set the stiffness for all equations and contact materials.
     * @method setGlobalStiffness
     * @param {Number} stiffness
     */
    World.prototype.setGlobalStiffness = function (stiffness) {
        setGlobalEquationParams(this, { stiffness: stiffness });
        // Set for all contact materials
        var contactMaterials = this.contactMaterials;
        for (var i = 0; i !== contactMaterials.length; i++) {
            var c = contactMaterials[i];
            c.stiffness = c.frictionStiffness = stiffness;
        }
        // Set for default contact material
        var c = this.defaultContactMaterial;
        c.stiffness = c.frictionStiffness = stiffness;
    };
    /**
     * Set the relaxation for all equations and contact materials.
     * @method setGlobalRelaxation
     * @param {Number} relaxation
     */
    World.prototype.setGlobalRelaxation = function (relaxation) {
        setGlobalEquationParams(this, { relaxation: relaxation });
        // Set for all contact materials
        for (var i = 0; i !== this.contactMaterials.length; i++) {
            var c = this.contactMaterials[i];
            c.relaxation = c.frictionRelaxation = relaxation;
        }
        // Set for default contact material
        var c = this.defaultContactMaterial;
        c.relaxation = c.frictionRelaxation = relaxation;
    };
    /**
     * Ray cast against all bodies in the world.
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @return {boolean} True if any body was hit.
     *
     * @example
     *     var ray = new Ray({
     *         mode: Ray.CLOSEST, // or ANY
     *         from: [0, 0],
     *         to: [10, 0],
     *     });
     *     var result = new RaycastResult();
     *     world.raycast(result, ray);
     *
     *     // Get the hit point
     *     var hitPoint = vec2.create();
     *     result.getHitPoint(hitPoint, ray);
     *     console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));
     *
     * @example
     *     var ray = new Ray({
     *         mode: Ray.ALL,
     *         from: [0, 0],
     *         to: [10, 0],
     *         callback: function(result){
     *
     *             // Print some info about the hit
     *             console.log('Hit body and shape: ', result.body, result.shape);
     *
     *             // Get the hit point
     *             var hitPoint = vec2.create();
     *             result.getHitPoint(hitPoint, ray);
     *             console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));
     *
     *             // If you are happy with the hits you got this far, you can stop the traversal here:
     *             result.stop();
     *         }
     *     });
     *     var result = new RaycastResult();
     *     world.raycast(result, ray);
     */
    World.prototype.raycast = function (result, ray) {
        var tmpAABB = new aabb_1.default();
        var tmpArray = [];
        // Get all bodies within the ray AABB
        ray.getAABB(tmpAABB);
        this.broadphase.aabbQuery(this, tmpAABB, tmpArray);
        ray.intersectBodies(result, tmpArray);
        tmpArray.length = 0;
        return result.hasHit();
    };
    /**
     * Never deactivate bodies.
     * @static
     * @property {number} NO_SLEEPING
     */
    World.NO_SLEEPING = 1;
    /**
     * Deactivate individual bodies if they are sleepy.
     * @static
     * @property {number} BODY_SLEEPING
     */
    World.BODY_SLEEPING = 2;
    /**
     * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink "World/islandSplit:property"}}.islandSplit{{/crossLink}} for this to work.
     * @static
     * @property {number} ISLAND_SLEEPING
     */
    World.ISLAND_SLEEPING = 4;
    return World;
}(event_emitter_1.default));
exports.default = World;

},{"../collision/aabb":1,"../collision/narrowphase":4,"../collision/sap-broadphase":7,"../events/event-emitter":21,"../material/contact-material":24,"../material/material":25,"../math/vec2":28,"../objects/body":30,"../shapes/shape":46,"../solver/gs-solver":47,"../utils/overlap-keeper":53,"../utils/utils":56,"./union-find":57}]},{},[22])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcam9zaF9cXE9uZURyaXZlXFxEZXNrdG9wXFxQUk9KRUNUU1xcR0lUSFVCXFxnZWFyYm94MmRcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vYWFiYi5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vYnJvYWRwaGFzZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vbmFpdmUtYnJvYWRwaGFzZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vbmFycm93cGhhc2UuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvY29sbGlzaW9uL3JheS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vcmF5Y2FzdC1yZXN1bHQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvY29sbGlzaW9uL3NhcC1icm9hZHBoYXNlLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2NvbnN0cmFpbnRzL2NvbnN0cmFpbnQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvY29uc3RyYWludHMvZGlzdGFuY2UtY29uc3RyYWludC5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb25zdHJhaW50cy9nZWFyLWNvbnN0cmFpbnQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvY29uc3RyYWludHMvbG9jay1jb25zdHJhaW50LmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2NvbnN0cmFpbnRzL3ByaXNtYXRpYy1jb25zdHJhaW50LmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2NvbnN0cmFpbnRzL3Jldm9sdXRlLWNvbnN0cmFpbnQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvZXF1YXRpb25zL0VxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2VxdWF0aW9ucy9hbmdsZS1sb2NrLWVxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2VxdWF0aW9ucy9jb250YWN0LWVxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2VxdWF0aW9ucy9mcmljdGlvbi1lcXVhdGlvbi5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9lcXVhdGlvbnMvcm90YXRpb25hbC1sb2NrLWVxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2VxdWF0aW9ucy9yb3RhdGlvbmFsLXZlbG9jaXR5LWVxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2V2ZW50cy9ldmVudC1lbWl0dGVyLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2luZGV4LmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL21hdGVyaWFsL01hdGVyaWFsLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL21hdGVyaWFsL2NvbnRhY3QtbWF0ZXJpYWwuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvbWF0aC9wb2x5LWRlY29tcC5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9tYXRoL3BvbHlrLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL21hdGgvdmVjMi5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9vYmplY3RzL0JvZHkuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvb2JqZWN0cy9saW5lYXItc3ByaW5nLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL29iamVjdHMvcm90YXRpb25hbC1zcHJpbmcuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvb2JqZWN0cy9zcHJpbmcuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvb2JqZWN0cy90b3AtZG93bi12ZWhpY2xlLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3NoYXBlcy9Cb3guanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvc2hhcGVzL0NpcmNsZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9zaGFwZXMvQ29udmV4LmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3NoYXBlcy9TaGFwZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9zaGFwZXMvY2Fwc3VsZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9zaGFwZXMvaGVpZ2h0ZmllbGQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvc2hhcGVzL2xpbmUuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvc2hhcGVzL3BhcnRpY2xlLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3NoYXBlcy9wbGFuZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9zb2x2ZXIvZ3Mtc29sdmVyLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3NvbHZlci9zb2x2ZXIuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvdXRpbHMvY29udGFjdC1lcXVhdGlvbi1wb29sLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3V0aWxzL2ZyaWN0aW9uLWVxdWF0aW9uLXBvb2wuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvdXRpbHMvb3ZlcmxhcC1rZWVwZXItcmVjb3JkLXBvb2wuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvdXRpbHMvb3ZlcmxhcC1rZWVwZXItcmVjb3JkLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3V0aWxzL292ZXJsYXAta2VlcGVyLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3V0aWxzL3Bvb2wuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvdXRpbHMvdHVwbGUtZGljdGlvbmFyeS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC91dGlscy91dGlscy5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC93b3JsZC91bmlvbi1maW5kLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3dvcmxkL3dvcmxkLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3h6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaHFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIEFBQkIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggY2xhc3MuXHJcbiAgICAgKiBAY2xhc3MgQUFCQlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy51cHBlckJvdW5kXVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb3dlckJvdW5kXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYWFiYiA9IG5ldyBBQUJCKHtcclxuICAgICAqICAgICAgICAgdXBwZXJCb3VuZDogWzEsIDFdLFxyXG4gICAgICogICAgICAgICBsb3dlckJvdW5kOiBbLTEsIC0xXVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBQUJCKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnRtcCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIGJvdW5kaW5nIGJveC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgbG93ZXJCb3VuZFxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvd2VyQm91bmQgPSBvcHRpb25zLmxvd2VyQm91bmQgPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLmxvd2VyQm91bmQpIDogdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXHJcbiAgICAgICAgICogQHByb3BlcnR5IHVwcGVyQm91bmRcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51cHBlckJvdW5kID0gb3B0aW9ucy51cHBlckJvdW5kID8gdmVjMl8xLmRlZmF1bHQuY2xvbmUob3B0aW9ucy51cHBlckJvdW5kKSA6IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIEFBQkIgYm91bmRzIGZyb20gYSBzZXQgb2YgcG9pbnRzLCB0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIGFuZ2xlLlxyXG4gICAgICogQG1ldGhvZCBzZXRGcm9tUG9pbnRzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQW4gYXJyYXkgb2YgdmVjMidzLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYW5nbGU9MF1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2tpblNpemU9MF0gU29tZSBtYXJnaW4gdG8gYmUgYWRkZWQgdG8gdGhlIEFBQkIuXHJcbiAgICAgKi9cclxuICAgIEFBQkIucHJvdG90eXBlLnNldEZyb21Qb2ludHMgPSBmdW5jdGlvbiAocG9pbnRzLCBwb3NpdGlvbiwgYW5nbGUsIHNraW5TaXplKSB7XHJcbiAgICAgICAgaWYgKHNraW5TaXplID09PSB2b2lkIDApIHsgc2tpblNpemUgPSAwOyB9XHJcbiAgICAgICAgdmFyIGwgPSB0aGlzLmxvd2VyQm91bmQsIHUgPSB0aGlzLnVwcGVyQm91bmQ7XHJcbiAgICAgICAgYW5nbGUgPSBhbmdsZSB8fCAwO1xyXG4gICAgICAgIC8vIFNldCB0byB0aGUgZmlyc3QgcG9pbnRcclxuICAgICAgICBpZiAoYW5nbGUgIT09IDApIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKGwsIHBvaW50c1swXSwgYW5nbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShsLCBwb2ludHNbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHUsIGwpO1xyXG4gICAgICAgIC8vIENvbXB1dGUgY29zaW5lcyBhbmQgc2luZXMganVzdCBvbmNlXHJcbiAgICAgICAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpLCBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcclxuICAgICAgICAgICAgaWYgKGFuZ2xlICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHBbMF0sIHkgPSBwWzFdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50bXBbMF0gPSBjb3NBbmdsZSAqIHggLSBzaW5BbmdsZSAqIHk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRtcFsxXSA9IHNpbkFuZ2xlICogeCArIGNvc0FuZ2xlICogeTtcclxuICAgICAgICAgICAgICAgIHAgPSB0aGlzLnRtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBbal0gPiB1W2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdVtqXSA9IHBbal07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocFtqXSA8IGxbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICBsW2pdID0gcFtqXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgb2Zmc2V0XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChsLCBsLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZCh1LCB1LCBwb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChza2luU2l6ZSkge1xyXG4gICAgICAgICAgICBsWzBdIC09IHNraW5TaXplO1xyXG4gICAgICAgICAgICBsWzFdIC09IHNraW5TaXplO1xyXG4gICAgICAgICAgICB1WzBdICs9IHNraW5TaXplO1xyXG4gICAgICAgICAgICB1WzFdICs9IHNraW5TaXplO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvcHkgYm91bmRzIGZyb20gYW4gQUFCQiB0byB0aGlzIEFBQkJcclxuICAgICAqIEBtZXRob2QgY29weVxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gICAgICovXHJcbiAgICBBQUJCLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGFhYmIpIHtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHRoaXMubG93ZXJCb3VuZCwgYWFiYi5sb3dlckJvdW5kKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHRoaXMudXBwZXJCb3VuZCwgYWFiYi51cHBlckJvdW5kKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCB0aGlzIEFBQkIgc28gdGhhdCBpdCBjb3ZlcnMgdGhlIGdpdmVuIEFBQkIgdG9vLlxyXG4gICAgICogQG1ldGhvZCBleHRlbmRcclxuICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICAgICAqL1xyXG4gICAgQUFCQi5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKGFhYmIpIHtcclxuICAgICAgICB2YXIgbG93ZXIgPSB0aGlzLmxvd2VyQm91bmQsIHVwcGVyID0gdGhpcy51cHBlckJvdW5kO1xyXG4gICAgICAgIC8vIExvb3Agb3ZlciB4IGFuZCB5XHJcbiAgICAgICAgdmFyIGkgPSAyO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgLy8gRXh0ZW5kIGxvd2VyIGJvdW5kXHJcbiAgICAgICAgICAgIHZhciBsID0gYWFiYi5sb3dlckJvdW5kW2ldO1xyXG4gICAgICAgICAgICBpZiAobG93ZXJbaV0gPiBsKSB7XHJcbiAgICAgICAgICAgICAgICBsb3dlcltpXSA9IGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXBwZXJcclxuICAgICAgICAgICAgdmFyIHUgPSBhYWJiLnVwcGVyQm91bmRbaV07XHJcbiAgICAgICAgICAgIGlmICh1cHBlcltpXSA8IHUpIHtcclxuICAgICAgICAgICAgICAgIHVwcGVyW2ldID0gdTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBvdmVybGFwcyB0aGlzIEFBQkIuXHJcbiAgICAgKiBAbWV0aG9kIG92ZXJsYXBzXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBBQUJCLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uIChhYWJiKSB7XHJcbiAgICAgICAgdmFyIGwxID0gdGhpcy5sb3dlckJvdW5kLCB1MSA9IHRoaXMudXBwZXJCb3VuZCwgbDIgPSBhYWJiLmxvd2VyQm91bmQsIHUyID0gYWFiYi51cHBlckJvdW5kO1xyXG4gICAgICAgIC8vICAgICAgbDIgICAgICAgIHUyXHJcbiAgICAgICAgLy8gICAgICB8LS0tLS0tLS0tfFxyXG4gICAgICAgIC8vIHwtLS0tLS0tLXxcclxuICAgICAgICAvLyBsMSAgICAgICB1MVxyXG4gICAgICAgIHJldHVybiAoKGwyWzBdIDw9IHUxWzBdICYmIHUxWzBdIDw9IHUyWzBdKSB8fCAobDFbMF0gPD0gdTJbMF0gJiYgdTJbMF0gPD0gdTFbMF0pKSAmJlxyXG4gICAgICAgICAgICAoKGwyWzFdIDw9IHUxWzFdICYmIHUxWzFdIDw9IHUyWzFdKSB8fCAobDFbMV0gPD0gdTJbMV0gJiYgdTJbMV0gPD0gdTFbMV0pKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY29udGFpbnNQb2ludFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHBvaW50XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBBQUJCLnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgdmFyIGwgPSB0aGlzLmxvd2VyQm91bmQsIHUgPSB0aGlzLnVwcGVyQm91bmQ7XHJcbiAgICAgICAgcmV0dXJuIGxbMF0gPD0gcG9pbnRbMF0gJiYgcG9pbnRbMF0gPD0gdVswXSAmJiBsWzFdIDw9IHBvaW50WzFdICYmIHBvaW50WzFdIDw9IHVbMV07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiB0aGUgQUFCQiBpcyBoaXQgYnkgYSByYXkuXHJcbiAgICAgKiBAbWV0aG9kIG92ZXJsYXBzUmF5XHJcbiAgICAgKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtMSBpZiBubyBoaXQsIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSBpZiBoaXQsIGluZGljYXRpbmcgdGhlIHBvc2l0aW9uIGJldHdlZW4gdGhlIFwiZnJvbVwiIGFuZCBcInRvXCIgcG9pbnRzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYWFiYiA9IG5ldyBBQUJCKHtcclxuICAgICAqICAgICAgICAgdXBwZXJCb3VuZDogWzEsIDFdLFxyXG4gICAgICogICAgICAgICBsb3dlckJvdW5kOiBbLTEsIC0xXVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHZhciByYXkgPSBuZXcgUmF5KHtcclxuICAgICAqICAgICAgICAgZnJvbTogWy0yLCAwXSxcclxuICAgICAqICAgICAgICAgdG86IFswLCAwXVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHZhciBmcmFjdGlvbiA9IGFhYmIub3ZlcmxhcHNSYXkocmF5KTsgLy8gZnJhY3Rpb24gPT0gMC41XHJcbiAgICAgKi9cclxuICAgIEFBQkIucHJvdG90eXBlLm92ZXJsYXBzUmF5ID0gZnVuY3Rpb24gKHJheSkge1xyXG4gICAgICAgIC8vIHJheS5kaXJlY3Rpb24gaXMgdW5pdCBkaXJlY3Rpb24gdmVjdG9yIG9mIHJheVxyXG4gICAgICAgIHZhciBkaXJGcmFjWCA9IDEgLyByYXkuZGlyZWN0aW9uWzBdO1xyXG4gICAgICAgIHZhciBkaXJGcmFjWSA9IDEgLyByYXkuZGlyZWN0aW9uWzFdO1xyXG4gICAgICAgIC8vIHRoaXMubG93ZXJCb3VuZCBpcyB0aGUgY29ybmVyIG9mIEFBQkIgd2l0aCBtaW5pbWFsIGNvb3JkaW5hdGVzIC0gbGVmdCBib3R0b20sIHJ0IGlzIG1heGltYWwgY29ybmVyXHJcbiAgICAgICAgdmFyIGZyb20gPSByYXkuZnJvbTtcclxuICAgICAgICB2YXIgbG93ZXJCb3VuZCA9IHRoaXMubG93ZXJCb3VuZDtcclxuICAgICAgICB2YXIgdXBwZXJCb3VuZCA9IHRoaXMudXBwZXJCb3VuZDtcclxuICAgICAgICB2YXIgdDEgPSAobG93ZXJCb3VuZFswXSAtIGZyb21bMF0pICogZGlyRnJhY1g7XHJcbiAgICAgICAgdmFyIHQyID0gKHVwcGVyQm91bmRbMF0gLSBmcm9tWzBdKSAqIGRpckZyYWNYO1xyXG4gICAgICAgIHZhciB0MyA9IChsb3dlckJvdW5kWzFdIC0gZnJvbVsxXSkgKiBkaXJGcmFjWTtcclxuICAgICAgICB2YXIgdDQgPSAodXBwZXJCb3VuZFsxXSAtIGZyb21bMV0pICogZGlyRnJhY1k7XHJcbiAgICAgICAgdmFyIHRtaW4gPSBNYXRoLm1heChNYXRoLm1pbih0MSwgdDIpLCBNYXRoLm1pbih0MywgdDQpKTtcclxuICAgICAgICB2YXIgdG1heCA9IE1hdGgubWluKE1hdGgubWF4KHQxLCB0MiksIE1hdGgubWF4KHQzLCB0NCkpO1xyXG4gICAgICAgIC8vIGlmIHRtYXggPCAwLCByYXkgKGxpbmUpIGlzIGludGVyc2VjdGluZyBBQUJCLCBidXQgd2hvbGUgQUFCQiBpcyBiZWhpbmcgdXNcclxuICAgICAgICBpZiAodG1heCA8IDApIHtcclxuICAgICAgICAgICAgLy90ID0gdG1heDtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0bWluID4gdG1heCwgcmF5IGRvZXNuJ3QgaW50ZXJzZWN0IEFBQkJcclxuICAgICAgICBpZiAodG1pbiA+IHRtYXgpIHtcclxuICAgICAgICAgICAgLy90ID0gdG1heDtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG1pbiAvIHJheS5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFBQkI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFBQkI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBCb2R5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL29iamVjdHMvQm9keVwiKSk7XHJcbi8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBzdXBwb3NlZCB0byBiZSBhYnN0cmFjdC5cclxudmFyIEJyb2FkcGhhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb25zLiBEb24ndCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseS5cclxuICAgICAqIEBjbGFzcyBCcm9hZHBoYXNlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQnJvYWRwaGFzZSh0eXBlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJlc3VsdGluZyBvdmVybGFwcGluZyBwYWlycy4gV2lsbCBiZSBmaWxsZWQgd2l0aCByZXN1bHRzIGR1cmluZyAuZ2V0Q29sbGlzaW9uUGFpcnMoKS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgcmVzdWx0XHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVzdWx0ID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHdvcmxkIHRvIHNlYXJjaCBmb3IgY29sbGlzaW9uIHBhaXJzIGluLiBUbyBjaGFuZ2UgaXQsIHVzZSAuc2V0V29ybGQoKVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxyXG4gICAgICAgICAqIEB0eXBlIHtXb3JsZH1cclxuICAgICAgICAgKiBAcmVhZE9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndvcmxkID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYm91bmRpbmcgdm9sdW1lIHR5cGUgdG8gdXNlIGluIHRoZSBicm9hZHBoYXNlIGFsZ29yaXRobXMuIFNob3VsZCBiZSBzZXQgdG8gQnJvYWRwaGFzZS5BQUJCIG9yIEJyb2FkcGhhc2UuQk9VTkRJTkdfQ0lSQ0xFLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBib3VuZGluZ1ZvbHVtZVR5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJvdW5kaW5nVm9sdW1lVHlwZSA9IEJyb2FkcGhhc2UuQUFCQjtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IDE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgd29ybGQgdGhhdCB3ZSBhcmUgc2VhcmNoaW5nIGZvciBjb2xsaXNpb24gcGFpcnMgaW4uXHJcbiAgICAgKiBAbWV0aG9kIHNldFdvcmxkXHJcbiAgICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogbW92ZSB0byBjb25zdHJ1Y3RvciFcclxuICAgIEJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24gKHdvcmxkKSB7XHJcbiAgICAgICAgdGhpcy53b3JsZCA9IHdvcmxkO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qXHJcbiAgICAgKiBHZXQgYWxsIHBvdGVudGlhbCBpbnRlcnNlY3RpbmcgYm9keSBwYWlycy5cclxuICAgICAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcclxuICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZCBUaGUgd29ybGQgdG8gc2VhcmNoIGluLlxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSBib2RpZXMsIG9yZGVyZWQgaW4gcGFpcnMuIEV4YW1wbGU6IEEgcmVzdWx0IG9mIFthLGIsYyxkXSBtZWFucyB0aGF0IHRoZSBwb3RlbnRpYWwgcGFpcnMgYXJlOiAoYSxiKSwgKGMsZCkuXHJcbiAgICAgKi9cclxuICAgIEJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24gKHdvcmxkKSB7XHJcbiAgICAgICAgLy8gSSBndWVzcyB0aGlzIHNob3VsZCBiZSBvdmVycmlkZGVuP1xyXG4gICAgICAgIC8vIFRPRE86IHBvc3NpYmxlIGFic3RyYWN0IG1ldGhvZC5cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxyXG4gICAgICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBCcm9hZHBoYXNlLmJvdW5kaW5nUmFkaXVzQ2hlY2sgPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgdmFyIGQyID0gdmVjMl8xLmRlZmF1bHQuc3F1YXJlZERpc3RhbmNlKGJvZHlBLnBvc2l0aW9uLCBib2R5Qi5wb3NpdGlvbiksIHIgPSBib2R5QS5ib3VuZGluZ1JhZGl1cyArIGJvZHlCLmJvdW5kaW5nUmFkaXVzO1xyXG4gICAgICAgIHJldHVybiBkMiA8PSByICogcjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIEFBQkIgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxyXG4gICAgICogQG1ldGhvZCAgYWFiYkNoZWNrXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUJcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIEJyb2FkcGhhc2UuYWFiYkNoZWNrID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgIHJldHVybiBib2R5QS5nZXRBQUJCKCkub3ZlcmxhcHMoYm9keUIuZ2V0QUFCQigpKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGJvdW5kaW5nIHZvbHVtZXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxyXG4gICAgICogQG1ldGhvZCAgYm91bmRpbmdWb2x1bWVDaGVja1xyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBCcm9hZHBoYXNlLnByb3RvdHlwZS5ib3VuZGluZ1ZvbHVtZUNoZWNrID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmJvdW5kaW5nVm9sdW1lVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIEJyb2FkcGhhc2UuQk9VTkRJTkdfQ0lSQ0xFOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQnJvYWRwaGFzZS5ib3VuZGluZ1JhZGl1c0NoZWNrKGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBCcm9hZHBoYXNlLkFBQkI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBCcm9hZHBoYXNlLmFhYmJDaGVjayhib2R5QSwgYm9keUIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kaW5nIHZvbHVtZSB0eXBlIG5vdCByZWNvZ25pemVkOiAnICsgdGhpcy5ib3VuZGluZ1ZvbHVtZVR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gYm9kaWVzIGFyZSBhbGxvd2VkIHRvIGNvbGxpZGUgYXQgYWxsLlxyXG4gICAgICogQG1ldGhvZCAgY2FuQ29sbGlkZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBCcm9hZHBoYXNlLmNhbkNvbGxpZGUgPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgdmFyIEtJTkVNQVRJQyA9IEJvZHlfMS5kZWZhdWx0LktJTkVNQVRJQztcclxuICAgICAgICB2YXIgU1RBVElDID0gQm9keV8xLmRlZmF1bHQuU1RBVElDO1xyXG4gICAgICAgIHZhciB0eXBlQSA9IGJvZHlBLnR5cGU7XHJcbiAgICAgICAgdmFyIHR5cGVCID0gYm9keUIudHlwZTtcclxuICAgICAgICAvLyBDYW5ub3QgY29sbGlkZSBzdGF0aWMgYm9kaWVzXHJcbiAgICAgICAgaWYgKHR5cGVBID09PSBTVEFUSUMgJiYgdHlwZUIgPT09IFNUQVRJQykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbm5vdCBjb2xsaWRlIHN0YXRpYyB2cyBraW5lbWF0aWMgYm9kaWVzXHJcbiAgICAgICAgaWYgKCh0eXBlQSA9PT0gS0lORU1BVElDICYmIHR5cGVCID09PSBTVEFUSUMpIHx8XHJcbiAgICAgICAgICAgICh0eXBlQSA9PT0gU1RBVElDICYmIHR5cGVCID09PSBLSU5FTUFUSUMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2Fubm90IGNvbGxpZGUga2luZW1hdGljIHZzIGtpbmVtYXRpY1xyXG4gICAgICAgIGlmICh0eXBlQSA9PT0gS0lORU1BVElDICYmIHR5cGVCID09PSBLSU5FTUFUSUMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYW5ub3QgY29sbGlkZSBib3RoIHNsZWVwaW5nIGJvZGllc1xyXG4gICAgICAgIGlmIChib2R5QS5zbGVlcFN0YXRlID09PSBCb2R5XzEuZGVmYXVsdC5TTEVFUElORyAmJiBib2R5Qi5zbGVlcFN0YXRlID09PSBCb2R5XzEuZGVmYXVsdC5TTEVFUElORykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbm5vdCBjb2xsaWRlIGlmIG9uZSBpcyBzdGF0aWMgYW5kIHRoZSBvdGhlciBpcyBzbGVlcGluZ1xyXG4gICAgICAgIGlmICgoYm9keUEuc2xlZXBTdGF0ZSA9PT0gQm9keV8xLmRlZmF1bHQuU0xFRVBJTkcgJiYgdHlwZUIgPT09IFNUQVRJQykgfHxcclxuICAgICAgICAgICAgKGJvZHlCLnNsZWVwU3RhdGUgPT09IEJvZHlfMS5kZWZhdWx0LlNMRUVQSU5HICYmIHR5cGVBID09PSBTVEFUSUMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxyXG4gICAgICogQG1ldGhvZCBhYWJiUXVlcnlcclxuICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gICAgICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXHJcbiAgICAgKiBAcmV0dXJuIHthcnJheX1cclxuICAgICAqL1xyXG4gICAgQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24gKHdvcmxkLCBhYWJiLCByZXN1bHQpIHtcclxuICAgICAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzXHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLy8gTW9kZTpcclxuICAgIEJyb2FkcGhhc2UuTkFJVkUgPSAxO1xyXG4gICAgQnJvYWRwaGFzZS5TQVAgPSAyO1xyXG4gICAgLy8gQm91bmRpbmcgYm94OlxyXG4gICAgLyoqXHJcbiAgICAgKiBBeGlzIGFsaWduZWQgYm91bmRpbmcgYm94IHR5cGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQUFCQlxyXG4gICAgICovXHJcbiAgICBCcm9hZHBoYXNlLkFBQkIgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCb3VuZGluZyBjaXJjbGUgdHlwZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBCT1VORElOR19DSVJDTEVcclxuICAgICAqL1xyXG4gICAgQnJvYWRwaGFzZS5CT1VORElOR19DSVJDTEUgPSAyO1xyXG4gICAgcmV0dXJuIEJyb2FkcGhhc2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJyb2FkcGhhc2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBicm9hZHBoYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYnJvYWRwaGFzZVwiKSk7XHJcbnZhciBOYWl2ZUJyb2FkcGhhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTmFpdmVCcm9hZHBoYXNlLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYWl2ZSBicm9hZHBoYXNlIGltcGxlbWVudGF0aW9uLiBEb2VzIE5eMiB0ZXN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgTmFpdmVCcm9hZHBoYXNlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIEJyb2FkcGhhc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTmFpdmVCcm9hZHBoYXNlKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBicm9hZHBoYXNlXzEuZGVmYXVsdC5OQUlWRSkgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjb2xsaWRpbmcgcGFpcnNcclxuICAgICAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcclxuICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIE5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbiAod29ybGQpIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLCByZXN1bHQgPSB0aGlzLnJlc3VsdDtcclxuICAgICAgICByZXN1bHQubGVuZ3RoID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgTmNvbGxpZGluZyA9IGJvZGllcy5sZW5ndGg7IGkgIT09IE5jb2xsaWRpbmc7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmogPSBib2RpZXNbal07XHJcbiAgICAgICAgICAgICAgICBpZiAoYnJvYWRwaGFzZV8xLmRlZmF1bHQuY2FuQ29sbGlkZShiaSwgYmopICYmIHRoaXMuYm91bmRpbmdWb2x1bWVDaGVjayhiaSwgYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gYW4gQUFCQi5cclxuICAgICAqIEBtZXRob2QgYWFiYlF1ZXJ5XHJcbiAgICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxyXG4gICAgICogQHJldHVybiB7YXJyYXl9XHJcbiAgICAgKi9cclxuICAgIE5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24gKHdvcmxkLCBhYWJiLCByZXN1bHQpIHtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHdvcmxkLmJvZGllcztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgaWYgKGIuYWFiYk5lZWRzVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBiLnVwZGF0ZUFBQkIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBOYWl2ZUJyb2FkcGhhc2U7XHJcbn0oYnJvYWRwaGFzZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTmFpdmVCcm9hZHBoYXNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgc3ViID0gdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QsIGFkZCA9IHZlYzJfMS5kZWZhdWx0LmFkZCwgZG90ID0gdmVjMl8xLmRlZmF1bHQuZG90LCByb3RhdGUgPSB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUsIG5vcm1hbGl6ZSA9IHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZSwgY29weSA9IHZlYzJfMS5kZWZhdWx0LmNvcHksIHNjYWxlID0gdmVjMl8xLmRlZmF1bHQuc2NhbGUsIHNxdWFyZWRMZW5ndGggPSB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkTGVuZ3RoLCBjcmVhdGVWZWMyID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlO1xyXG52YXIgQ2lyY2xlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYXBlcy9DaXJjbGVcIikpO1xyXG52YXIgQ29udmV4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYXBlcy9Db252ZXhcIikpO1xyXG52YXIgQm94XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYXBlcy9Cb3hcIikpO1xyXG52YXIgY29udGFjdF9lcXVhdGlvbl9wb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL2NvbnRhY3QtZXF1YXRpb24tcG9vbFwiKSk7XHJcbnZhciBmcmljdGlvbl9lcXVhdGlvbl9wb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL2ZyaWN0aW9uLWVxdWF0aW9uLXBvb2xcIikpO1xyXG52YXIgdHVwbGVfZGljdGlvbmFyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy90dXBsZS1kaWN0aW9uYXJ5XCIpKTtcclxudmFyIHlBeGlzID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygwLCAxKTtcclxudmFyIHRtcDEgPSBjcmVhdGVWZWMyKCksIHRtcDIgPSBjcmVhdGVWZWMyKCksIHRtcDMgPSBjcmVhdGVWZWMyKCksIHRtcDQgPSBjcmVhdGVWZWMyKCksIHRtcDUgPSBjcmVhdGVWZWMyKCksIHRtcDYgPSBjcmVhdGVWZWMyKCksIHRtcDcgPSBjcmVhdGVWZWMyKCksIHRtcDggPSBjcmVhdGVWZWMyKCksIHRtcDkgPSBjcmVhdGVWZWMyKCksIHRtcDEwID0gY3JlYXRlVmVjMigpLCB0bXAxMSA9IGNyZWF0ZVZlYzIoKSwgdG1wMTIgPSBjcmVhdGVWZWMyKCksIHRtcDEzID0gY3JlYXRlVmVjMigpLCB0bXAxNCA9IGNyZWF0ZVZlYzIoKSwgdG1wMTUgPSBjcmVhdGVWZWMyKCksIHRtcEFycmF5ID0gW107XHJcbnZhciBmaW5kTWF4U2VwYXJhdGlvbl9uID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBmaW5kTWF4U2VwYXJhdGlvbl92MSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgZmluZE1heFNlcGFyYXRpb25fdG1wID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBmaW5kTWF4U2VwYXJhdGlvbl90bXAyID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBmaW5kSW5jaWRlbnRFZGdlX25vcm1hbDEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGNvbGxpZGVQb2x5Z29uc190ZW1wVmVjID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfdG1wVmVjID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfbG9jYWxUYW5nZW50ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfbG9jYWxOb3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGNvbGxpZGVQb2x5Z29uc19wbGFuZVBvaW50ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfdGFuZ2VudCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX25vcm1hbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX25lZ2F0aXZlVGFuZ2VudCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX3YxMSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX3YxMiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX2Rpc3QgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGNvbGxpZGVQb2x5Z29uc19jbGlwUG9pbnRzMSA9IFt2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCldO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX2NsaXBQb2ludHMyID0gW3ZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKV07XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfaW5jaWRlbnRFZGdlID0gW3ZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKV07XHJcbnZhciBwaWNfbG9jYWxQb2ludCA9IGNyZWF0ZVZlYzIoKSwgcGljX3IwID0gY3JlYXRlVmVjMigpLCBwaWNfcjEgPSBjcmVhdGVWZWMyKCk7XHJcbnZhciBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25BID0gY3JlYXRlVmVjMigpLCBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25CID0gY3JlYXRlVmVjMigpO1xyXG52YXIgY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzEgPSBjcmVhdGVWZWMyKCksIGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMyID0gY3JlYXRlVmVjMigpO1xyXG52YXIgY29udmV4Q2Fwc3VsZV90ZW1wVmVjID0gY3JlYXRlVmVjMigpO1xyXG52YXIgcGxhbmVDYXBzdWxlX3RtcDEgPSBjcmVhdGVWZWMyKCksIHBsYW5lQ2Fwc3VsZV90bXAyID0gY3JlYXRlVmVjMigpO1xyXG52YXIgY2lyY2xlSGVpZ2h0ZmllbGRfY2FuZGlkYXRlID0gY3JlYXRlVmVjMigpLCBjaXJjbGVIZWlnaHRmaWVsZF9kaXN0ID0gY3JlYXRlVmVjMigpLCBjaXJjbGVIZWlnaHRmaWVsZF92MCA9IGNyZWF0ZVZlYzIoKSwgY2lyY2xlSGVpZ2h0ZmllbGRfdjEgPSBjcmVhdGVWZWMyKCksIGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZSA9IGNyZWF0ZVZlYzIoKSwgY2lyY2xlSGVpZ2h0ZmllbGRfd29ybGROb3JtYWwgPSBjcmVhdGVWZWMyKCksIGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZU5vcm1hbCA9IGNyZWF0ZVZlYzIoKTtcclxudmFyIGNvbnZleEhlaWdodGZpZWxkX3YwID0gY3JlYXRlVmVjMigpLCBjb252ZXhIZWlnaHRmaWVsZF92MSA9IGNyZWF0ZVZlYzIoKSwgY29udmV4SGVpZ2h0ZmllbGRfdGlsZVBvcyA9IGNyZWF0ZVZlYzIoKSwgY29udmV4SGVpZ2h0ZmllbGRfdGVtcENvbnZleFNoYXBlID0gbmV3IENvbnZleF8xLmRlZmF1bHQodW5kZWZpbmVkLCBbY3JlYXRlVmVjMigpLCBjcmVhdGVWZWMyKCksIGNyZWF0ZVZlYzIoKSwgY3JlYXRlVmVjMigpXSk7XHJcbmZ1bmN0aW9uIHNldENvbnZleFRvQ2Fwc3VsZVNoYXBlTWlkZGxlKGNvbnZleFNoYXBlLCBjYXBzdWxlU2hhcGUpIHtcclxuICAgIHZhciBjYXBzdWxlUmFkaXVzID0gY2Fwc3VsZVNoYXBlLnJhZGl1cztcclxuICAgIHZhciBoYWxmQ2Fwc3VsZUxlbmd0aCA9IGNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjU7XHJcbiAgICB2YXIgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcztcclxuICAgIHZlYzJfMS5kZWZhdWx0LnNldCh2ZXJ0c1swXSwgLWhhbGZDYXBzdWxlTGVuZ3RoLCAtY2Fwc3VsZVJhZGl1cyk7XHJcbiAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodmVydHNbMV0sIGhhbGZDYXBzdWxlTGVuZ3RoLCAtY2Fwc3VsZVJhZGl1cyk7XHJcbiAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodmVydHNbMl0sIGhhbGZDYXBzdWxlTGVuZ3RoLCBjYXBzdWxlUmFkaXVzKTtcclxuICAgIHZlYzJfMS5kZWZhdWx0LnNldCh2ZXJ0c1szXSwgLWhhbGZDYXBzdWxlTGVuZ3RoLCBjYXBzdWxlUmFkaXVzKTtcclxufVxyXG4vKlxyXG4qIENoZWNrIGlmIGEgcG9pbnQgaXMgaW4gYSBwb2x5Z29uXHJcbiovXHJcbmZ1bmN0aW9uIHBvaW50SW5Db252ZXgod29ybGRQb2ludCwgY29udmV4U2hhcGUsIGNvbnZleE9mZnNldCwgY29udmV4QW5nbGUpIHtcclxuICAgIHZhciBsb2NhbFBvaW50ID0gcGljX2xvY2FsUG9pbnQsIHIwID0gcGljX3IwLCByMSA9IHBpY19yMSwgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcywgbGFzdENyb3NzID0gbnVsbDtcclxuICAgIHZlYzJfMS5kZWZhdWx0LnRvTG9jYWxGcmFtZShsb2NhbFBvaW50LCB3b3JsZFBvaW50LCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBudW1WZXJ0cyA9IHZlcnRzLmxlbmd0aDsgaSAhPT0gbnVtVmVydHMgKyAxOyBpKyspIHtcclxuICAgICAgICB2YXIgdjAgPSB2ZXJ0c1tpICUgbnVtVmVydHNdLCB2MSA9IHZlcnRzWyhpICsgMSkgJSBudW1WZXJ0c107XHJcbiAgICAgICAgc3ViKHIwLCB2MCwgbG9jYWxQb2ludCk7XHJcbiAgICAgICAgc3ViKHIxLCB2MSwgbG9jYWxQb2ludCk7XHJcbiAgICAgICAgdmFyIGNyb3NzID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocjAsIHIxKTtcclxuICAgICAgICBpZiAobGFzdENyb3NzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxhc3RDcm9zcyA9IGNyb3NzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB3ZSBnb3QgYSBkaWZmZXJlbnQgc2lnbiBvZiB0aGUgZGlzdGFuY2UgdmVjdG9yLCB0aGUgcG9pbnQgaXMgb3V0IG9mIHRoZSBwb2x5Z29uXHJcbiAgICAgICAgaWYgKGNyb3NzICogbGFzdENyb3NzIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RDcm9zcyA9IGNyb3NzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLypcclxuKiBDaGVjayBpZiBhIHBvaW50IGlzIGluIGEgcG9seWdvblxyXG4qL1xyXG5mdW5jdGlvbiBwb2ludEluQ29udmV4TG9jYWwobG9jYWxQb2ludCwgY29udmV4U2hhcGUpIHtcclxuICAgIHZhciByMCA9IHBpY19yMCwgcjEgPSBwaWNfcjEsIHZlcnRzID0gY29udmV4U2hhcGUudmVydGljZXMsIGxhc3RDcm9zcyA9IG51bGwsIG51bVZlcnRzID0gdmVydHMubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WZXJ0cyArIDE7IGkrKykge1xyXG4gICAgICAgIHZhciB2MCA9IHZlcnRzW2kgJSBudW1WZXJ0c10sIHYxID0gdmVydHNbKGkgKyAxKSAlIG51bVZlcnRzXTtcclxuICAgICAgICBzdWIocjAsIHYwLCBsb2NhbFBvaW50KTtcclxuICAgICAgICBzdWIocjEsIHYxLCBsb2NhbFBvaW50KTtcclxuICAgICAgICB2YXIgY3Jvc3MgPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyMCwgcjEpO1xyXG4gICAgICAgIGlmIChsYXN0Q3Jvc3MgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgbGFzdENyb3NzID0gY3Jvc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGdvdCBhIGRpZmZlcmVudCBzaWduIG9mIHRoZSBkaXN0YW5jZSB2ZWN0b3IsIHRoZSBwb2ludCBpcyBvdXQgb2YgdGhlIHBvbHlnb25cclxuICAgICAgICBpZiAoY3Jvc3MgKiBsYXN0Q3Jvc3MgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGFzdENyb3NzID0gY3Jvc3M7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBhZGRTdWIob3V0LCBhLCBiLCBjKSB7XHJcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXSAtIGNbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXSAtIGNbMV07XHJcbn1cclxuZnVuY3Rpb24gZmluZE1heFNlcGFyYXRpb24obWF4U2VwYXJhdGlvbk91dCwgcG9seTEsIHBvc2l0aW9uMSwgYW5nbGUxLCBwb2x5MiwgcG9zaXRpb24yLCBhbmdsZTIpIHtcclxuICAgIC8vIEZpbmQgdGhlIG1heCBzZXBhcmF0aW9uIGJldHdlZW4gcG9seTEgYW5kIHBvbHkyIHVzaW5nIGVkZ2Ugbm9ybWFscyBmcm9tIHBvbHkxLlxyXG4gICAgdmFyIGNvdW50MSA9IHBvbHkxLnZlcnRpY2VzLmxlbmd0aDtcclxuICAgIHZhciBjb3VudDIgPSBwb2x5Mi52ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICB2YXIgbjFzID0gcG9seTEubm9ybWFscztcclxuICAgIHZhciB2MXMgPSBwb2x5MS52ZXJ0aWNlcztcclxuICAgIHZhciB2MnMgPSBwb2x5Mi52ZXJ0aWNlcztcclxuICAgIHZhciBuID0gZmluZE1heFNlcGFyYXRpb25fbjtcclxuICAgIHZhciB2MSA9IGZpbmRNYXhTZXBhcmF0aW9uX3YxO1xyXG4gICAgdmFyIHRtcCA9IGZpbmRNYXhTZXBhcmF0aW9uX3RtcDtcclxuICAgIHZhciB0bXAyID0gZmluZE1heFNlcGFyYXRpb25fdG1wMjtcclxuICAgIHZhciBhbmdsZSA9IGFuZ2xlMSAtIGFuZ2xlMjtcclxuICAgIHZhciBiZXN0SW5kZXggPSAwO1xyXG4gICAgdmFyIG1heFNlcGFyYXRpb24gPSAtSW5maW5pdHk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50MTsgKytpKSB7XHJcbiAgICAgICAgLy8gR2V0IHBvbHkxIG5vcm1hbCBpbiBmcmFtZTIuXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKG4sIG4xc1tpXSwgYW5nbGUpO1xyXG4gICAgICAgIC8vIEdldCBwb2x5MSB2ZXJ0ZXggaW4gZnJhbWUyXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh0bXAyLCB2MXNbaV0sIHBvc2l0aW9uMSwgYW5nbGUxKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUodjEsIHRtcDIsIHBvc2l0aW9uMiwgYW5nbGUyKTtcclxuICAgICAgICAvLyBGaW5kIGRlZXBlc3QgcG9pbnQgZm9yIG5vcm1hbCBpLlxyXG4gICAgICAgIHZhciBzaSA9IEluZmluaXR5O1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQyOyArK2opIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QodG1wLCB2MnNbal0sIHYxKTtcclxuICAgICAgICAgICAgdmFyIHNpaiA9IHZlYzJfMS5kZWZhdWx0LmRvdChuLCB0bXApO1xyXG4gICAgICAgICAgICBpZiAoc2lqIDwgc2kpIHtcclxuICAgICAgICAgICAgICAgIHNpID0gc2lqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaSA+IG1heFNlcGFyYXRpb24pIHtcclxuICAgICAgICAgICAgbWF4U2VwYXJhdGlvbiA9IHNpO1xyXG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFVzZSBhIHZlYzIgZm9yIHN0b3JpbmcgdGhlIGZsb2F0IHZhbHVlIGFuZCBhbHdheXMgcmV0dXJuIGludCwgZm9yIHBlcmZcclxuICAgIG1heFNlcGFyYXRpb25PdXRbMF0gPSBtYXhTZXBhcmF0aW9uO1xyXG4gICAgcmV0dXJuIGJlc3RJbmRleDtcclxufVxyXG5mdW5jdGlvbiBmaW5kSW5jaWRlbnRFZGdlKGNsaXBWZXJ0aWNlc091dCwgcG9seTEsIHBvc2l0aW9uMSwgYW5nbGUxLCBlZGdlMSwgcG9seTIsIHBvc2l0aW9uMiwgYW5nbGUyKSB7XHJcbiAgICB2YXIgbm9ybWFsczEgPSBwb2x5MS5ub3JtYWxzO1xyXG4gICAgdmFyIGNvdW50MiA9IHBvbHkyLnZlcnRpY2VzLmxlbmd0aDtcclxuICAgIHZhciB2ZXJ0aWNlczIgPSBwb2x5Mi52ZXJ0aWNlcztcclxuICAgIHZhciBub3JtYWxzMiA9IHBvbHkyLm5vcm1hbHM7XHJcbiAgICAvLyBHZXQgdGhlIG5vcm1hbCBvZiB0aGUgcmVmZXJlbmNlIGVkZ2UgaW4gcG9seTIncyBmcmFtZS5cclxuICAgIHZhciBub3JtYWwxID0gZmluZEluY2lkZW50RWRnZV9ub3JtYWwxO1xyXG4gICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKG5vcm1hbDEsIG5vcm1hbHMxW2VkZ2UxXSwgYW5nbGUxIC0gYW5nbGUyKTtcclxuICAgIC8vIEZpbmQgdGhlIGluY2lkZW50IGVkZ2Ugb24gcG9seTIuXHJcbiAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgdmFyIG1pbkRvdCA9IEluZmluaXR5O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDI7ICsraSkge1xyXG4gICAgICAgIHZhciBkb3RfMSA9IHZlYzJfMS5kZWZhdWx0LmRvdChub3JtYWwxLCBub3JtYWxzMltpXSk7XHJcbiAgICAgICAgaWYgKGRvdF8xIDwgbWluRG90KSB7XHJcbiAgICAgICAgICAgIG1pbkRvdCA9IGRvdF8xO1xyXG4gICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQnVpbGQgdGhlIGNsaXAgdmVydGljZXMgZm9yIHRoZSBpbmNpZGVudCBlZGdlLlxyXG4gICAgdmFyIGkxID0gaW5kZXg7XHJcbiAgICB2YXIgaTIgPSBpMSArIDEgPCBjb3VudDIgPyBpMSArIDEgOiAwO1xyXG4gICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZShjbGlwVmVydGljZXNPdXRbMF0sIHZlcnRpY2VzMltpMV0sIHBvc2l0aW9uMiwgYW5nbGUyKTtcclxuICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUoY2xpcFZlcnRpY2VzT3V0WzFdLCB2ZXJ0aWNlczJbaTJdLCBwb3NpdGlvbjIsIGFuZ2xlMik7XHJcbn1cclxuZnVuY3Rpb24gY2xpcFNlZ21lbnRUb0xpbmUodk91dCwgdkluLCBub3JtYWwsIG9mZnNldCkge1xyXG4gICAgLy8gU3RhcnQgd2l0aCBubyBvdXRwdXQgcG9pbnRzXHJcbiAgICB2YXIgbnVtT3V0ID0gMDtcclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugb2YgZW5kIHBvaW50cyB0byB0aGUgbGluZVxyXG4gICAgdmFyIGRpc3RhbmNlMCA9IHZlYzJfMS5kZWZhdWx0LmRvdChub3JtYWwsIHZJblswXSkgLSBvZmZzZXQ7XHJcbiAgICB2YXIgZGlzdGFuY2UxID0gdmVjMl8xLmRlZmF1bHQuZG90KG5vcm1hbCwgdkluWzFdKSAtIG9mZnNldDtcclxuICAgIC8vIElmIHRoZSBwb2ludHMgYXJlIGJlaGluZCB0aGUgcGxhbmVcclxuICAgIGlmIChkaXN0YW5jZTAgPD0gMC4wKSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh2T3V0W251bU91dCsrXSwgdkluWzBdKTtcclxuICAgIH1cclxuICAgIGlmIChkaXN0YW5jZTEgPD0gMC4wKSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh2T3V0W251bU91dCsrXSwgdkluWzFdKTtcclxuICAgIH1cclxuICAgIC8vIElmIHRoZSBwb2ludHMgYXJlIG9uIGRpZmZlcmVudCBzaWRlcyBvZiB0aGUgcGxhbmVcclxuICAgIGlmIChkaXN0YW5jZTAgKiBkaXN0YW5jZTEgPCAwLjApIHtcclxuICAgICAgICAvLyBGaW5kIGludGVyc2VjdGlvbiBwb2ludCBvZiBlZGdlIGFuZCBwbGFuZVxyXG4gICAgICAgIHZhciBpbnRlcnAgPSBkaXN0YW5jZTAgLyAoZGlzdGFuY2UwIC0gZGlzdGFuY2UxKTtcclxuICAgICAgICB2YXIgdiA9IHZPdXRbbnVtT3V0XTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdCh2LCB2SW5bMV0sIHZJblswXSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUodiwgdiwgaW50ZXJwKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQodiwgdiwgdkluWzBdKTtcclxuICAgICAgICArK251bU91dDtcclxuICAgIH1cclxuICAgIHJldHVybiBudW1PdXQ7XHJcbn1cclxudmFyIE5hcnJvd3BoYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXJyb3dwaGFzZS4gQ3JlYXRlcyBjb250YWN0cyBhbmQgZnJpY3Rpb24gZ2l2ZW4gc2hhcGVzIGFuZCB0cmFuc2Zvcm1zLlxyXG4gICAgICogQGNsYXNzIE5hcnJvd3BoYXNlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTmFycm93cGhhc2UoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IGNvbnRhY3RFcXVhdGlvbnNcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IGZyaWN0aW9uRXF1YXRpb25zXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRvIG1ha2UgZnJpY3Rpb24gZXF1YXRpb25zIGluIHRoZSB1cGNvbWluZyBjb250YWN0cy5cclxuICAgICAgICAgKiBAcHJvcGVydHkgZW5hYmxlRnJpY3Rpb25cclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRvIG1ha2UgZXF1YXRpb25zIGVuYWJsZWQgaW4gdXBjb21pbmcgY29udGFjdHMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGVuYWJsZWRFcXVhdGlvbnNcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZWRFcXVhdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmcmljdGlvbiBzbGlwIGZvcmNlIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGZyaWN0aW9uIGVxdWF0aW9ucy5cclxuICAgICAgICAgKiBAcHJvcGVydHkgc2xpcEZvcmNlXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNsaXBGb3JjZSA9IDEwLjA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGFsbG9jYXRlZCBDb250YWN0RXF1YXRpb25zLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdEVxdWF0aW9uUG9vbH0gY29udGFjdEVxdWF0aW9uUG9vbFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBBbGxvY2F0ZSBhIGZldyBlcXVhdGlvbnMgYmVmb3JlIHN0YXJ0aW5nIHRoZSBzaW11bGF0aW9uLlxyXG4gICAgICAgICAqICAgICAvLyBUaGlzIHdheSwgbm8gY29udGFjdCBvYmplY3RzIG5lZWQgdG8gYmUgY3JlYXRlZCBvbiB0aGUgZmx5IGluIHRoZSBnYW1lIGxvb3AuXHJcbiAgICAgICAgICogICAgIHdvcmxkLm5hcnJvd3BoYXNlLmNvbnRhY3RFcXVhdGlvblBvb2wucmVzaXplKDEwMjQpO1xyXG4gICAgICAgICAqICAgICB3b3JsZC5uYXJyb3dwaGFzZS5mcmljdGlvbkVxdWF0aW9uUG9vbC5yZXNpemUoMTAyNCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25Qb29sID0gbmV3IGNvbnRhY3RfZXF1YXRpb25fcG9vbF8xLmRlZmF1bHQoeyBzaXplOiAzMiB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgYWxsb2NhdGVkIENvbnRhY3RFcXVhdGlvbnMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtGcmljdGlvbkVxdWF0aW9uUG9vbH0gZnJpY3Rpb25FcXVhdGlvblBvb2xcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sID0gbmV3IGZyaWN0aW9uX2VxdWF0aW9uX3Bvb2xfMS5kZWZhdWx0KHsgc2l6ZTogNjQgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5hYmxlIHJlZHVjdGlvbiBvZiBmcmljdGlvbiBlcXVhdGlvbnMuIElmIGRpc2FibGVkLCBhIGJveCBvbiBhIHBsYW5lIHdpbGwgZ2VuZXJhdGUgMiBjb250YWN0IGVxdWF0aW9ucyBhbmQgMiBmcmljdGlvbiBlcXVhdGlvbnMuIElmIGVuYWJsZWQsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgZnJpY3Rpb24gZXF1YXRpb24uIFNhbWUga2luZCBvZiBzaW1wbGlmaWNhdGlvbnMgYXJlIG1hZGUgIGZvciBhbGwgY29sbGlzaW9uIHR5cGVzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBlbmFibGVGcmljdGlvblJlZHVjdGlvblxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFRoaXMgZmxhZyB3aWxsIGJlIHJlbW92ZWQgd2hlbiB0aGUgZmVhdHVyZSBpcyBzdGFibGUgZW5vdWdoLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY29sbGlkaW5nIGJvZGllcyBsYXN0IHN0ZXAuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcHJvcGVydHkgY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXBcclxuICAgICAgICAgKiBAdHlwZSB7VHVwbGVEaWN0aW9uYXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAgPSBuZXcgdHVwbGVfZGljdGlvbmFyeV8xLmRlZmF1bHQoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJvcGVydHkgY3VycmVudENvbnRhY3RNYXRlcmlhbFxyXG4gICAgICAgICAqIEB0eXBlIHtDb250YWN0TWF0ZXJpYWx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBib2RpZXNPdmVybGFwXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtjaGVja0NvbGxpc2lvbk1hc2tzPWZhbHNlXVxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmJvZGllc092ZXJsYXAgPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCLCBjaGVja0NvbGxpc2lvbk1hc2tzKSB7XHJcbiAgICAgICAgaWYgKGNoZWNrQ29sbGlzaW9uTWFza3MgPT09IHZvaWQgMCkgeyBjaGVja0NvbGxpc2lvbk1hc2tzID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgc2hhcGVQb3NpdGlvbkEgPSBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25BO1xyXG4gICAgICAgIHZhciBzaGFwZVBvc2l0aW9uQiA9IGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkI7XHJcbiAgICAgICAgLy8gTG9vcCBvdmVyIGFsbCBzaGFwZXMgb2YgYm9keUFcclxuICAgICAgICBmb3IgKHZhciBrID0gMCwgTnNoYXBlc2kgPSBib2R5QS5zaGFwZXMubGVuZ3RoOyBrICE9PSBOc2hhcGVzaTsgaysrKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZUEgPSBib2R5QS5zaGFwZXNba107XHJcbiAgICAgICAgICAgIC8vIEFsbCBzaGFwZXMgb2YgYm9keSBqXHJcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwLCBOc2hhcGVzaiA9IGJvZHlCLnNoYXBlcy5sZW5ndGg7IGwgIT09IE5zaGFwZXNqOyBsKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFwZUIgPSBib2R5Qi5zaGFwZXNbbF07XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBjb2xsaXNpb24gZ3JvdXBzIGFuZCBtYXNrc1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrQ29sbGlzaW9uTWFza3MgJiYgISgoc2hhcGVBLmNvbGxpc2lvbkdyb3VwICYgc2hhcGVCLmNvbGxpc2lvbk1hc2spICE9PSAwICYmIChzaGFwZUIuY29sbGlzaW9uR3JvdXAgJiBzaGFwZUEuY29sbGlzaW9uTWFzaykgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYm9keUEudG9Xb3JsZEZyYW1lKHNoYXBlUG9zaXRpb25BLCBzaGFwZUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgYm9keUIudG9Xb3JsZEZyYW1lKHNoYXBlUG9zaXRpb25CLCBzaGFwZUIucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudGVzdENvbnRhY3QoYm9keUEsIHNoYXBlQSwgc2hhcGVQb3NpdGlvbkEsIGJvZHlCLCBzaGFwZUIsIHNoYXBlUG9zaXRpb25CLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlIGJvZGllcyB3ZXJlIGluIGNvbnRhY3Qgc2luY2UgdGhlIGxhc3QgcmVzZXQoKS5cclxuICAgICAqIEBtZXRob2QgY29sbGlkZWRMYXN0U3RlcFxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY29sbGlkZWRMYXN0U3RlcCA9IGZ1bmN0aW9uIChib2R5QSwgYm9keUIpIHtcclxuICAgICAgICB2YXIgaWQxID0gYm9keUEuaWQgfCAwLCBpZDIgPSBib2R5Qi5pZCB8IDA7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5nZXQoaWQxLCBpZDIpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhyb3dzIGF3YXkgdGhlIG9sZCBlcXVhdGlvbnMgYW5kIGdldHMgcmVhZHkgdG8gY3JlYXRlIG5ld1xyXG4gICAgICogQG1ldGhvZCByZXNldFxyXG4gICAgICovXHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5yZXNldCgpO1xyXG4gICAgICAgIHZhciBlcXMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvbnM7XHJcbiAgICAgICAgdmFyIGwgPSBlcXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgdmFyIGVxID0gZXFzW2xdLCBpZDEgPSBlcS5ib2R5QS5pZCwgaWQyID0gZXEuYm9keUIuaWQ7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAuc2V0KGlkMSwgaWQyLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNlID0gdGhpcy5jb250YWN0RXF1YXRpb25zLCBmZSA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblBvb2wucmVsZWFzZShjZVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbC5yZWxlYXNlKGZlW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVzZXRcclxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggPSAwO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIENvbnRhY3RFcXVhdGlvbiwgZWl0aGVyIGJ5IHJldXNpbmcgYW4gZXhpc3Rpbmcgb2JqZWN0IG9yIGNyZWF0aW5nIGEgbmV3IG9uZS5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlQ29udGFjdEVxdWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUJcclxuICAgICAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvbn1cclxuICAgICAqL1xyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbiA9IGZ1bmN0aW9uIChib2R5QSwgYm9keUIsIHNoYXBlQSwgc2hhcGVCKSB7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvblBvb2wuZ2V0KCk7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRDb250YWN0TWF0ZXJpYWwgPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7XHJcbiAgICAgICAgYy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgICAgIGMuYm9keUIgPSBib2R5QjtcclxuICAgICAgICBjLnNoYXBlQSA9IHNoYXBlQTtcclxuICAgICAgICBjLnNoYXBlQiA9IHNoYXBlQjtcclxuICAgICAgICBjLmVuYWJsZWQgPSB0aGlzLmVuYWJsZWRFcXVhdGlvbnM7XHJcbiAgICAgICAgYy5maXJzdEltcGFjdCA9ICF0aGlzLmNvbGxpZGVkTGFzdFN0ZXAoYm9keUEsIGJvZHlCKTtcclxuICAgICAgICBjLnJlc3RpdHV0aW9uID0gY3VycmVudENvbnRhY3RNYXRlcmlhbC5yZXN0aXR1dGlvbjtcclxuICAgICAgICBjLnN0aWZmbmVzcyA9IGN1cnJlbnRDb250YWN0TWF0ZXJpYWwuc3RpZmZuZXNzO1xyXG4gICAgICAgIGMucmVsYXhhdGlvbiA9IGN1cnJlbnRDb250YWN0TWF0ZXJpYWwucmVsYXhhdGlvbjtcclxuICAgICAgICBjLm9mZnNldCA9IGN1cnJlbnRDb250YWN0TWF0ZXJpYWwuY29udGFjdFNraW5TaXplO1xyXG4gICAgICAgIGMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIEZyaWN0aW9uRXF1YXRpb24sIGVpdGhlciBieSByZXVzaW5nIGFuIGV4aXN0aW5nIG9iamVjdCBvciBjcmVhdGluZyBhIG5ldyBvbmUuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUZyaWN0aW9uRXF1YXRpb25cclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHJldHVybiB7RnJpY3Rpb25FcXVhdGlvbn1cclxuICAgICAqL1xyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24gPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCLCBzaGFwZUEsIHNoYXBlQikge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbC5nZXQoKTtcclxuICAgICAgICB2YXIgY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbDtcclxuICAgICAgICBjLmJvZHlBID0gYm9keUE7XHJcbiAgICAgICAgYy5ib2R5QiA9IGJvZHlCO1xyXG4gICAgICAgIGMuc2hhcGVBID0gc2hhcGVBO1xyXG4gICAgICAgIGMuc2hhcGVCID0gc2hhcGVCO1xyXG4gICAgICAgIGMuc2V0U2xpcEZvcmNlKHRoaXMuc2xpcEZvcmNlKTtcclxuICAgICAgICBjLmVuYWJsZWQgPSB0aGlzLmVuYWJsZWRFcXVhdGlvbnM7XHJcbiAgICAgICAgYy5mcmljdGlvbkNvZWZmaWNpZW50ID0gY3VycmVudENvbnRhY3RNYXRlcmlhbC5mcmljdGlvbjtcclxuICAgICAgICBjLnJlbGF0aXZlVmVsb2NpdHkgPSBjdXJyZW50Q29udGFjdE1hdGVyaWFsLnN1cmZhY2VWZWxvY2l0eTtcclxuICAgICAgICBjLnN0aWZmbmVzcyA9IGN1cnJlbnRDb250YWN0TWF0ZXJpYWwuZnJpY3Rpb25TdGlmZm5lc3M7XHJcbiAgICAgICAgYy5yZWxheGF0aW9uID0gY3VycmVudENvbnRhY3RNYXRlcmlhbC5mcmljdGlvblJlbGF4YXRpb247XHJcbiAgICAgICAgYy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgYy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgRnJpY3Rpb25FcXVhdGlvbiBnaXZlbiB0aGUgZGF0YSBpbiB0aGUgQ29udGFjdEVxdWF0aW9uLiBVc2VzIHNhbWUgb2Zmc2V0IHZlY3RvcnMgcmkgYW5kIHJqLCBidXQgdGhlIHRhbmdlbnQgdmVjdG9yIHdpbGwgYmUgY29uc3RydWN0ZWQgZnJvbSB0aGUgY29sbGlzaW9uIG5vcm1hbC5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdFxyXG4gICAgICogQHBhcmFtICB7Q29udGFjdEVxdWF0aW9ufSBjb250YWN0RXF1YXRpb25cclxuICAgICAqIEByZXR1cm4ge0ZyaWN0aW9uRXF1YXRpb259XHJcbiAgICAgKi9cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0ID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICB2YXIgZXEgPSB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24oYy5ib2R5QSwgYy5ib2R5QiwgYy5zaGFwZUEsIGMuc2hhcGVCKTtcclxuICAgICAgICBjb3B5KGVxLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSk7XHJcbiAgICAgICAgY29weShlcS5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZTkwY3coZXEudCwgYy5ub3JtYWxBKTtcclxuICAgICAgICBlcS5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XHJcbiAgICAgICAgcmV0dXJuIGVxO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8vIFRha2UgdGhlIGF2ZXJhZ2UgTiBsYXRlc3QgY29udGFjdCBwb2ludCBvbiB0aGUgcGxhbmUuXHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZSA9IGZ1bmN0aW9uIChudW1Db250YWN0cykge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5jb250YWN0RXF1YXRpb25zW3RoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggLSAxXTtcclxuICAgICAgICB2YXIgZXEgPSB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24oYy5ib2R5QSwgYy5ib2R5QiwgYy5zaGFwZUEsIGMuc2hhcGVCKTtcclxuICAgICAgICB2YXIgYm9keUEgPSBjLmJvZHlBO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChlcS5jb250YWN0UG9pbnRBLCAwLCAwKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQoZXEuY29udGFjdFBvaW50QiwgMCwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGVxLnQsIDAsIDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ29udGFjdHM7IGkrKykge1xyXG4gICAgICAgICAgICBjID0gdGhpcy5jb250YWN0RXF1YXRpb25zW3RoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggLSAxIC0gaV07XHJcbiAgICAgICAgICAgIGlmIChjLmJvZHlBID09PSBib2R5QSkge1xyXG4gICAgICAgICAgICAgICAgYWRkKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XHJcbiAgICAgICAgICAgICAgICBhZGQoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBKTtcclxuICAgICAgICAgICAgICAgIGFkZChlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3ViKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XHJcbiAgICAgICAgICAgICAgICBhZGQoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRCKTtcclxuICAgICAgICAgICAgICAgIGFkZChlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVxLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGludk51bUNvbnRhY3RzID0gMSAvIG51bUNvbnRhY3RzO1xyXG4gICAgICAgIHNjYWxlKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGludk51bUNvbnRhY3RzKTtcclxuICAgICAgICBzY2FsZShlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBpbnZOdW1Db250YWN0cyk7XHJcbiAgICAgICAgbm9ybWFsaXplKGVxLnQsIGVxLnQpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZTkwY3coZXEudCwgZXEudCk7XHJcbiAgICAgICAgcmV0dXJuIGVxO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS50ZXN0Q29udGFjdCA9IGZ1bmN0aW9uIChib2R5QSwgc2hhcGVBLCBvZmZzZXRBLCBib2R5Qiwgc2hhcGVCLCBvZmZzZXRCLCBqdXN0VGVzdFxyXG4gICAgLy8gbWV0YT86IHtcclxuICAgIC8vIFx0cmFkaXVzQT86IGYzMixcclxuICAgIC8vIFx0cmFkaXVzQj86IGYzMlxyXG4gICAgLy8gfVxyXG4gICAgKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IDA7XHJcbiAgICAgICAgaWYgKHNoYXBlQS50eXBlID4gc2hhcGVCLnR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGJUbXAgPSBib2R5QjtcclxuICAgICAgICAgICAgYm9keUIgPSBib2R5QTtcclxuICAgICAgICAgICAgYm9keUEgPSBiVG1wO1xyXG4gICAgICAgICAgICB2YXIgc1RtcCA9IHNoYXBlQjtcclxuICAgICAgICAgICAgc2hhcGVCID0gc2hhcGVBO1xyXG4gICAgICAgICAgICBzaGFwZUEgPSBzVG1wO1xyXG4gICAgICAgICAgICB2YXIgcFRtcCA9IG9mZnNldEI7XHJcbiAgICAgICAgICAgIG9mZnNldEIgPSBvZmZzZXRBO1xyXG4gICAgICAgICAgICBvZmZzZXRBID0gcFRtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChzaGFwZUEudHlwZSB8IHNoYXBlQi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTogeyAvLyBDaXJjbGUvY2lyY2xlXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNpcmNsZUNpcmNsZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlCLCBzYiwgb2Zmc2V0QiwganVzdFRlc3QsIHNhLnJhZGl1cywgc2IucmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMzogeyAvLyBQYXJ0aWNsZS9jaXJjbGUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNpcmNsZVBhcnRpY2xlKGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUIsIHNiLCBvZmZzZXRCLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDU6IHsgLy8gUGxhbmUvY2lyY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaXJjbGVQbGFuZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAzMzogLy8gQm94L2NpcmNsZS5cclxuICAgICAgICAgICAgY2FzZSA5OiB7IC8vIENvbnZleC9jaXJjbGUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNpcmNsZUNvbnZleChib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QsIHNhLnJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDE3OiB7IC8vIExpbmUvY2lyY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaXJjbGVMaW5lKGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLCBqdXN0VGVzdCwgMCwgc2EucmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgNjU6IHsgLy8gQ2Fwc3VsZS9jaXJjbGUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNpcmNsZUNhcHN1bGUoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMTI5OiB7IC8vIEhlaWdodGZpZWxkL2NpcmNsZS5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2lyY2xlSGVpZ2h0ZmllbGQoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5Qiwgc2IsIG9mZnNldEIsIGp1c3RUZXN0LCBzYS5yYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSA2OiB7IC8vIFBsYW5lL3BhcnRpY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJ0aWNsZVBsYW5lKGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDM0OiAvLyBCb3gvcGFydGljbGUuXHJcbiAgICAgICAgICAgIGNhc2UgMTA6IHsgLy8gQ29udmV4L3BhcnRpY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJ0aWNsZUNvbnZleChib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAxMDogeyAvLyBDYXBzdWxlL3BhcnRpY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJ0aWNsZUNhcHN1bGUoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMzY6IC8vIEJveC9wbGFuZS5cclxuICAgICAgICAgICAgY2FzZSAxMjogeyAvLyBDb252ZXgvcGxhbmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBsYW5lQ29udmV4KGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUEuYW5nbGUgKyBzYS5hbmdsZSwgYm9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDIwOiB7IC8vIExpbmUvcGxhbmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBsYW5lTGluZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlBLmFuZ2xlICsgc2EuYW5nbGUsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSA2ODogeyAvLyBDYXBzdWxlL3BsYW5lLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wbGFuZUNhcHN1bGUoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgNDA6IC8vIEJveC9jb252ZXguXHJcbiAgICAgICAgICAgIGNhc2UgODogeyAvLyBDb252ZXgvY29udmV4LlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb252ZXhDb252ZXgoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMjQ6IHsgLy8gTGluZS9jb252ZXguXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICAvLyBOT1QgU1VQUE9SVEVEIVxyXG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0ID0gdGhpcy5jb252ZXhMaW5lKGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUEuYW5nbGUgKyBzYS5hbmdsZSxcclxuICAgICAgICAgICAgICAgIC8vIFx0Ym9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLCBcclxuICAgICAgICAgICAgICAgIC8vIFx0anVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSA3MjogeyAvLyBDYXBzdWxlL2NvbnZleC5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29udmV4Q2Fwc3VsZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlBLmFuZ2xlICsgc2EuYW5nbGUsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAxMzY6IHsgLy8gSGVpZ2h0ZmllbGQvY29udmV4LlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb252ZXhIZWlnaHRmaWVsZChib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlBLmFuZ2xlICsgc2EuYW5nbGUsIGJvZHlCLCBzYiwgb2Zmc2V0QiwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAxNjogeyAvLyBMaW5lL2xpbmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICAvLyBOT1QgU1VQUE9SVEVEIVxyXG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0ID0gdGhpcy5saW5lTGluZShib2R5QSwgc2EsIHNoYXBlUG9zaXRpb25BLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgLy8gXHRib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsXHJcbiAgICAgICAgICAgICAgICAvLyBcdGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgNDg6IHsgLy8gQm94L2xpbmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICAvLyBOT1QgU1VQUE9SVEVEIVxyXG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0ID0gdGhpcy5saW5lQm94KGJvZHlBLCBzYSwgc2hhcGVQb3NpdGlvbkEsIGJvZHlBLmFuZ2xlICsgc2EuYW5nbGUsXHJcbiAgICAgICAgICAgICAgICAvLyBcdGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSxcclxuICAgICAgICAgICAgICAgIC8vIFx0anVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSA4MDogeyAvLyBDYXBzdWxlL2xpbmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICAvLyBOT1QgU1VQUE9SVEVEIVxyXG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0ID0gdGhpcy5saW5lQ2Fwc3VsZShib2R5QSwgc2EsIHNoYXBlUG9zaXRpb25BLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgLy8gXHRib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsXHJcbiAgICAgICAgICAgICAgICAvLyBcdGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgNjQ6IHsgLy8gQ2Fwc3VsZS9jYXBzdWxlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jYXBzdWxlQ2Fwc3VsZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlBLmFuZ2xlICsgc2EuYW5nbGUsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnZleC9saW5lIG5hcnJvd3BoYXNlXHJcbiAgICAgKiBAbWV0aG9kIGNvbnZleExpbmVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGNvbnZleEJvZHlcclxuICAgICAqIEBwYXJhbSAge0NvbnZleH0gICAgIGNvbnZleFNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBjb252ZXhPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGNvbnZleEFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBsaW5lQm9keVxyXG4gICAgICogQHBhcmFtICB7TGluZX0gICAgICAgbGluZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBsaW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBsaW5lQW5nbGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIGp1c3RUZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKiBAdG9kbyBJbXBsZW1lbnQgbWUhXHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLkxJTkVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhMaW5lID0gZnVuY3Rpb24gKFxyXG4gICAgLypcclxuICAgIGNvbnZleEJvZHksXHJcbiAgICBjb252ZXhTaGFwZSxcclxuICAgIGNvbnZleE9mZnNldCxcclxuICAgIGNvbnZleEFuZ2xlLFxyXG4gICAgbGluZUJvZHksXHJcbiAgICBsaW5lU2hhcGUsXHJcbiAgICBsaW5lT2Zmc2V0LFxyXG4gICAgbGluZUFuZ2xlLFxyXG4gICAganVzdFRlc3RcclxuICAgICovXHJcbiAgICApIHtcclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lL2JveCBuYXJyb3dwaGFzZVxyXG4gICAgICogQG1ldGhvZCBsaW5lQm94XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBsaW5lQm9keVxyXG4gICAgICogQHBhcmFtICB7TGluZX0gICAgICAgbGluZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBsaW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBsaW5lQW5nbGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJveEJvZHlcclxuICAgICAqIEBwYXJhbSAge0JveH0gIGJveFNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBib3hPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGJveEFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSAgICBqdXN0VGVzdFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICogQHRvZG8gSW1wbGVtZW50IG1lIVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FIHwgU2hhcGUuQk9YXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUJveCA9IGZ1bmN0aW9uIChcclxuICAgIC8qXHJcbiAgICBsaW5lQm9keSxcclxuICAgIGxpbmVTaGFwZSxcclxuICAgIGxpbmVPZmZzZXQsXHJcbiAgICBsaW5lQW5nbGUsXHJcbiAgICBib3hCb2R5LFxyXG4gICAgYm94U2hhcGUsXHJcbiAgICBib3hPZmZzZXQsXHJcbiAgICBib3hBbmdsZSxcclxuICAgIGp1c3RUZXN0XHJcbiAgICAqL1xyXG4gICAgKSB7XHJcbiAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmV4L2NhcHN1bGUgbmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgY29udmV4Q2Fwc3VsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgY29udmV4Qm9keVxyXG4gICAgICogQHBhcmFtICB7Q29udmV4fSAgICAgY29udmV4U2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgICAgIGNvbnZleFBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjb252ZXhBbmdsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgY2Fwc3VsZUJvZHlcclxuICAgICAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIGNhcHN1bGVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgY2Fwc3VsZVBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjYXBzdWxlQW5nbGVcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ09OVkVYIHwgU2hhcGUuQ0FQU1VMRV0gPVxyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQk9YIHwgU2hhcGUuQ0FQU1VMRV0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleENhcHN1bGUgPSBmdW5jdGlvbiAoY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleFBvc2l0aW9uLCBjb252ZXhBbmdsZSwgY2Fwc3VsZUJvZHksIGNhcHN1bGVTaGFwZSwgY2Fwc3VsZVBvc2l0aW9uLCBjYXBzdWxlQW5nbGUsIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdmFyIGNvbnZleENhcHN1bGVfdGVtcFJlY3QgPSBuZXcgQm94XzEuZGVmYXVsdCh7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfSk7XHJcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGNpcmNsZXNcclxuICAgICAgICAvLyBBZGQgb2Zmc2V0cyFcclxuICAgICAgICB2YXIgY2lyY2xlUG9zID0gY29udmV4Q2Fwc3VsZV90ZW1wVmVjO1xyXG4gICAgICAgIHZhciBoYWxmTGVuZ3RoID0gY2Fwc3VsZVNoYXBlLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGNpcmNsZVBvcywgaGFsZkxlbmd0aCwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZShjaXJjbGVQb3MsIGNpcmNsZVBvcywgY2Fwc3VsZVBvc2l0aW9uLCBjYXBzdWxlQW5nbGUpO1xyXG4gICAgICAgIHZhciByZXN1bHQxID0gdGhpcy5jaXJjbGVDb252ZXgoY2Fwc3VsZUJvZHksIGNhcHN1bGVTaGFwZSwgY2lyY2xlUG9zLCBjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4UG9zaXRpb24sIGNvbnZleEFuZ2xlLCBqdXN0VGVzdCwgY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGNpcmNsZVBvcywgLWhhbGZMZW5ndGgsIDApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUoY2lyY2xlUG9zLCBjaXJjbGVQb3MsIGNhcHN1bGVQb3NpdGlvbiwgY2Fwc3VsZUFuZ2xlKTtcclxuICAgICAgICB2YXIgcmVzdWx0MiA9IHRoaXMuY2lyY2xlQ29udmV4KGNhcHN1bGVCb2R5LCBjYXBzdWxlU2hhcGUsIGNpcmNsZVBvcywgY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleFBvc2l0aW9uLCBjb252ZXhBbmdsZSwganVzdFRlc3QsIGNhcHN1bGVTaGFwZS5yYWRpdXMpO1xyXG4gICAgICAgIGlmIChqdXN0VGVzdCAmJiAocmVzdWx0MSArIHJlc3VsdDIpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBjZW50ZXIgcmVjdFxyXG4gICAgICAgIHZhciByID0gY29udmV4Q2Fwc3VsZV90ZW1wUmVjdDtcclxuICAgICAgICBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShyLCBjYXBzdWxlU2hhcGUpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnZleENvbnZleChjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4UG9zaXRpb24sIGNvbnZleEFuZ2xlLCBjYXBzdWxlQm9keSwgciwgY2Fwc3VsZVBvc2l0aW9uLCBjYXBzdWxlQW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgcmVzdWx0MSArIHJlc3VsdDI7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYXBzdWxlL2xpbmUgbmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgbGluZUNhcHN1bGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGxpbmVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtMaW5lfSAgICAgICBsaW5lU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxpbmVQb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjYXBzdWxlQm9keVxyXG4gICAgICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgY2Fwc3VsZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBjYXBzdWxlUG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGNhcHN1bGVBbmdsZVxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICogQHRvZG8gSW1wbGVtZW50IG1lIVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FIHwgU2hhcGUuQ0FQU1VMRV0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmxpbmVDYXBzdWxlID0gZnVuY3Rpb24gKFxyXG4gICAgLypcclxuICAgIGxpbmVCb2R5LFxyXG4gICAgbGluZVNoYXBlLFxyXG4gICAgbGluZVBvc2l0aW9uLFxyXG4gICAgbGluZUFuZ2xlLFxyXG4gICAgY2Fwc3VsZUJvZHksXHJcbiAgICBjYXBzdWxlU2hhcGUsXHJcbiAgICBjYXBzdWxlUG9zaXRpb24sXHJcbiAgICBjYXBzdWxlQW5nbGUsXHJcbiAgICBqdXN0VGVzdFxyXG4gICAgKi9cclxuICAgICkge1xyXG4gICAgICAgIC8vIFRPRE9cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENhcHN1bGUvY2Fwc3VsZSBuYXJyb3dwaGFzZVxyXG4gICAgICogQG1ldGhvZCBjYXBzdWxlQ2Fwc3VsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcclxuICAgICAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIHNpXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICB4aVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgYWlcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXHJcbiAgICAgKiBAcGFyYW0gIHtDYXBzdWxlfSAgICBzalxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgeGpcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGFqXHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jYXBzdWxlQ2Fwc3VsZSA9IGZ1bmN0aW9uIChiaSwgc2ksIHhpLCBhaSwgYmosIHNqLCB4aiwgYWosIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdGhyb3cgXCJDYXBzdWxlLWNhcHN1bGUgY29sbGlzaW9ucyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuXCI7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgLy8gbGV0IGNhcHN1bGVDYXBzdWxlX3RlbXBSZWN0MSA9IG5ldyBCb3goeyB3aWR0aDogMSwgaGVpZ2h0OiAxIH0pO1xyXG4gICAgICAgIC8vIGxldCBlbmFibGVGcmljdGlvbkJlZm9yZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgIC8vIC8vIENoZWNrIHRoZSBjaXJjbGVzXHJcbiAgICAgICAgLy8gLy8gQWRkIG9mZnNldHMhXHJcbiAgICAgICAgLy8gbGV0IGNpcmNsZVBvc2kgPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMSxcclxuICAgICAgICAvLyBcdGNpcmNsZVBvc2ogPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMjtcclxuICAgICAgICAvLyBsZXQgbnVtQ29udGFjdHMgPSAwO1xyXG4gICAgICAgIC8vIC8vIE5lZWQgNCBjaXJjbGUgY2hlY2tzLCBiZXR3ZWVuIGFsbFxyXG4gICAgICAgIC8vIGZvcihsZXQgaT0wOyBpPDI7IGkrKyl7XHJcbiAgICAgICAgLy8gXHR2ZWMyLnNldChjaXJjbGVQb3NpLChpPT09MD8tMToxKSpzaS5sZW5ndGgvMiwwKTtcclxuICAgICAgICAvLyBcdHZlYzIudG9HbG9iYWxGcmFtZShjaXJjbGVQb3NpLCBjaXJjbGVQb3NpLCB4aSwgYWkpO1xyXG4gICAgICAgIC8vIFx0Zm9yKGxldCBqPTA7IGo8MjsgaisrKXtcclxuICAgICAgICAvLyBcdFx0dmVjMi5zZXQoY2lyY2xlUG9zaiwoaj09PTA/LTE6MSkqc2oubGVuZ3RoLzIsIDApO1xyXG4gICAgICAgIC8vIFx0XHR2ZWMyLnRvR2xvYmFsRnJhbWUoY2lyY2xlUG9zaiwgY2lyY2xlUG9zaiwgeGosIGFqKTtcclxuICAgICAgICAvLyBcdFx0Ly8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cclxuICAgICAgICAvLyBcdFx0aWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XHJcbiAgICAgICAgLy8gXHRcdFx0ZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xyXG4gICAgICAgIC8vIFx0XHRcdHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICAvLyBcdFx0fVxyXG4gICAgICAgIC8vIFx0XHRsZXQgcmVzdWx0ID0gdGhpcy5jaXJjbGVDaXJjbGUoYmksc2ksY2lyY2xlUG9zaSwgYmosc2osY2lyY2xlUG9zaiwganVzdFRlc3QsIHNpLnJhZGl1cywgc2oucmFkaXVzKTtcclxuICAgICAgICAvLyBcdFx0aWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XHJcbiAgICAgICAgLy8gXHRcdFx0dGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xyXG4gICAgICAgIC8vIFx0XHR9XHJcbiAgICAgICAgLy8gXHRcdGlmKGp1c3RUZXN0ICYmIHJlc3VsdCAhPT0gMCl7XHJcbiAgICAgICAgLy8gXHRcdFx0cmV0dXJuIDE7XHJcbiAgICAgICAgLy8gXHRcdH1cclxuICAgICAgICAvLyBcdFx0bnVtQ29udGFjdHMgKz0gcmVzdWx0O1xyXG4gICAgICAgIC8vIFx0fVxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcclxuICAgICAgICAvLyBcdC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXHJcbiAgICAgICAgLy8gXHRlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XHJcbiAgICAgICAgLy8gXHR0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIC8vIENoZWNrIGNpcmNsZXMgYWdhaW5zdCB0aGUgY2VudGVyIGJveHNcclxuICAgICAgICAvLyBsZXQgcmVjdCA9IGNhcHN1bGVDYXBzdWxlX3RlbXBSZWN0MTtcclxuICAgICAgICAvLyBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShyZWN0LHNpKTtcclxuICAgICAgICAvLyBsZXQgcmVzdWx0MSA9IHRoaXMuY29udmV4Q2Fwc3VsZShiaSxyZWN0LHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3QpO1xyXG4gICAgICAgIC8vIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xyXG4gICAgICAgIC8vIFx0dGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBpZihqdXN0VGVzdCAmJiByZXN1bHQxICE9PSAwKXtcclxuICAgICAgICAvLyBcdHJldHVybiAxO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBudW1Db250YWN0cyArPSByZXN1bHQxO1xyXG4gICAgICAgIC8vIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xyXG4gICAgICAgIC8vIFx0Ly8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cclxuICAgICAgICAvLyBcdGxldCBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XHJcbiAgICAgICAgLy8gXHR0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIHNldENvbnZleFRvQ2Fwc3VsZVNoYXBlTWlkZGxlKHJlY3Qsc2opO1xyXG4gICAgICAgIC8vIGxldCByZXN1bHQyID0gdGhpcy5jb252ZXhDYXBzdWxlKGJqLHJlY3QseGosYWosIGJpLHNpLHhpLGFpLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgLy8gaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XHJcbiAgICAgICAgLy8gXHR0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIGlmKGp1c3RUZXN0ICYmIHJlc3VsdDIgIT09IDApe1xyXG4gICAgICAgIC8vIFx0cmV0dXJuIDE7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIG51bUNvbnRhY3RzICs9IHJlc3VsdDI7XHJcbiAgICAgICAgLy8gaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XHJcbiAgICAgICAgLy8gXHRpZihudW1Db250YWN0cyAmJiB0aGlzLmVuYWJsZUZyaWN0aW9uKXtcclxuICAgICAgICAvLyBcdFx0dGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykpO1xyXG4gICAgICAgIC8vIFx0fVxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyByZXR1cm4gbnVtQ29udGFjdHM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lL2xpbmUgbmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgbGluZUxpbmVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJvZHlBXHJcbiAgICAgKiBAcGFyYW0gIHtMaW5lfSAgICAgICBzaGFwZUFcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBvc2l0aW9uQVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGVBXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBib2R5QlxyXG4gICAgICogQHBhcmFtICB7TGluZX0gICAgICAgc2hhcGVCXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBwb3NpdGlvbkJcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlQlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICogQHRvZG8gSW1wbGVtZW50IG1lIVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUxpbmUgPSBmdW5jdGlvbiAoXHJcbiAgICAvKiBib2R5QSxcclxuICAgICAgICBzaGFwZUEsXHJcbiAgICAgICAgcG9zaXRpb25BLFxyXG4gICAgICAgIGFuZ2xlQSxcclxuICAgICAgICBib2R5QixcclxuICAgICAgICBzaGFwZUIsXHJcbiAgICAgICAgcG9zaXRpb25CLFxyXG4gICAgICAgIGFuZ2xlQixcclxuICAgICAgICBqdXN0VGVzdCovXHJcbiAgICApIHtcclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFuZS9saW5lIE5hcnJvd3BoYXNlXHJcbiAgICAgKiBAbWV0aG9kIHBsYW5lTGluZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICBwbGFuZUJvZHlcclxuICAgICAqIEBwYXJhbSAge1BsYW5lfSAgcGxhbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICBwbGFuZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBwbGFuZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgIGxpbmVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtMaW5lfSAgIGxpbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICBsaW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxpbmVBbmdsZVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkxJTkVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUxpbmUgPSBmdW5jdGlvbiAocGxhbmVCb2R5LCBwbGFuZVNoYXBlLCBwbGFuZU9mZnNldCwgcGxhbmVBbmdsZSwgbGluZUJvZHksIGxpbmVTaGFwZSwgbGluZU9mZnNldCwgbGluZUFuZ2xlLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLCB3b3JsZFZlcnRleDEgPSB0bXAyLCB3b3JsZFZlcnRleDAxID0gdG1wMywgd29ybGRWZXJ0ZXgxMSA9IHRtcDQsIHdvcmxkRWRnZSA9IHRtcDUsIHdvcmxkRWRnZVVuaXQgPSB0bXA2LCBkaXN0ID0gdG1wNywgd29ybGROb3JtYWwgPSB0bXA4LCB3b3JsZFRhbmdlbnQgPSB0bXA5LCB2ZXJ0cyA9IHRtcEFycmF5LCBudW1Db250YWN0cyA9IDA7XHJcbiAgICAgICAgLy8gR2V0IHN0YXJ0IGFuZCBlbmQgcG9pbnRzXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHdvcmxkVmVydGV4MCwgLWxpbmVTaGFwZS5sZW5ndGggLyAyLCAwKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQod29ybGRWZXJ0ZXgxLCBsaW5lU2hhcGUubGVuZ3RoIC8gMiwgMCk7XHJcbiAgICAgICAgLy8gTm90IHN1cmUgd2h5IHdlIGhhdmUgdG8gdXNlIHdvcmxkVmVydGV4KjEgaGVyZSwgYnV0IGl0IHdvbid0IHdvcmsgb3RoZXJ3aXNlLiBUaXJlZC5cclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKHdvcmxkVmVydGV4MDEsIHdvcmxkVmVydGV4MCwgbGluZU9mZnNldCwgbGluZUFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MSwgbGluZU9mZnNldCwgbGluZUFuZ2xlKTtcclxuICAgICAgICBjb3B5KHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwMSk7XHJcbiAgICAgICAgY29weSh3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MTEpO1xyXG4gICAgICAgIC8vIEdldCB2ZWN0b3IgYWxvbmcgdGhlIGxpbmVcclxuICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MCk7XHJcbiAgICAgICAgbm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XHJcbiAgICAgICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlOTBjdyh3b3JsZFRhbmdlbnQsIHdvcmxkRWRnZVVuaXQpO1xyXG4gICAgICAgIHJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xyXG4gICAgICAgIC8vIENoZWNrIGxpbmUgZW5kc1xyXG4gICAgICAgIHZlcnRzWzBdID0gd29ybGRWZXJ0ZXgwO1xyXG4gICAgICAgIHZlcnRzWzFdID0gd29ybGRWZXJ0ZXgxO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcclxuICAgICAgICAgICAgc3ViKGRpc3QsIHYsIHBsYW5lT2Zmc2V0KTtcclxuICAgICAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGROb3JtYWwpO1xyXG4gICAgICAgICAgICBpZiAoZCA8IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksIGxpbmVCb2R5LCBwbGFuZVNoYXBlLCBsaW5lU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgbnVtQ29udGFjdHMrKztcclxuICAgICAgICAgICAgICAgIGNvcHkoYy5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGlzdGFuY2UgdmVjdG9yIGFsb25nIHBsYW5lIG5vcm1hbFxyXG4gICAgICAgICAgICAgICAgc2NhbGUoZGlzdCwgd29ybGROb3JtYWwsIGQpO1xyXG4gICAgICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gcGxhbmUgY2VudGVyIHRvIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHYsIGRpc3QpO1xyXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgLy8gRnJvbSBsaW5lIGNlbnRlciB0byBjb250YWN0XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB2LCBsaW5lT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChudW1Db250YWN0cyAmJiB0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bUNvbnRhY3RzO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuQ0FQU1VMRV0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLnBhcnRpY2xlQ2Fwc3VsZSA9IGZ1bmN0aW9uIChwYXJ0aWNsZUJvZHksIHBhcnRpY2xlU2hhcGUsIHBhcnRpY2xlUG9zaXRpb24sIGNhcHN1bGVCb2R5LCBjYXBzdWxlU2hhcGUsIGNhcHN1bGVQb3NpdGlvbiwgY2Fwc3VsZUFuZ2xlLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNpcmNsZUxpbmUocGFydGljbGVCb2R5LCBwYXJ0aWNsZVNoYXBlLCBwYXJ0aWNsZVBvc2l0aW9uLCBjYXBzdWxlQm9keSwgY2Fwc3VsZVNoYXBlLCBjYXBzdWxlUG9zaXRpb24sIGNhcHN1bGVBbmdsZSwganVzdFRlc3QsIGNhcHN1bGVTaGFwZS5yYWRpdXMsIDApO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2lyY2xlL2xpbmUgTmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgY2lyY2xlTGluZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gY2lyY2xlQm9keVxyXG4gICAgICogQHBhcmFtICB7Q2lyY2xlfSBjaXJjbGVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGNpcmNsZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gbGluZUJvZHlcclxuICAgICAqIEBwYXJhbSAge0xpbmV9IGxpbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGxpbmVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGluZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0IElmIHNldCB0byB0cnVlLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgKGludGVyc2VjdGlvbiBvciBub3QpIHdpdGhvdXQgYWRkaW5nIGVxdWF0aW9ucy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lUmFkaXVzIFJhZGl1cyB0byBhZGQgdG8gdGhlIGxpbmUuIENhbiBiZSB1c2VkIHRvIHRlc3QgQ2Fwc3VsZXMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2lyY2xlUmFkaXVzIElmIHNldCwgdGhpcyB2YWx1ZSBvdmVycmlkZXMgdGhlIGNpcmNsZSBzaGFwZSByYWRpdXMuXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkxJTkVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVMaW5lID0gZnVuY3Rpb24gKGNpcmNsZUJvZHksIGNpcmNsZVNoYXBlLCBjaXJjbGVPZmZzZXQsIFxyXG4gICAgLy9jaXJjbGVBbmdsZTogZjMyLFxyXG4gICAgbGluZUJvZHksIGxpbmVTaGFwZSwgbGluZU9mZnNldCwgbGluZUFuZ2xlLCBqdXN0VGVzdCwgbGluZVJhZGl1cywgY2lyY2xlUmFkaXVzKSB7XHJcbiAgICAgICAgbGluZVJhZGl1cyA9IGxpbmVSYWRpdXMgIT09IG51bGwgJiYgbGluZVJhZGl1cyAhPT0gdm9pZCAwID8gbGluZVJhZGl1cyA6IDA7XHJcbiAgICAgICAgdmFyIG9ydGhvRGlzdCA9IHRtcDE7XHJcbiAgICAgICAgdmFyIGxpbmVUb0NpcmNsZU9ydGhvVW5pdCA9IHRtcDI7XHJcbiAgICAgICAgdmFyIHByb2plY3RlZFBvaW50ID0gdG1wMztcclxuICAgICAgICB2YXIgY2VudGVyRGlzdCA9IHRtcDQ7XHJcbiAgICAgICAgdmFyIHdvcmxkVGFuZ2VudCA9IHRtcDU7XHJcbiAgICAgICAgdmFyIHdvcmxkRWRnZSA9IHRtcDY7XHJcbiAgICAgICAgdmFyIHdvcmxkRWRnZVVuaXQgPSB0bXA3O1xyXG4gICAgICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXA4O1xyXG4gICAgICAgIHZhciB3b3JsZFZlcnRleDEgPSB0bXA5O1xyXG4gICAgICAgIHZhciB3b3JsZFZlcnRleDAxID0gdG1wMTA7XHJcbiAgICAgICAgdmFyIHdvcmxkVmVydGV4MTEgPSB0bXAxMTtcclxuICAgICAgICB2YXIgZGlzdCA9IHRtcDEyO1xyXG4gICAgICAgIHZhciBsaW5lVG9DaXJjbGUgPSB0bXAxMztcclxuICAgICAgICB2YXIgbGluZUVuZFRvTGluZVJhZGl1cyA9IHRtcDE0O1xyXG4gICAgICAgIHZhciB2ZXJ0cyA9IHRtcEFycmF5O1xyXG4gICAgICAgIHZhciBoYWxmTGluZUxlbmd0aCA9IGxpbmVTaGFwZS5sZW5ndGggLyAyO1xyXG4gICAgICAgIC8vIEdldCBzdGFydCBhbmQgZW5kIHBvaW50c1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh3b3JsZFZlcnRleDAsIC1oYWxmTGluZUxlbmd0aCwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHdvcmxkVmVydGV4MSwgaGFsZkxpbmVMZW5ndGgsIDApO1xyXG4gICAgICAgIC8vIE5vdCBzdXJlIHdoeSB3ZSBoYXZlIHRvIHVzZSB3b3JsZFZlcnRleCoxIGhlcmUsIGJ1dCBpdCB3b24ndCB3b3JrIG90aGVyd2lzZS4gVGlyZWQuXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAsIGxpbmVPZmZzZXQsIGxpbmVBbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDEsIGxpbmVPZmZzZXQsIGxpbmVBbmdsZSk7XHJcbiAgICAgICAgY29weSh3b3JsZFZlcnRleDAsIHdvcmxkVmVydGV4MDEpO1xyXG4gICAgICAgIGNvcHkod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDExKTtcclxuICAgICAgICAvLyBHZXQgdmVjdG9yIGFsb25nIHRoZSBsaW5lXHJcbiAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xyXG4gICAgICAgIG5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xyXG4gICAgICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLlxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZTkwY3cod29ybGRUYW5nZW50LCB3b3JsZEVkZ2VVbml0KTtcclxuICAgICAgICAvLyBDaGVjayBkaXN0YW5jZSBmcm9tIHRoZSBwbGFuZSBzcGFubmVkIGJ5IHRoZSBlZGdlIHZzIHRoZSBjaXJjbGVcclxuICAgICAgICBzdWIoZGlzdCwgY2lyY2xlT2Zmc2V0LCB3b3JsZFZlcnRleDApO1xyXG4gICAgICAgIHZhciBkID0gZG90KGRpc3QsIHdvcmxkVGFuZ2VudCk7IC8vIERpc3RhbmNlIGZyb20gY2VudGVyIG9mIGxpbmUgdG8gY2lyY2xlIGNlbnRlclxyXG4gICAgICAgIHN1YihjZW50ZXJEaXN0LCB3b3JsZFZlcnRleDAsIGxpbmVPZmZzZXQpO1xyXG4gICAgICAgIHN1YihsaW5lVG9DaXJjbGUsIGNpcmNsZU9mZnNldCwgbGluZU9mZnNldCk7XHJcbiAgICAgICAgdmFyIHJhZGl1c1N1bSA9IGNpcmNsZVJhZGl1cyArIGxpbmVSYWRpdXM7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGQpIDwgcmFkaXVzU3VtKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdyBwcm9qZWN0IHRoZSBjaXJjbGUgb250byB0aGUgZWRnZVxyXG4gICAgICAgICAgICBzY2FsZShvcnRob0Rpc3QsIHdvcmxkVGFuZ2VudCwgZCk7XHJcbiAgICAgICAgICAgIHN1Yihwcm9qZWN0ZWRQb2ludCwgY2lyY2xlT2Zmc2V0LCBvcnRob0Rpc3QpO1xyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG1pc3NpbmcgbGluZSByYWRpdXNcclxuICAgICAgICAgICAgc2NhbGUobGluZVRvQ2lyY2xlT3J0aG9Vbml0LCB3b3JsZFRhbmdlbnQsIGRvdCh3b3JsZFRhbmdlbnQsIGxpbmVUb0NpcmNsZSkpO1xyXG4gICAgICAgICAgICBub3JtYWxpemUobGluZVRvQ2lyY2xlT3J0aG9Vbml0LCBsaW5lVG9DaXJjbGVPcnRob1VuaXQpO1xyXG4gICAgICAgICAgICBzY2FsZShsaW5lVG9DaXJjbGVPcnRob1VuaXQsIGxpbmVUb0NpcmNsZU9ydGhvVW5pdCwgbGluZVJhZGl1cyk7XHJcbiAgICAgICAgICAgIGFkZChwcm9qZWN0ZWRQb2ludCwgcHJvamVjdGVkUG9pbnQsIGxpbmVUb0NpcmNsZU9ydGhvVW5pdCk7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGVkZ2Ugc3BhblxyXG4gICAgICAgICAgICB2YXIgcG9zID0gZG90KHdvcmxkRWRnZVVuaXQsIHByb2plY3RlZFBvaW50KTtcclxuICAgICAgICAgICAgdmFyIHBvczAgPSBkb3Qod29ybGRFZGdlVW5pdCwgd29ybGRWZXJ0ZXgwKTtcclxuICAgICAgICAgICAgdmFyIHBvczEgPSBkb3Qod29ybGRFZGdlVW5pdCwgd29ybGRWZXJ0ZXgxKTtcclxuICAgICAgICAgICAgaWYgKHBvcyA+IHBvczAgJiYgcG9zIDwgcG9zMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZ290IGNvbnRhY3QhXHJcbiAgICAgICAgICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSwgbGluZUJvZHksIGNpcmNsZVNoYXBlLCBsaW5lU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgc2NhbGUoYy5ub3JtYWxBLCBvcnRob0Rpc3QsIC0xKTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZShjLm5vcm1hbEEsIGMubm9ybWFsQSk7XHJcbiAgICAgICAgICAgICAgICBzY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBwcm9qZWN0ZWRQb2ludCwgbGluZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgY29ybmVyXHJcbiAgICAgICAgdmVydHNbMF0gPSB3b3JsZFZlcnRleDA7XHJcbiAgICAgICAgdmVydHNbMV0gPSB3b3JsZFZlcnRleDE7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xyXG4gICAgICAgICAgICBzdWIoZGlzdCwgdiwgY2lyY2xlT2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKHNxdWFyZWRMZW5ndGgoZGlzdCkgPCBNYXRoLnBvdyhyYWRpdXNTdW0sIDIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSwgbGluZUJvZHksIGNpcmNsZVNoYXBlLCBsaW5lU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgY29weShjLm5vcm1hbEEsIGRpc3QpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcclxuICAgICAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcclxuICAgICAgICAgICAgICAgIHNjYWxlKGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHYsIGxpbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgc2NhbGUobGluZUVuZFRvTGluZVJhZGl1cywgYy5ub3JtYWxBLCAtbGluZVJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVFbmRUb0xpbmVSYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaXJjbGUvY2Fwc3VsZSBOYXJyb3dwaGFzZVxyXG4gICAgICogQG1ldGhvZCBjaXJjbGVDYXBzdWxlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgIGJpXHJcbiAgICAgKiBAcGFyYW0gIHtDaXJjbGV9IHNpXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIHhpXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgIGJqXHJcbiAgICAgKiBAcGFyYW0gIHtMaW5lfSAgIHNqXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIHhqXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFqXHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkNBUFNVTEVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVDYXBzdWxlID0gZnVuY3Rpb24gKGJpLCBzaSwgeGksIGJqLCBzaiwgeGosIGFqLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNpcmNsZUxpbmUoYmksIHNpLCB4aSwgYmosIHNqLCB4aiwgYWosIGp1c3RUZXN0LCAwLCBzaS5yYWRpdXMpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2lyY2xlL2NvbnZleCBOYXJyb3dwaGFzZS5cclxuICAgICAqIEBtZXRob2QgY2lyY2xlQ29udmV4XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBjaXJjbGVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDaXJjbGV9IGNpcmNsZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gY2lyY2xlT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBqdXN0VGVzdFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVSYWRpdXNcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqIEB0b2RvIFNob3VsZCBwcm9iYWJseSBkbyBhIHNlcGFyYXRpbmcgYXhpcyB0ZXN0IGxpa2UgaHR0cHM6Ly9naXRodWIuY29tL2VyaW5jYXR0by9Cb3gyRC9ibG9iL21hc3Rlci9Cb3gyRC9Cb3gyRC9Db2xsaXNpb24vYjJDb2xsaWRlQ2lyY2xlLmNwcCNMNjJcclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuQ09OVkVYXSA9XHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5CT1hdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVDb252ZXggPSBmdW5jdGlvbiAoY2lyY2xlQm9keSwgY2lyY2xlU2hhcGUsIGNpcmNsZU9mZnNldCwgY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleE9mZnNldCwgY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjaXJjbGVSYWRpdXMpIHtcclxuICAgICAgICB2YXIgd29ybGRWZXJ0ZXgwID0gdG1wMSwgd29ybGRWZXJ0ZXgxID0gdG1wMiwgZWRnZSA9IHRtcDMsIGVkZ2VVbml0ID0gdG1wNCwgbm9ybWFsID0gdG1wNSwgemVybyA9IHRtcDYsIGxvY2FsQ2lyY2xlUG9zaXRpb24gPSB0bXA3LCByID0gdG1wOCwgZGlzdCA9IHRtcDEwLCB3b3JsZFZlcnRleCA9IHRtcDExLCBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50ID0gdG1wMTMsIGNhbmRpZGF0ZSA9IHRtcDE0LCBjYW5kaWRhdGVEaXN0ID0gdG1wMTUsIGZvdW5kID0gLTEsIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gSW5maW5pdHk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHplcm8sIDAsIDApO1xyXG4gICAgICAgIC8vIE5ldyBhbGdvcml0aG06XHJcbiAgICAgICAgLy8gMS4gQ2hlY2sgc28gY2VudGVyIG9mIGNpcmNsZSBpcyBub3QgaW5zaWRlIHRoZSBwb2x5Z29uLiBJZiBpdCBpcywgdGhpcyB3b250IHdvcmsuLi5cclxuICAgICAgICAvLyAyLiBGb3IgZWFjaCBlZGdlXHJcbiAgICAgICAgLy8gMi4gMS4gR2V0IHBvaW50IG9uIGNpcmNsZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGVkZ2UgKHNjYWxlIG5vcm1hbCB3aXRoIC1yYWRpdXMpXHJcbiAgICAgICAgLy8gMi4gMi4gQ2hlY2sgaWYgcG9pbnQgaXMgaW5zaWRlLlxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvTG9jYWxGcmFtZShsb2NhbENpcmNsZVBvc2l0aW9uLCBjaXJjbGVPZmZzZXQsIGNvbnZleE9mZnNldCwgY29udmV4QW5nbGUpO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzO1xyXG4gICAgICAgIHZhciBub3JtYWxzID0gY29udmV4U2hhcGUubm9ybWFscztcclxuICAgICAgICB2YXIgbnVtVmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG5vcm1hbEluZGV4ID0gLTE7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgbWluIHNlcGFyYXRpbmcgZWRnZS5cclxuICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IC1JbmZpbml0eTtcclxuICAgICAgICB2YXIgcmFkaXVzID0gY29udmV4U2hhcGUuYm91bmRpbmdSYWRpdXMgKyBjaXJjbGVSYWRpdXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WZXJ0aWNlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1YihyLCBsb2NhbENpcmNsZVBvc2l0aW9uLCB2ZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgICAgIHZhciBzID0gZG90KG5vcm1hbHNbaV0sIHIpO1xyXG4gICAgICAgICAgICBpZiAocyA+IHJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgLy8gRWFybHkgb3V0LlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHMgPiBzZXBhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0aW9uID0gcztcclxuICAgICAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBlZGdlcyBmaXJzdFxyXG4gICAgICAgIGZvciAodmFyIGkgPSBub3JtYWxJbmRleCArIG51bVZlcnRpY2VzIC0gMTsgaSA8IG5vcm1hbEluZGV4ICsgbnVtVmVydGljZXMgKyAyOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYwID0gdmVydGljZXNbaSAlIG51bVZlcnRpY2VzXSwgbiA9IG5vcm1hbHNbaSAlIG51bVZlcnRpY2VzXTtcclxuICAgICAgICAgICAgLy8gR2V0IHBvaW50IG9uIGNpcmNsZSwgY2xvc2VzdCB0byB0aGUgY29udmV4XHJcbiAgICAgICAgICAgIHNjYWxlKGNhbmRpZGF0ZSwgbiwgLWNpcmNsZVJhZGl1cyk7XHJcbiAgICAgICAgICAgIGFkZChjYW5kaWRhdGUsIGNhbmRpZGF0ZSwgbG9jYWxDaXJjbGVQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChwb2ludEluQ29udmV4TG9jYWwoY2FuZGlkYXRlLCBjb252ZXhTaGFwZSkpIHtcclxuICAgICAgICAgICAgICAgIHN1YihjYW5kaWRhdGVEaXN0LCB2MCwgY2FuZGlkYXRlKTtcclxuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVEaXN0YW5jZSA9IE1hdGguYWJzKGRvdChjYW5kaWRhdGVEaXN0LCBuKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlRGlzdGFuY2UgPCBtaW5DYW5kaWRhdGVEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gY2FuZGlkYXRlRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3VuZCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdjAgPSB2ZXJ0aWNlc1tmb3VuZCAlIG51bVZlcnRpY2VzXSwgdjEgPSB2ZXJ0aWNlc1soZm91bmQgKyAxKSAlIG51bVZlcnRpY2VzXTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh3b3JsZFZlcnRleDAsIHYwLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh3b3JsZFZlcnRleDEsIHYxLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICAgICAgc3ViKGVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcclxuICAgICAgICAgICAgbm9ybWFsaXplKGVkZ2VVbml0LCBlZGdlKTtcclxuICAgICAgICAgICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuIFBvaW50cyBvdXQgb2YgdGhlIENvbnZleFxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGU5MGN3KG5vcm1hbCwgZWRnZVVuaXQpO1xyXG4gICAgICAgICAgICAvLyBHZXQgcG9pbnQgb24gY2lyY2xlLCBjbG9zZXN0IHRvIHRoZSBjb252ZXhcclxuICAgICAgICAgICAgc2NhbGUoY2FuZGlkYXRlLCBub3JtYWwsIC1jaXJjbGVSYWRpdXMpO1xyXG4gICAgICAgICAgICBhZGQoY2FuZGlkYXRlLCBjYW5kaWRhdGUsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgIHNjYWxlKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIG5vcm1hbCwgbWluQ2FuZGlkYXRlRGlzdGFuY2UpO1xyXG4gICAgICAgICAgICBhZGQoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgY2FuZGlkYXRlKTtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LCBjb252ZXhCb2R5LCBjaXJjbGVTaGFwZSwgY29udmV4U2hhcGUpO1xyXG4gICAgICAgICAgICBzdWIoYy5ub3JtYWxBLCBjYW5kaWRhdGUsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZShjLm5vcm1hbEEsIGMubm9ybWFsQSk7XHJcbiAgICAgICAgICAgIHNjYWxlKGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xyXG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIGNvbnZleE9mZnNldCk7XHJcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4T2Zmc2V0KTtcclxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgY2xvc2VzdCB2ZXJ0aWNlc1xyXG4gICAgICAgIGlmIChjaXJjbGVSYWRpdXMgPiAwICYmIG5vcm1hbEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbm9ybWFsSW5kZXggKyBudW1WZXJ0aWNlczsgaSA8IG5vcm1hbEluZGV4ICsgbnVtVmVydGljZXMgKyAyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFZlcnRleCA9IHZlcnRpY2VzW2kgJSBudW1WZXJ0aWNlc107XHJcbiAgICAgICAgICAgICAgICBzdWIoZGlzdCwgbG9jYWxWZXJ0ZXgsIGxvY2FsQ2lyY2xlUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNxdWFyZWRMZW5ndGgoZGlzdCkgPCBjaXJjbGVSYWRpdXMgKiBjaXJjbGVSYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUod29ybGRWZXJ0ZXgsIGxvY2FsVmVydGV4LCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRWZXJ0ZXgsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LCBjb252ZXhCb2R5LCBjaXJjbGVTaGFwZSwgY29udmV4U2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB3b3JsZFZlcnRleCwgY29udmV4T2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJ0aWNsZS9jb252ZXggTmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgcGFydGljbGVDb252ZXhcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IHBhcnRpY2xlQm9keVxyXG4gICAgICogQHBhcmFtICB7UGFydGljbGV9IHBhcnRpY2xlU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwYXJ0aWNsZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBwYXJ0aWNsZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKiBAdG9kbyB1c2UgcG9pbnRJbkNvbnZleCBhbmQgY29kZSBtb3JlIHNpbWlsYXIgdG8gY2lyY2xlQ29udmV4XHJcbiAgICAgKiBAdG9kbyBkb24ndCB0cmFuc2Zvcm0gZWFjaCB2ZXJ0ZXgsIGJ1dCB0cmFuc2Zvcm0gdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHRvIGNvbnZleC1sb2NhbCBpbnN0ZWFkXHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuQ09OVkVYXSA9XHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLkJPWF0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLnBhcnRpY2xlQ29udmV4ID0gZnVuY3Rpb24gKHBhcnRpY2xlQm9keSwgcGFydGljbGVTaGFwZSwgcGFydGljbGVPZmZzZXQsIGNvbnZleEJvZHksIGNvbnZleFNoYXBlLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLCB3b3JsZFZlcnRleDEgPSB0bXAyLCB3b3JsZEVkZ2UgPSB0bXAzLCB3b3JsZEVkZ2VVbml0ID0gdG1wNCwgd29ybGRUYW5nZW50ID0gdG1wNSwgY2VudGVyRGlzdCA9IHRtcDYsIGNvbnZleFRvcGFydGljbGUgPSB0bXA3LCBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50ID0gdG1wMTMsIGNhbmRpZGF0ZURpc3QgPSB0bXAxNCwgbWluRWRnZU5vcm1hbCA9IHRtcDE1LCBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IEluZmluaXR5LCBmb3VuZCA9IGZhbHNlLCB2ZXJ0cyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwYXJ0aWNsZSBpcyBpbiB0aGUgcG9seWdvbiBhdCBhbGxcclxuICAgICAgICBpZiAoIXBvaW50SW5Db252ZXgocGFydGljbGVPZmZzZXQsIGNvbnZleFNoYXBlLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBlZGdlcyBmaXJzdFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBudW1WZXJ0cyA9IHZlcnRzLmxlbmd0aDsgaSAhPT0gbnVtVmVydHMgKyAxOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYwID0gdmVydHNbaSAlIG51bVZlcnRzXSwgdjEgPSB2ZXJ0c1soaSArIDEpICUgbnVtVmVydHNdO1xyXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdmVydGljZXMgdG8gd29ybGRcclxuICAgICAgICAgICAgLy8gQHRvZG8gdHJhbnNmb3JtIHBvaW50IHRvIGxvY2FsIHNwYWNlIGluc3RlYWRcclxuICAgICAgICAgICAgcm90YXRlKHdvcmxkVmVydGV4MCwgdjAsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICAgICAgcm90YXRlKHdvcmxkVmVydGV4MSwgdjEsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICAgICAgYWRkKHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xyXG4gICAgICAgICAgICBhZGQod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDEsIGNvbnZleE9mZnNldCk7XHJcbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBlZGdlXHJcbiAgICAgICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcclxuICAgICAgICAgICAgbm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XHJcbiAgICAgICAgICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLiBQb2ludHMgb3V0IG9mIHRoZSBDb252ZXhcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlOTBjdyh3b3JsZFRhbmdlbnQsIHdvcmxkRWRnZVVuaXQpO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBkaXN0YW5jZSBmcm9tIHRoZSBpbmZpbml0ZSBsaW5lIChzcGFubmVkIGJ5IHRoZSBlZGdlKSB0byB0aGUgcGFydGljbGVcclxuICAgICAgICAgICAgLy9zdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIHdvcmxkVmVydGV4MCk7XHJcbiAgICAgICAgICAgIC8vbGV0IGQgPSBkb3QoZGlzdCwgd29ybGRUYW5nZW50KTtcclxuICAgICAgICAgICAgc3ViKGNlbnRlckRpc3QsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcclxuICAgICAgICAgICAgc3ViKGNvbnZleFRvcGFydGljbGUsIHBhcnRpY2xlT2Zmc2V0LCBjb252ZXhPZmZzZXQpO1xyXG4gICAgICAgICAgICBzdWIoY2FuZGlkYXRlRGlzdCwgd29ybGRWZXJ0ZXgwLCBwYXJ0aWNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGVEaXN0YW5jZSA9IE1hdGguYWJzKGRvdChjYW5kaWRhdGVEaXN0LCB3b3JsZFRhbmdlbnQpKTtcclxuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZURpc3RhbmNlIDwgbWluQ2FuZGlkYXRlRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gY2FuZGlkYXRlRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBzY2FsZShjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCB3b3JsZFRhbmdlbnQsIGNhbmRpZGF0ZURpc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIGFkZChjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCBwYXJ0aWNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBjb3B5KG1pbkVkZ2VOb3JtYWwsIHdvcmxkVGFuZ2VudCk7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGFydGljbGVCb2R5LCBjb252ZXhCb2R5LCBwYXJ0aWNsZVNoYXBlLCBjb252ZXhTaGFwZSk7XHJcbiAgICAgICAgICAgIHNjYWxlKGMubm9ybWFsQSwgbWluRWRnZU5vcm1hbCwgLTEpO1xyXG4gICAgICAgICAgICBub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICAvLyBQYXJ0aWNsZSBoYXMgbm8gZXh0ZW50IHRvIHRoZSBjb250YWN0IHBvaW50XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChjLmNvbnRhY3RQb2ludEEsIDAsIDApO1xyXG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBhcnRpY2xlT2Zmc2V0KTtcclxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAvLyBGcm9tIGNvbnZleCBjZW50ZXIgdG8gcG9pbnRcclxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgY29udmV4T2Zmc2V0KTtcclxuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhPZmZzZXQpO1xyXG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleEJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENpcmNsZS9jaXJjbGUgTmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgY2lyY2xlQ2lyY2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtICB7Q2lyY2xlfSBzaGFwZUFcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRBXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtICB7Q2lyY2xlfSBzaGFwZUJcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRCXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1c0FdIE9wdGlvbmFsIHJhZGl1cyB0byB1c2UgZm9yIHNoYXBlQVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXNCXSBPcHRpb25hbCByYWRpdXMgdG8gdXNlIGZvciBzaGFwZUJcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlQ2lyY2xlID0gZnVuY3Rpb24gKGJvZHlBLCBzaGFwZUEsIG9mZnNldEEsIGJvZHlCLCBzaGFwZUIsIG9mZnNldEIsIGp1c3RUZXN0LCByYWRpdXNBLCByYWRpdXNCKSB7XHJcbiAgICAgICAgdmFyIGRpc3QgPSB0bXAxO1xyXG4gICAgICAgIHN1YihkaXN0LCBvZmZzZXRBLCBvZmZzZXRCKTtcclxuICAgICAgICB2YXIgciA9IHJhZGl1c0EgKyByYWRpdXNCO1xyXG4gICAgICAgIGlmIChzcXVhcmVkTGVuZ3RoKGRpc3QpID4gciAqIHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIsIHNoYXBlQSwgc2hhcGVCKTtcclxuICAgICAgICB2YXIgY3BBID0gYy5jb250YWN0UG9pbnRBO1xyXG4gICAgICAgIHZhciBjcEIgPSBjLmNvbnRhY3RQb2ludEI7XHJcbiAgICAgICAgdmFyIG5vcm1hbEEgPSBjLm5vcm1hbEE7XHJcbiAgICAgICAgc3ViKG5vcm1hbEEsIG9mZnNldEIsIG9mZnNldEEpO1xyXG4gICAgICAgIG5vcm1hbGl6ZShub3JtYWxBLCBub3JtYWxBKTtcclxuICAgICAgICBzY2FsZShjcEEsIG5vcm1hbEEsIHJhZGl1c0EpO1xyXG4gICAgICAgIHNjYWxlKGNwQiwgbm9ybWFsQSwgLXJhZGl1c0IpO1xyXG4gICAgICAgIGFkZFN1YihjcEEsIGNwQSwgb2Zmc2V0QSwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgIGFkZFN1YihjcEIsIGNwQiwgb2Zmc2V0QiwgYm9keUIucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFBsYW5lL0NvbnZleCBOYXJyb3dwaGFzZVxyXG4gICAgICogQG1ldGhvZCBwbGFuZUNvbnZleFxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gcGxhbmVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtQbGFuZX0gcGxhbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHBsYW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGNvbnZleEJvZHlcclxuICAgICAqIEBwYXJhbSAge0NvbnZleH0gY29udmV4U2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBjb252ZXhPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY29udmV4QW5nbGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqIEB0b2RvIG9ubHkgdXNlIHRoZSBkZWVwZXN0IGNvbnRhY3QgcG9pbnQgKyB0aGUgY29udGFjdCBwb2ludCBmdXJ0aGVzdCBhd2F5IGZyb20gaXRcclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5DT05WRVhdID1cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuQk9YXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVDb252ZXggPSBmdW5jdGlvbiAocGxhbmVCb2R5LCBwbGFuZVNoYXBlLCBwbGFuZU9mZnNldCwgcGxhbmVBbmdsZSwgY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleE9mZnNldCwgY29udmV4QW5nbGUsIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdmFyIHdvcmxkVmVydGV4ID0gdG1wMSwgd29ybGROb3JtYWwgPSB0bXAyLCBkaXN0ID0gdG1wMywgbG9jYWxQbGFuZU9mZnNldCA9IHRtcDQsIGxvY2FsUGxhbmVOb3JtYWwgPSB0bXA1LCBsb2NhbERpc3QgPSB0bXA2O1xyXG4gICAgICAgIHZhciBudW1SZXBvcnRlZCA9IDA7XHJcbiAgICAgICAgcm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XHJcbiAgICAgICAgLy8gR2V0IGNvbnZleC1sb2NhbCBwbGFuZSBvZmZzZXQgYW5kIG5vcm1hbFxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnZlY3RvclRvTG9jYWxGcmFtZShsb2NhbFBsYW5lTm9ybWFsLCB3b3JsZE5vcm1hbCwgY29udmV4QW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvTG9jYWxGcmFtZShsb2NhbFBsYW5lT2Zmc2V0LCBwbGFuZU9mZnNldCwgY29udmV4T2Zmc2V0LCBjb252ZXhBbmdsZSk7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gY29udmV4U2hhcGUudmVydGljZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG51bVZlcnRzID0gdmVydGljZXMubGVuZ3RoOyBpICE9PSBudW1WZXJ0czsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gdmVydGljZXNbaV07XHJcbiAgICAgICAgICAgIHN1Yihsb2NhbERpc3QsIHYsIGxvY2FsUGxhbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoZG90KGxvY2FsRGlzdCwgbG9jYWxQbGFuZU5vcm1hbCkgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKHdvcmxkVmVydGV4LCB2LCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgcGxhbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgLy8gRm91bmQgdmVydGV4XHJcbiAgICAgICAgICAgICAgICBudW1SZXBvcnRlZCsrO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksIGNvbnZleEJvZHksIHBsYW5lU2hhcGUsIGNvbnZleFNoYXBlKTtcclxuICAgICAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgcGxhbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgY29weShjLm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gZG90KGRpc3QsIGMubm9ybWFsQSk7XHJcbiAgICAgICAgICAgICAgICBzY2FsZShkaXN0LCBjLm5vcm1hbEEsIGQpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmogaXMgZnJvbSBjb252ZXggY2VudGVyIHRvIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHdvcmxkVmVydGV4LCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIC8vIHJpIGlzIGZyb20gcGxhbmUgY2VudGVyIHRvIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHdvcmxkVmVydGV4LCBkaXN0KTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uICYmIG51bVJlcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bVJlcG9ydGVkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bVJlcG9ydGVkO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTmFycm93cGhhc2UgZm9yIHBhcnRpY2xlIHZzIHBsYW5lXHJcbiAgICAgKiBAbWV0aG9kIHBhcnRpY2xlUGxhbmVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHBhcnRpY2xlQm9keVxyXG4gICAgICogQHBhcmFtICB7UGFydGljbGV9ICAgcGFydGljbGVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgcGFydGljbGVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHBsYW5lQm9keVxyXG4gICAgICogQHBhcmFtICB7UGxhbmV9ICAgICAgcGxhbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgcGxhbmVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIHBsYW5lQW5nbGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgIGp1c3RUZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuUExBTkVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5wYXJ0aWNsZVBsYW5lID0gZnVuY3Rpb24gKHBhcnRpY2xlQm9keSwgcGFydGljbGVTaGFwZSwgcGFydGljbGVPZmZzZXQsIHBsYW5lQm9keSwgcGxhbmVTaGFwZSwgcGxhbmVPZmZzZXQsIHBsYW5lQW5nbGUsIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdmFyIGRpc3QgPSB0bXAxLCB3b3JsZE5vcm1hbCA9IHRtcDI7XHJcbiAgICAgICAgcGxhbmVBbmdsZSA9IHBsYW5lQW5nbGUgfHwgMDtcclxuICAgICAgICBzdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIHBsYW5lT2Zmc2V0KTtcclxuICAgICAgICByb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcclxuICAgICAgICB2YXIgZCA9IGRvdChkaXN0LCB3b3JsZE5vcm1hbCk7XHJcbiAgICAgICAgaWYgKGQgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LCBwYXJ0aWNsZUJvZHksIHBsYW5lU2hhcGUsIHBhcnRpY2xlU2hhcGUpO1xyXG4gICAgICAgIGNvcHkoYy5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XHJcbiAgICAgICAgc2NhbGUoZGlzdCwgYy5ub3JtYWxBLCBkKTtcclxuICAgICAgICAvLyBkaXN0IGlzIG5vdyB0aGUgZGlzdGFuY2UgdmVjdG9yIGluIHRoZSBub3JtYWwgZGlyZWN0aW9uXHJcbiAgICAgICAgLy8gcmkgaXMgdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHByb2plY3RlZCBkb3duIG9udG8gdGhlIHBsYW5lLCBmcm9tIHRoZSBwbGFuZSBjZW50ZXJcclxuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZU9mZnNldCwgZGlzdCk7XHJcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgIC8vIHJqIGlzIGZyb20gdGhlIGJvZHkgY2VudGVyIHRvIHRoZSBwYXJ0aWNsZSBjZW50ZXJcclxuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBwYXJ0aWNsZU9mZnNldCwgcGFydGljbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaXJjbGUvUGFydGljbGUgTmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgY2lyY2xlUGFydGljbGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGNpcmNsZUJvZHlcclxuICAgICAqIEBwYXJhbSAge0NpcmNsZX0gY2lyY2xlU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBjaXJjbGVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IHBhcnRpY2xlQm9keVxyXG4gICAgICogQHBhcmFtICB7UGFydGljbGV9IHBhcnRpY2xlU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwYXJ0aWNsZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0ganVzdFRlc3RcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuUEFSVElDTEVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVQYXJ0aWNsZSA9IGZ1bmN0aW9uIChjaXJjbGVCb2R5LCBjaXJjbGVTaGFwZSwgY2lyY2xlT2Zmc2V0LCBwYXJ0aWNsZUJvZHksIHBhcnRpY2xlU2hhcGUsIHBhcnRpY2xlT2Zmc2V0LCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHZhciBkaXN0ID0gdG1wMTtcclxuICAgICAgICB2YXIgY2lyY2xlUmFkaXVzID0gY2lyY2xlU2hhcGUucmFkaXVzO1xyXG4gICAgICAgIHN1YihkaXN0LCBwYXJ0aWNsZU9mZnNldCwgY2lyY2xlT2Zmc2V0KTtcclxuICAgICAgICBpZiAoc3F1YXJlZExlbmd0aChkaXN0KSA+IGNpcmNsZVJhZGl1cyAqIGNpcmNsZVJhZGl1cykge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksIHBhcnRpY2xlQm9keSwgY2lyY2xlU2hhcGUsIHBhcnRpY2xlU2hhcGUpO1xyXG4gICAgICAgIHZhciBub3JtYWxBID0gYy5ub3JtYWxBO1xyXG4gICAgICAgIHZhciBjb250YWN0UG9pbnRBID0gYy5jb250YWN0UG9pbnRBO1xyXG4gICAgICAgIHZhciBjb250YWN0UG9pbnRCID0gYy5jb250YWN0UG9pbnRCO1xyXG4gICAgICAgIGNvcHkobm9ybWFsQSwgZGlzdCk7XHJcbiAgICAgICAgbm9ybWFsaXplKG5vcm1hbEEsIG5vcm1hbEEpO1xyXG4gICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcclxuICAgICAgICBzY2FsZShjb250YWN0UG9pbnRBLCBub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xyXG4gICAgICAgIGFkZChjb250YWN0UG9pbnRBLCBjb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xyXG4gICAgICAgIHN1Yihjb250YWN0UG9pbnRBLCBjb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAvLyBWZWN0b3IgZnJvbSBwYXJ0aWNsZSBjZW50ZXIgdG8gY29udGFjdCBwb2ludCBpcyB6ZXJvXHJcbiAgICAgICAgc3ViKGNvbnRhY3RQb2ludEIsIHBhcnRpY2xlT2Zmc2V0LCBwYXJ0aWNsZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgcGxhbmVDYXBzdWxlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBwbGFuZUJvZHlcclxuICAgICAqIEBwYXJhbSAge0NpcmNsZX0gcGxhbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHBsYW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGNhcHN1bGVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtQYXJ0aWNsZX0gY2Fwc3VsZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gY2Fwc3VsZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjYXBzdWxlQW5nbGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5DQVBTVUxFXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVDYXBzdWxlID0gZnVuY3Rpb24gKHBsYW5lQm9keSwgcGxhbmVTaGFwZSwgcGxhbmVPZmZzZXQsIHBsYW5lQW5nbGUsIGNhcHN1bGVCb2R5LCBjYXBzdWxlU2hhcGUsIGNhcHN1bGVPZmZzZXQsIGNhcHN1bGVBbmdsZSwganVzdFRlc3QpIHtcclxuICAgICAgICB2YXIgcGxhbmVDYXBzdWxlX3RtcENpcmNsZSA9IG5ldyBDaXJjbGVfMS5kZWZhdWx0KHsgcmFkaXVzOiAxIH0pO1xyXG4gICAgICAgIHZhciBlbmQxID0gcGxhbmVDYXBzdWxlX3RtcDEsIGVuZDIgPSBwbGFuZUNhcHN1bGVfdG1wMiwgY2lyY2xlID0gcGxhbmVDYXBzdWxlX3RtcENpcmNsZSwgaGFsZkxlbmd0aCA9IGNhcHN1bGVTaGFwZS5sZW5ndGggLyAyO1xyXG4gICAgICAgIC8vIENvbXB1dGUgd29ybGQgZW5kIHBvc2l0aW9uc1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChlbmQxLCAtaGFsZkxlbmd0aCwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGVuZDIsIGhhbGZMZW5ndGgsIDApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUoZW5kMSwgZW5kMSwgY2Fwc3VsZU9mZnNldCwgY2Fwc3VsZUFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKGVuZDIsIGVuZDIsIGNhcHN1bGVPZmZzZXQsIGNhcHN1bGVBbmdsZSk7XHJcbiAgICAgICAgY2lyY2xlLnJhZGl1cyA9IGNhcHN1bGVTaGFwZS5yYWRpdXM7XHJcbiAgICAgICAgdmFyIGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcclxuICAgICAgICAvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gTmFycm93cGhhc2UgYXMgdHdvIGNpcmNsZXNcclxuICAgICAgICB2YXIgbnVtQ29udGFjdHMxID0gdGhpcy5jaXJjbGVQbGFuZShjYXBzdWxlQm9keSwgY2lyY2xlLCBlbmQxLCBwbGFuZUJvZHksIHBsYW5lU2hhcGUsIHBsYW5lT2Zmc2V0LCBwbGFuZUFuZ2xlLCBqdXN0VGVzdCksIG51bUNvbnRhY3RzMiA9IHRoaXMuY2lyY2xlUGxhbmUoY2Fwc3VsZUJvZHksIGNpcmNsZSwgZW5kMiwgcGxhbmVCb2R5LCBwbGFuZVNoYXBlLCBwbGFuZU9mZnNldCwgcGxhbmVBbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgIC8vIFJlc3RvcmUgZnJpY3Rpb25cclxuICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtQ29udGFjdHMxICsgbnVtQ29udGFjdHMyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG51bVRvdGFsID0gbnVtQ29udGFjdHMxICsgbnVtQ29udGFjdHMyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bVRvdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Ub3RhbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudW1Ub3RhbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNpcmNsZVBsYW5lXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICBjaXJjbGVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDaXJjbGV9ICBjaXJjbGVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgY2lyY2xlT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICBwbGFuZUJvZHlcclxuICAgICAqIEBwYXJhbSAge1BsYW5lfSAgIHBsYW5lU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgIHBsYW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBwbGFuZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBqdXN0VGVzdFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5QTEFORV0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZVBsYW5lID0gZnVuY3Rpb24gKGNpcmNsZUJvZHksIGNpcmNsZVNoYXBlLCBjaXJjbGVPZmZzZXQsIHBsYW5lQm9keSwgcGxhbmVTaGFwZSwgcGxhbmVPZmZzZXQsIHBsYW5lQW5nbGUsIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdmFyIGNpcmNsZVJhZGl1cyA9IGNpcmNsZVNoYXBlLnJhZGl1cztcclxuICAgICAgICAvLyBWZWN0b3IgZnJvbSBwbGFuZSB0byBjaXJjbGVcclxuICAgICAgICB2YXIgcGxhbmVUb0NpcmNsZSA9IHRtcDEsIHdvcmxkTm9ybWFsID0gdG1wMiwgdGVtcCA9IHRtcDM7XHJcbiAgICAgICAgc3ViKHBsYW5lVG9DaXJjbGUsIGNpcmNsZU9mZnNldCwgcGxhbmVPZmZzZXQpO1xyXG4gICAgICAgIC8vIFdvcmxkIHBsYW5lIG5vcm1hbFxyXG4gICAgICAgIHJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xyXG4gICAgICAgIC8vIE5vcm1hbCBkaXJlY3Rpb24gZGlzdGFuY2VcclxuICAgICAgICB2YXIgZCA9IGRvdCh3b3JsZE5vcm1hbCwgcGxhbmVUb0NpcmNsZSk7XHJcbiAgICAgICAgaWYgKGQgPiBjaXJjbGVSYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIE5vIG92ZXJsYXAuIEFib3J0LlxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENyZWF0ZSBjb250YWN0XHJcbiAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksIGNpcmNsZUJvZHksIHBsYW5lU2hhcGUsIGNpcmNsZVNoYXBlKTtcclxuICAgICAgICAvLyBuaSBpcyB0aGUgcGxhbmUgd29ybGQgbm9ybWFsXHJcbiAgICAgICAgY29weShjb250YWN0Lm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcclxuICAgICAgICAvLyByaiBpcyB0aGUgdmVjdG9yIGZyb20gY2lyY2xlIGNlbnRlciB0byB0aGUgY29udGFjdCBwb2ludFxyXG4gICAgICAgIHZhciBjcEIgPSBjb250YWN0LmNvbnRhY3RQb2ludEI7XHJcbiAgICAgICAgc2NhbGUoY3BCLCBjb250YWN0Lm5vcm1hbEEsIC1jaXJjbGVSYWRpdXMpO1xyXG4gICAgICAgIGFkZChjcEIsIGNwQiwgY2lyY2xlT2Zmc2V0KTtcclxuICAgICAgICBzdWIoY3BCLCBjcEIsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgIC8vIHJpIGlzIHRoZSBkaXN0YW5jZSBmcm9tIHBsYW5lIGNlbnRlciB0byBjb250YWN0LlxyXG4gICAgICAgIHZhciBjcEEgPSBjb250YWN0LmNvbnRhY3RQb2ludEE7XHJcbiAgICAgICAgc2NhbGUodGVtcCwgY29udGFjdC5ub3JtYWxBLCBkKTtcclxuICAgICAgICBzdWIoY3BBLCBwbGFuZVRvQ2lyY2xlLCB0ZW1wKTsgLy8gU3VidHJhY3Qgbm9ybWFsIGRpc3RhbmNlIHZlY3RvciBmcm9tIHRoZSBkaXN0YW5jZSB2ZWN0b3JcclxuICAgICAgICBhZGQoY3BBLCBjcEEsIHBsYW5lT2Zmc2V0KTtcclxuICAgICAgICBzdWIoY3BBLCBjcEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goY29udGFjdCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjb250YWN0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8vIEZpbmQgZWRnZSBub3JtYWwgb2YgbWF4IHNlcGFyYXRpb24gb24gQSAtIHJldHVybiBpZiBzZXBhcmF0aW5nIGF4aXMgaXMgZm91bmRcclxuICAgIC8vIEZpbmQgZWRnZSBub3JtYWwgb2YgbWF4IHNlcGFyYXRpb24gb24gQiAtIHJldHVybiBpZiBzZXBhcmF0aW9uIGF4aXMgaXMgZm91bmRcclxuICAgIC8vIENob29zZSByZWZlcmVuY2UgZWRnZSBhcyBtaW4obWluQSwgbWluQilcclxuICAgIC8vIEZpbmQgaW5jaWRlbnQgZWRnZVxyXG4gICAgLy8gQ2xpcFxyXG4gICAgLy8gVGhlIG5vcm1hbCBwb2ludHMgZnJvbSAxIHRvIDJcclxuICAgIC8qZnVuY3Rpb24gY29sbGlkZVBvbHlnb25zKFxyXG4gICAgICAgIG1hbmlmb2xkLFxyXG4gICAgICAgIHBvbHlBLCBwb3NpdGlvbkEsIGFuZ2xlQSxcclxuICAgICAgICBwb2x5QiwgcG9zaXRpb25CLCBhbmdsZUIsXHJcbiAgICAgICAgaW5jaWRlbnRFZGdlXHJcbiAgICApIHsqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXgvY29udmV4IE5hcnJvd3BoYXNlLlNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy5hbHRkZXZibG9nYWRheS5jb20vMjAxMS8wNS8xMy9jb250YWN0LWdlbmVyYXRpb24tYmV0d2Vlbi0zZC1jb252ZXgtbWVzaGVzL1wiPnRoaXMgYXJ0aWNsZTwvYT4gZm9yIG1vcmUgaW5mby5cclxuICAgICAqIEBtZXRob2QgY29udmV4Q29udmV4XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBiaVxyXG4gICAgICogQHBhcmFtICB7Q29udmV4fSBzaVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHhpXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFpXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBialxyXG4gICAgICogQHBhcmFtICB7Q29udmV4fSBzalxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHhqXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFqXHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBqdXN0VGVzdFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVhdID1cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLkJPWF0gPVxyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQk9YXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4Q29udmV4ID0gZnVuY3Rpb24gKGJvZHlBLCBwb2x5QSwgcG9zaXRpb25BLCBhbmdsZUEsIGJvZHlCLCBwb2x5QiwgcG9zaXRpb25CLCBhbmdsZUIsIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdmFyIG1heE1hbmlmb2xkUG9pbnRzID0gMjtcclxuICAgICAgICB2YXIgdG90YWxSYWRpdXMgPSAwO1xyXG4gICAgICAgIHZhciBkaXN0ID0gY29sbGlkZVBvbHlnb25zX2Rpc3Q7XHJcbiAgICAgICAgdmFyIHRlbXBWZWMgPSBjb2xsaWRlUG9seWdvbnNfdGVtcFZlYztcclxuICAgICAgICB2YXIgdG1wVmVjID0gY29sbGlkZVBvbHlnb25zX3RtcFZlYztcclxuICAgICAgICB2YXIgZWRnZUEgPSBmaW5kTWF4U2VwYXJhdGlvbih0ZW1wVmVjLCBwb2x5QSwgcG9zaXRpb25BLCBhbmdsZUEsIHBvbHlCLCBwb3NpdGlvbkIsIGFuZ2xlQik7XHJcbiAgICAgICAgdmFyIHNlcGFyYXRpb25BID0gdGVtcFZlY1swXTtcclxuICAgICAgICBpZiAoc2VwYXJhdGlvbkEgPiB0b3RhbFJhZGl1cykge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVkZ2VCID0gZmluZE1heFNlcGFyYXRpb24odG1wVmVjLCBwb2x5QiwgcG9zaXRpb25CLCBhbmdsZUIsIHBvbHlBLCBwb3NpdGlvbkEsIGFuZ2xlQSk7XHJcbiAgICAgICAgdmFyIHNlcGFyYXRpb25CID0gdG1wVmVjWzBdO1xyXG4gICAgICAgIGlmIChzZXBhcmF0aW9uQiA+IHRvdGFsUmFkaXVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcG9seTE7IC8vIHJlZmVyZW5jZSBwb2x5Z29uXHJcbiAgICAgICAgdmFyIHBvbHkyOyAvLyBpbmNpZGVudCBwb2x5Z29uXHJcbiAgICAgICAgdmFyIHBvc2l0aW9uMTtcclxuICAgICAgICB2YXIgcG9zaXRpb24yO1xyXG4gICAgICAgIHZhciBhbmdsZTE7XHJcbiAgICAgICAgdmFyIGFuZ2xlMjtcclxuICAgICAgICB2YXIgYm9keTE7XHJcbiAgICAgICAgdmFyIGJvZHkyO1xyXG4gICAgICAgIHZhciBlZGdlMTsgLy8gcmVmZXJlbmNlIGVkZ2VcclxuICAgICAgICB2YXIgdHlwZTtcclxuICAgICAgICBpZiAoc2VwYXJhdGlvbkIgPiBzZXBhcmF0aW9uQSkge1xyXG4gICAgICAgICAgICBwb2x5MSA9IHBvbHlCO1xyXG4gICAgICAgICAgICBwb2x5MiA9IHBvbHlBO1xyXG4gICAgICAgICAgICBib2R5MSA9IGJvZHlCO1xyXG4gICAgICAgICAgICBib2R5MiA9IGJvZHlBO1xyXG4gICAgICAgICAgICBwb3NpdGlvbjEgPSBwb3NpdGlvbkI7XHJcbiAgICAgICAgICAgIGFuZ2xlMSA9IGFuZ2xlQjtcclxuICAgICAgICAgICAgcG9zaXRpb24yID0gcG9zaXRpb25BO1xyXG4gICAgICAgICAgICBhbmdsZTIgPSBhbmdsZUE7XHJcbiAgICAgICAgICAgIGVkZ2UxID0gZWRnZUI7XHJcbiAgICAgICAgICAgIHR5cGUgPSAxOyAvLyBmYWNlQlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcG9seTEgPSBwb2x5QTtcclxuICAgICAgICAgICAgcG9seTIgPSBwb2x5QjtcclxuICAgICAgICAgICAgYm9keTEgPSBib2R5QTtcclxuICAgICAgICAgICAgYm9keTIgPSBib2R5QjtcclxuICAgICAgICAgICAgcG9zaXRpb24xID0gcG9zaXRpb25BO1xyXG4gICAgICAgICAgICBhbmdsZTEgPSBhbmdsZUE7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uMiA9IHBvc2l0aW9uQjtcclxuICAgICAgICAgICAgYW5nbGUyID0gYW5nbGVCO1xyXG4gICAgICAgICAgICBlZGdlMSA9IGVkZ2VBO1xyXG4gICAgICAgICAgICB0eXBlID0gMDsgLy8gZmFjZUFcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluY2lkZW50RWRnZSA9IGNvbGxpZGVQb2x5Z29uc19pbmNpZGVudEVkZ2U7XHJcbiAgICAgICAgZmluZEluY2lkZW50RWRnZShpbmNpZGVudEVkZ2UsIHBvbHkxLCBwb3NpdGlvbjEsIGFuZ2xlMSwgZWRnZTEsIHBvbHkyLCBwb3NpdGlvbjIsIGFuZ2xlMik7XHJcbiAgICAgICAgdmFyIGNvdW50MSA9IHBvbHkxLnZlcnRpY2VzLmxlbmd0aDtcclxuICAgICAgICB2YXIgdmVydGljZXMxID0gcG9seTEudmVydGljZXM7XHJcbiAgICAgICAgdmFyIGl2MSA9IGVkZ2UxO1xyXG4gICAgICAgIHZhciBpdjIgPSBlZGdlMSArIDEgPCBjb3VudDEgPyBlZGdlMSArIDEgOiAwO1xyXG4gICAgICAgIHZhciB2MTEgPSBjb2xsaWRlUG9seWdvbnNfdjExO1xyXG4gICAgICAgIHZhciB2MTIgPSBjb2xsaWRlUG9seWdvbnNfdjEyO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkodjExLCB2ZXJ0aWNlczFbaXYxXSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh2MTIsIHZlcnRpY2VzMVtpdjJdKTtcclxuICAgICAgICB2YXIgbG9jYWxUYW5nZW50ID0gY29sbGlkZVBvbHlnb25zX2xvY2FsVGFuZ2VudDtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChsb2NhbFRhbmdlbnQsIHYxMiwgdjExKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUobG9jYWxUYW5nZW50LCBsb2NhbFRhbmdlbnQpO1xyXG4gICAgICAgIHZhciBsb2NhbE5vcm1hbCA9IGNvbGxpZGVQb2x5Z29uc19sb2NhbE5vcm1hbDtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jcm9zc1ZaKGxvY2FsTm9ybWFsLCBsb2NhbFRhbmdlbnQsIDEuMCk7XHJcbiAgICAgICAgdmFyIHBsYW5lUG9pbnQgPSBjb2xsaWRlUG9seWdvbnNfcGxhbmVQb2ludDtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQocGxhbmVQb2ludCwgdjExLCB2MTIpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKHBsYW5lUG9pbnQsIHBsYW5lUG9pbnQsIDAuNSk7XHJcbiAgICAgICAgdmFyIHRhbmdlbnQgPSBjb2xsaWRlUG9seWdvbnNfdGFuZ2VudDsgLy8gdGFuZ2VudCBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh0YW5nZW50LCBsb2NhbFRhbmdlbnQsIGFuZ2xlMSk7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IGNvbGxpZGVQb2x5Z29uc19ub3JtYWw7IC8vIG5vcm1hbCBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNyb3NzVloobm9ybWFsLCB0YW5nZW50LCAxLjApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUodjExLCB2MTEsIHBvc2l0aW9uMSwgYW5nbGUxKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKHYxMiwgdjEyLCBwb3NpdGlvbjEsIGFuZ2xlMSk7XHJcbiAgICAgICAgLy8gRmFjZSBvZmZzZXQuXHJcbiAgICAgICAgdmFyIGZyb250T2Zmc2V0ID0gdmVjMl8xLmRlZmF1bHQuZG90KG5vcm1hbCwgdjExKTtcclxuICAgICAgICAvLyBTaWRlIG9mZnNldHMsIGV4dGVuZGVkIGJ5IHBvbHl0b3BlIHNraW4gdGhpY2tuZXNzLlxyXG4gICAgICAgIHZhciBzaWRlT2Zmc2V0MSA9IC12ZWMyXzEuZGVmYXVsdC5kb3QodGFuZ2VudCwgdjExKSArIHRvdGFsUmFkaXVzO1xyXG4gICAgICAgIHZhciBzaWRlT2Zmc2V0MiA9IHZlYzJfMS5kZWZhdWx0LmRvdCh0YW5nZW50LCB2MTIpICsgdG90YWxSYWRpdXM7XHJcbiAgICAgICAgLy8gQ2xpcCBpbmNpZGVudCBlZGdlIGFnYWluc3QgZXh0cnVkZWQgZWRnZTEgc2lkZSBlZGdlcy5cclxuICAgICAgICB2YXIgY2xpcFBvaW50czEgPSBjb2xsaWRlUG9seWdvbnNfY2xpcFBvaW50czE7XHJcbiAgICAgICAgdmFyIGNsaXBQb2ludHMyID0gY29sbGlkZVBvbHlnb25zX2NsaXBQb2ludHMyO1xyXG4gICAgICAgIHZhciBucCA9IDA7XHJcbiAgICAgICAgLy8gQ2xpcCB0byBib3ggc2lkZSAxXHJcbiAgICAgICAgdmFyIG5lZ2F0aXZlVGFuZ2VudCA9IGNvbGxpZGVQb2x5Z29uc19uZWdhdGl2ZVRhbmdlbnQ7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUobmVnYXRpdmVUYW5nZW50LCB0YW5nZW50LCAtMSk7XHJcbiAgICAgICAgbnAgPSBjbGlwU2VnbWVudFRvTGluZShjbGlwUG9pbnRzMSwgaW5jaWRlbnRFZGdlLCBuZWdhdGl2ZVRhbmdlbnQsIHNpZGVPZmZzZXQxIC8qLCBpdjEqLyk7XHJcbiAgICAgICAgaWYgKG5wIDwgMikge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xpcCB0byBuZWdhdGl2ZSBib3ggc2lkZSAxXHJcbiAgICAgICAgbnAgPSBjbGlwU2VnbWVudFRvTGluZShjbGlwUG9pbnRzMiwgY2xpcFBvaW50czEsIHRhbmdlbnQsIHNpZGVPZmZzZXQyIC8qLCBpdjIqLyk7XHJcbiAgICAgICAgaWYgKG5wIDwgMikge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvaW50Q291bnQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4TWFuaWZvbGRQb2ludHM7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IHZlYzJfMS5kZWZhdWx0LmRvdChub3JtYWwsIGNsaXBQb2ludHMyW2ldKSAtIGZyb250T2Zmc2V0O1xyXG4gICAgICAgICAgICBpZiAoc2VwYXJhdGlvbiA8PSB0b3RhbFJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICArK3BvaW50Q291bnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJvZHkxLCBib2R5MiwgcG9seTEsIHBvbHkyKTtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkoYy5ub3JtYWxBLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShjLmNvbnRhY3RQb2ludEIsIGNsaXBQb2ludHMyW2ldKTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgYm9keTIucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUoZGlzdCwgbm9ybWFsLCAtc2VwYXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQoYy5jb250YWN0UG9pbnRBLCBjbGlwUG9pbnRzMltpXSwgZGlzdCk7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGJvZHkxLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24gJiYgIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9pbnRDb3VudCAmJiB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uICYmIHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShwb2ludENvdW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb2ludENvdW50O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkhFSUdIVEZJRUxEXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlSGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiAoY2lyY2xlQm9keSwgY2lyY2xlU2hhcGUsIGNpcmNsZVBvcywgaGZCb2R5LCBoZlNoYXBlLCBoZlBvcywganVzdFRlc3QsIHJhZGl1cykge1xyXG4gICAgICAgIHZhciBkYXRhID0gaGZTaGFwZS5oZWlnaHRzLCB3ID0gaGZTaGFwZS5lbGVtZW50V2lkdGgsIGRpc3QgPSBjaXJjbGVIZWlnaHRmaWVsZF9kaXN0LCBjYW5kaWRhdGUgPSBjaXJjbGVIZWlnaHRmaWVsZF9jYW5kaWRhdGUsIG1pbkNhbmRpZGF0ZSA9IGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZSwgbWluQ2FuZGlkYXRlTm9ybWFsID0gY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlTm9ybWFsLCB3b3JsZE5vcm1hbCA9IGNpcmNsZUhlaWdodGZpZWxkX3dvcmxkTm9ybWFsLCB2MCA9IGNpcmNsZUhlaWdodGZpZWxkX3YwLCB2MSA9IGNpcmNsZUhlaWdodGZpZWxkX3YxO1xyXG4gICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcclxuICAgICAgICB2YXIgaWR4QSA9IE1hdGguZmxvb3IoKGNpcmNsZVBvc1swXSAtIHJhZGl1cyAtIGhmUG9zWzBdKSAvIHcpLCBpZHhCID0gTWF0aC5jZWlsKChjaXJjbGVQb3NbMF0gKyByYWRpdXMgLSBoZlBvc1swXSkgLyB3KTtcclxuICAgICAgICAvKmlmKGlkeEIgPCAwIHx8IGlkeEEgPj0gZGF0YS5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBqdXN0VGVzdCA/IGZhbHNlIDogMDsqL1xyXG4gICAgICAgIGlmIChpZHhBIDwgMCkge1xyXG4gICAgICAgICAgICBpZHhBID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlkeEIgPj0gZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWR4QiA9IGRhdGEubGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IG1heCBhbmQgbWluXHJcbiAgICAgICAgdmFyIG1heCA9IGRhdGFbaWR4QV0sIG1pbiA9IGRhdGFbaWR4Ql07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGlkeEE7IGkgPCBpZHhCOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFbaV0gPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgIG1pbiA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGFbaV0gPiBtYXgpIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNpcmNsZVBvc1sxXSAtIHJhZGl1cyA+IG1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICBpZihjaXJjbGVQb3NbMV0rcmFkaXVzIDwgbWluKXtcclxuICAgICAgICAgICAgLy8gQmVsb3cgdGhlIG1pbmltdW0gcG9pbnQuLi4gV2UgY2FuIGp1c3QgZ3Vlc3MuXHJcbiAgICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuICAgICAgICAvLyAxLiBDaGVjayBzbyBjZW50ZXIgb2YgY2lyY2xlIGlzIG5vdCBpbnNpZGUgdGhlIGZpZWxkLiBJZiBpdCBpcywgdGhpcyB3b250IHdvcmsuLi5cclxuICAgICAgICAvLyAyLiBGb3IgZWFjaCBlZGdlXHJcbiAgICAgICAgLy8gMi4gMS4gR2V0IHBvaW50IG9uIGNpcmNsZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGVkZ2UgKHNjYWxlIG5vcm1hbCB3aXRoIC1yYWRpdXMpXHJcbiAgICAgICAgLy8gMi4gMi4gQ2hlY2sgaWYgcG9pbnQgaXMgaW5zaWRlLlxyXG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIENoZWNrIGFsbCBlZGdlcyBmaXJzdFxyXG4gICAgICAgIGZvciAodmFyIGkgPSBpZHhBOyBpIDwgaWR4QjsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBwb2ludHNcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHYwLCBpICogdywgZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh2MSwgKGkgKyAxKSAqIHcsIGRhdGFbaSArIDFdKTtcclxuICAgICAgICAgICAgYWRkKHYwLCB2MCwgaGZQb3MpOyAvLyBAdG9kbyB0cmFuc2Zvcm0gY2lyY2xlIHRvIGxvY2FsIGhlaWdodGZpZWxkIHNwYWNlIGluc3RlYWRcclxuICAgICAgICAgICAgYWRkKHYxLCB2MSwgaGZQb3MpO1xyXG4gICAgICAgICAgICAvLyBHZXQgbm9ybWFsXHJcbiAgICAgICAgICAgIHN1Yih3b3JsZE5vcm1hbCwgdjEsIHYwKTtcclxuICAgICAgICAgICAgcm90YXRlKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCwgTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgICAgICBub3JtYWxpemUod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsKTtcclxuICAgICAgICAgICAgLy8gR2V0IHBvaW50IG9uIGNpcmNsZSwgY2xvc2VzdCB0byB0aGUgZWRnZVxyXG4gICAgICAgICAgICBzY2FsZShjYW5kaWRhdGUsIHdvcmxkTm9ybWFsLCAtcmFkaXVzKTtcclxuICAgICAgICAgICAgYWRkKGNhbmRpZGF0ZSwgY2FuZGlkYXRlLCBjaXJjbGVQb3MpO1xyXG4gICAgICAgICAgICAvLyBEaXN0YW5jZSBmcm9tIHYwIHRvIHRoZSBjYW5kaWRhdGUgcG9pbnRcclxuICAgICAgICAgICAgc3ViKGRpc3QsIGNhbmRpZGF0ZSwgdjApO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCBpcyBpbiB0aGUgZWxlbWVudCBcInN0aWNrXCJcclxuICAgICAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGROb3JtYWwpO1xyXG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlWzBdID49IHYwWzBdICYmIGNhbmRpZGF0ZVswXSA8IHYxWzBdICYmIGQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgY2FuZGlkYXRlIHBvaW50LCBwcm9qZWN0ZWQgdG8gdGhlIGVkZ2VcclxuICAgICAgICAgICAgICAgIHNjYWxlKGRpc3QsIHdvcmxkTm9ybWFsLCAtZCk7XHJcbiAgICAgICAgICAgICAgICBhZGQobWluQ2FuZGlkYXRlLCBjYW5kaWRhdGUsIGRpc3QpO1xyXG4gICAgICAgICAgICAgICAgY29weShtaW5DYW5kaWRhdGVOb3JtYWwsIHdvcmxkTm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oaGZCb2R5LCBjaXJjbGVCb2R5LCBoZlNoYXBlLCBjaXJjbGVTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgaXMgb3V0IG9mIHRoZSBoZWlnaHRmaWVsZFxyXG4gICAgICAgICAgICAgICAgY29weShjLm5vcm1hbEEsIG1pbkNhbmRpZGF0ZU5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gaGVpZ2h0ZmllbGRcclxuICAgICAgICAgICAgICAgIHNjYWxlKGMuY29udGFjdFBvaW50QiwgYy5ub3JtYWxBLCAtcmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlUG9zKTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBjb3B5KGMuY29udGFjdFBvaW50QSwgbWluQ2FuZGlkYXRlKTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBhbGwgdmVydGljZXNcclxuICAgICAgICBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChyYWRpdXMgPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBpZHhBOyBpIDw9IGlkeEI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHBvaW50XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodjAsIGkgKiB3LCBkYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgIGFkZCh2MCwgdjAsIGhmUG9zKTtcclxuICAgICAgICAgICAgICAgIHN1YihkaXN0LCBjaXJjbGVQb3MsIHYwKTtcclxuICAgICAgICAgICAgICAgIGlmIChzcXVhcmVkTGVuZ3RoKGRpc3QpIDwgTWF0aC5wb3cocmFkaXVzLCAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oaGZCb2R5LCBjaXJjbGVCb2R5LCBoZlNoYXBlLCBjaXJjbGVTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IG5vcm1hbCAtIG91dCBvZiBoZWlnaHRmaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlKGMuY29udGFjdFBvaW50QiwgYy5ub3JtYWxBLCAtcmFkaXVzKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZVBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCB2MCwgaGZQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5CT1ggfCBTaGFwZS5IRUlHSFRGSUVMRF0gPVxyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ09OVkVYIHwgU2hhcGUuSEVJR0hURklFTERdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uIChjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4UG9zLCBjb252ZXhBbmdsZSwgaGZCb2R5LCBoZlNoYXBlLCBoZlBvcywganVzdFRlc3QpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IGhmU2hhcGUuaGVpZ2h0cywgdyA9IGhmU2hhcGUuZWxlbWVudFdpZHRoLCB2MCA9IGNvbnZleEhlaWdodGZpZWxkX3YwLCB2MSA9IGNvbnZleEhlaWdodGZpZWxkX3YxLCB0aWxlUG9zID0gY29udmV4SGVpZ2h0ZmllbGRfdGlsZVBvcywgdGlsZUNvbnZleCA9IGNvbnZleEhlaWdodGZpZWxkX3RlbXBDb252ZXhTaGFwZTtcclxuICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XHJcbiAgICAgICAgdmFyIGlkeEEgPSBNYXRoLmZsb29yKChjb252ZXhCb2R5LmFhYmIubG93ZXJCb3VuZFswXSAtIGhmUG9zWzBdKSAvIHcpLCBpZHhCID0gTWF0aC5jZWlsKChjb252ZXhCb2R5LmFhYmIudXBwZXJCb3VuZFswXSAtIGhmUG9zWzBdKSAvIHcpO1xyXG4gICAgICAgIGlmIChpZHhBIDwgMCkge1xyXG4gICAgICAgICAgICBpZHhBID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlkeEIgPj0gZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWR4QiA9IGRhdGEubGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IG1heCBhbmQgbWluXHJcbiAgICAgICAgdmFyIG1heCA9IGRhdGFbaWR4QV0sIG1pbiA9IGRhdGFbaWR4Ql07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGlkeEE7IGkgPCBpZHhCOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFbaV0gPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgIG1pbiA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGFbaV0gPiBtYXgpIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnZleEJvZHkuYWFiYi5sb3dlckJvdW5kWzFdID4gbWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbnVtQ29udGFjdHMgPSAwO1xyXG4gICAgICAgIC8vIExvb3Agb3ZlciBhbGwgZWRnZXNcclxuICAgICAgICAvLyBAdG9kbyBJZiBwb3NzaWJsZSwgY29uc3RydWN0IGEgY29udmV4IGZyb20gc2V2ZXJhbCBkYXRhIHBvaW50cyAobmVlZCBvIGNoZWNrIGlmIHRoZSBwb2ludHMgbWFrZSBhIGNvbnZleCBzaGFwZSlcclxuICAgICAgICAvLyBAdG9kbyB0cmFuc2Zvcm0gY29udmV4IHRvIGxvY2FsIGhlaWdodGZpZWxkIHNwYWNlLlxyXG4gICAgICAgIC8vIEB0b2RvIGJhaWwgb3V0IGlmIHRoZSBoZWlnaHRmaWVsZCB0aWxlIGlzIG5vdCB0YWxsIGVub3VnaC5cclxuICAgICAgICBmb3IgKHZhciBpID0gaWR4QTsgaSA8IGlkeEI7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBHZXQgcG9pbnRzXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh2MCwgaSAqIHcsIGRhdGFbaV0pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodjEsIChpICsgMSkgKiB3LCBkYXRhW2kgKyAxXSk7XHJcbiAgICAgICAgICAgIGFkZCh2MCwgdjAsIGhmUG9zKTtcclxuICAgICAgICAgICAgYWRkKHYxLCB2MSwgaGZQb3MpO1xyXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgYSBjb252ZXhcclxuICAgICAgICAgICAgdmFyIHRpbGVIZWlnaHQgPSAxMDA7IC8vIHRvZG9cclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHRpbGVQb3MsICh2MVswXSArIHYwWzBdKSAqIDAuNSwgKHYxWzFdICsgdjBbMV0gLSB0aWxlSGVpZ2h0KSAqIDAuNSk7XHJcbiAgICAgICAgICAgIHN1Yih0aWxlQ29udmV4LnZlcnRpY2VzWzBdLCB2MSwgdGlsZVBvcyk7XHJcbiAgICAgICAgICAgIHN1Yih0aWxlQ29udmV4LnZlcnRpY2VzWzFdLCB2MCwgdGlsZVBvcyk7XHJcbiAgICAgICAgICAgIGNvcHkodGlsZUNvbnZleC52ZXJ0aWNlc1syXSwgdGlsZUNvbnZleC52ZXJ0aWNlc1sxXSk7XHJcbiAgICAgICAgICAgIGNvcHkodGlsZUNvbnZleC52ZXJ0aWNlc1szXSwgdGlsZUNvbnZleC52ZXJ0aWNlc1swXSk7XHJcbiAgICAgICAgICAgIHRpbGVDb252ZXgudmVydGljZXNbMl1bMV0gLT0gdGlsZUhlaWdodDtcclxuICAgICAgICAgICAgdGlsZUNvbnZleC52ZXJ0aWNlc1szXVsxXSAtPSB0aWxlSGVpZ2h0O1xyXG4gICAgICAgICAgICB0aWxlQ29udmV4LnVwZGF0ZU5vcm1hbHMoKTtcclxuICAgICAgICAgICAgLy8gRG8gY29udmV4IGNvbGxpc2lvblxyXG4gICAgICAgICAgICBudW1Db250YWN0cyArPSB0aGlzLmNvbnZleENvbnZleChjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4UG9zLCBjb252ZXhBbmdsZSwgaGZCb2R5LCB0aWxlQ29udmV4LCB0aWxlUG9zLCAwLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudW1Db250YWN0cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gTmFycm93cGhhc2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE5hcnJvd3BoYXNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgaW50ZXJzZWN0Qm9keV93b3JsZFBvc2l0aW9uID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciB2MCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBpbnRlcnNlY3QgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIFJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQSBsaW5lIHdpdGggYSBzdGFydCBhbmQgZW5kIHBvaW50IHRoYXQgaXMgdXNlZCB0byBpbnRlcnNlY3Qgc2hhcGVzLiBGb3IgYW4gZXhhbXBsZSwgc2VlIHt7I2Nyb3NzTGluayBcIldvcmxkL3JheWNhc3Q6bWV0aG9kXCJ9fVdvcmxkLnJheWNhc3R7ey9jcm9zc0xpbmt9fVxyXG4gICAgICogQGNsYXNzIFJheVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBbb3B0aW9ucy5mcm9tXVxyXG4gICAgICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMudG9dXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25NYXNrPS0xXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkdyb3VwPS0xXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1vZGU9UmF5LkFOWV1cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSYXkob3B0aW9ucykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZWFkT25seVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGRpcmVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVuZ3RoIG9mIHRoZSByYXlcclxuICAgICAgICAgKiBAcmVhZE9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbGVuZ3RoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcclxuICAgICAgICB0aGlzLmZyb20gPSBvcHRpb25zLmZyb20gPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLmZyb20pIDogdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy50byA9IG9wdGlvbnMudG8gPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLnRvKSA6IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IG9wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlIDogdHJ1ZTtcclxuICAgICAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSAhIW9wdGlvbnMuc2tpcEJhY2tmYWNlcztcclxuICAgICAgICB0aGlzLmNvbGxpc2lvbk1hc2sgPSBvcHRpb25zLmNvbGxpc2lvbk1hc2sgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGlzaW9uTWFzayA6IC0xO1xyXG4gICAgICAgIHRoaXMuY29sbGlzaW9uR3JvdXAgPSBvcHRpb25zLmNvbGxpc2lvbkdyb3VwICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbkdyb3VwIDogLTE7XHJcbiAgICAgICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1vZGUgOiBSYXkuQU5ZO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uICggLypyZXN1bHQqLykgeyB9O1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3VsZCBiZSBjYWxsZWQgaWYgeW91IGNoYW5nZSB0aGUgZnJvbSBvciB0byBwb2ludC5cclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIFJheS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFVwZGF0ZSAuZGlyZWN0aW9uIGFuZCAubGVuZ3RoXHJcbiAgICAgICAgdmFyIGQgPSB0aGlzLmRpcmVjdGlvbjtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChkLCB0aGlzLnRvLCB0aGlzLmZyb20pO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gdmVjMl8xLmRlZmF1bHQubGVuZ3RoKGQpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZShkLCBkKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgaW50ZXJzZWN0Qm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBib2RpZXMgQW4gYXJyYXkgb2YgQm9keSBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICBSYXkucHJvdG90eXBlLmludGVyc2VjdEJvZGllcyA9IGZ1bmN0aW9uIChyZXN1bHQsIGJvZGllcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYm9kaWVzLmxlbmd0aDsgIXJlc3VsdC5zaG91bGRTdG9wKHRoaXMpICYmIGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIHZhciBhYWJiID0gYm9keS5nZXRBQUJCKCk7XHJcbiAgICAgICAgICAgIGlmIChhYWJiLm92ZXJsYXBzUmF5KHRoaXMpID49IDAgfHwgYWFiYi5jb250YWluc1BvaW50KHRoaXMuZnJvbSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0Qm9keShyZXN1bHQsIGJvZHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2hvb3QgYSByYXkgYXQgYSBib2R5LCBnZXQgYmFjayBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaGl0LlxyXG4gICAgICogQG1ldGhvZCBpbnRlcnNlY3RCb2R5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAgICAgKi9cclxuICAgIFJheS5wcm90b3R5cGUuaW50ZXJzZWN0Qm9keSA9IGZ1bmN0aW9uIChyZXN1bHQsIGJvZHkpIHtcclxuICAgICAgICB2YXIgY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZTtcclxuICAgICAgICBpZiAoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhYm9keS5jb2xsaXNpb25SZXNwb25zZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3b3JsZFBvc2l0aW9uID0gaW50ZXJzZWN0Qm9keV93b3JsZFBvc2l0aW9uO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBOID0gYm9keS5zaGFwZXMubGVuZ3RoOyBpIDwgTjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGJvZHkuc2hhcGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhc2hhcGUuY29sbGlzaW9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCh0aGlzLmNvbGxpc2lvbkdyb3VwICYgc2hhcGUuY29sbGlzaW9uTWFzaykgPT09IDAgfHwgKHNoYXBlLmNvbGxpc2lvbkdyb3VwICYgdGhpcy5jb2xsaXNpb25NYXNrKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR2V0IHdvcmxkIGFuZ2xlIGFuZCBwb3NpdGlvbiBvZiB0aGUgc2hhcGVcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHdvcmxkUG9zaXRpb24sIHNoYXBlLnBvc2l0aW9uLCBib2R5LmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKHdvcmxkUG9zaXRpb24sIHdvcmxkUG9zaXRpb24sIGJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgd29ybGRBbmdsZSA9IHNoYXBlLmFuZ2xlICsgYm9keS5hbmdsZTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3RTaGFwZShyZXN1bHQsIHNoYXBlLCB3b3JsZEFuZ2xlLCB3b3JsZFBvc2l0aW9uLCBib2R5KTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zaG91bGRTdG9wKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgaW50ZXJzZWN0U2hhcGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAgICAgKi9cclxuICAgIFJheS5wcm90b3R5cGUuaW50ZXJzZWN0U2hhcGUgPSBmdW5jdGlvbiAocmVzdWx0LCBzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLmZyb207XHJcbiAgICAgICAgLy8gQ2hlY2tpbmcgcmFkaXVzXHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uU3F1YXJlZChmcm9tLCB0aGlzLmRpcmVjdGlvbiwgcG9zaXRpb24pO1xyXG4gICAgICAgIGlmIChkaXN0YW5jZSA+IHNoYXBlLmJvdW5kaW5nUmFkaXVzICogc2hhcGUuYm91bmRpbmdSYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jdXJyZW50Qm9keSA9IGJvZHk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFNoYXBlID0gc2hhcGU7XHJcbiAgICAgICAgc2hhcGUucmF5Y2FzdChyZXN1bHQsIHRoaXMsIHBvc2l0aW9uLCBhbmdsZSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEJvZHkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFNoYXBlID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBBQUJCIG9mIHRoZSByYXkuXHJcbiAgICAgKiBAbWV0aG9kIGdldEFBQkJcclxuICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICAgICAqL1xyXG4gICAgUmF5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIHZhciB0byA9IHRoaXMudG87XHJcbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLmZyb207XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHJlc3VsdC5sb3dlckJvdW5kLCBNYXRoLm1pbih0b1swXSwgZnJvbVswXSksIE1hdGgubWluKHRvWzFdLCBmcm9tWzFdKSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHJlc3VsdC51cHBlckJvdW5kLCBNYXRoLm1heCh0b1swXSwgZnJvbVswXSksIE1hdGgubWF4KHRvWzFdLCBmcm9tWzFdKSk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHJlcG9ydEludGVyc2VjdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gZnJhY3Rpb25cclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBub3JtYWxcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW2ZhY2VJbmRleD0tMV1cclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGludGVyc2VjdGlvbnMgc2hvdWxkIGNvbnRpbnVlIC8vIFRoaXMgbmV2ZXIgcmV0dXJuZWQgYW55dGhpbmcuXHJcbiAgICAgKi9cclxuICAgIFJheS5wcm90b3R5cGUucmVwb3J0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHJlc3VsdCwgZnJhY3Rpb24sIG5vcm1hbCwgZmFjZUluZGV4KSB7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5fY3VycmVudFNoYXBlO1xyXG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5fY3VycmVudEJvZHk7XHJcbiAgICAgICAgLy8gU2tpcCBiYWNrIGZhY2VzP1xyXG4gICAgICAgIGlmICh0aGlzLnNraXBCYWNrZmFjZXMgJiYgdmVjMl8xLmRlZmF1bHQuZG90KG5vcm1hbCwgdGhpcy5kaXJlY3Rpb24pID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgUmF5LkFMTDpcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQobm9ybWFsLCBzaGFwZSwgYm9keSwgZnJhY3Rpb24sIGZhY2VJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSYXkuQ0xPU0VTVDpcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGlmIGNsb3NlciB0aGFuIGN1cnJlbnQgY2xvc2VzdFxyXG4gICAgICAgICAgICAgICAgaWYgKGZyYWN0aW9uIDwgcmVzdWx0LmZyYWN0aW9uIHx8ICFyZXN1bHQuaGFzSGl0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KG5vcm1hbCwgc2hhcGUsIGJvZHksIGZyYWN0aW9uLCBmYWNlSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmF5LkFOWTpcclxuICAgICAgICAgICAgICAgIC8vIFJlcG9ydCBhbmQgc3RvcC5cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQobm9ybWFsLCBzaGFwZSwgYm9keSwgZnJhY3Rpb24sIGZhY2VJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHJheWNhc3RpbmcgbW9kZSB3aWxsIG1ha2UgdGhlIFJheSB0cmF2ZXJzZSB0aHJvdWdoIGFsbCBpbnRlcnNlY3Rpb24gcG9pbnRzIGFuZCBvbmx5IHJldHVybiB0aGUgY2xvc2VzdCBvbmUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQ0xPU0VTVFxyXG4gICAgICovXHJcbiAgICBSYXkuQ0xPU0VTVCA9IDE7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgcmF5Y2FzdGluZyBtb2RlIHdpbGwgbWFrZSB0aGUgUmF5IHN0b3Agd2hlbiBpdCBmaW5kcyB0aGUgZmlyc3QgaW50ZXJzZWN0aW9uIHBvaW50LlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IEFOWVxyXG4gICAgICovXHJcbiAgICBSYXkuQU5ZID0gMjtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyByYXljYXN0aW5nIG1vZGUgd2lsbCB0cmF2ZXJzZSBhbGwgaW50ZXJzZWN0aW9uIHBvaW50cyBhbmQgZXhlY3V0ZXMgYSBjYWxsYmFjayBmb3IgZWFjaCBvbmUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQUxMXHJcbiAgICAgKi9cclxuICAgIFJheS5BTEwgPSA0O1xyXG4gICAgcmV0dXJuIFJheTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUmF5O1xyXG5mdW5jdGlvbiBkaXN0YW5jZUZyb21JbnRlcnNlY3Rpb25TcXVhcmVkKGZyb20sIGRpcmVjdGlvbiwgcG9zaXRpb24pIHtcclxuICAgIC8vIHYwIGlzIHZlY3RvciBmcm9tIGZyb20gdG8gcG9zaXRpb25cclxuICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHYwLCBwb3NpdGlvbiwgZnJvbSk7XHJcbiAgICB2YXIgZG90ID0gdmVjMl8xLmRlZmF1bHQuZG90KHYwLCBkaXJlY3Rpb24pO1xyXG4gICAgLy8gaW50ZXJzZWN0ID0gZGlyZWN0aW9uICogZG90ICsgZnJvbVxyXG4gICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUoaW50ZXJzZWN0LCBkaXJlY3Rpb24sIGRvdCk7XHJcbiAgICB2ZWMyXzEuZGVmYXVsdC5hZGQoaW50ZXJzZWN0LCBpbnRlcnNlY3QsIGZyb20pO1xyXG4gICAgcmV0dXJuIHZlYzJfMS5kZWZhdWx0LnNxdWFyZWREaXN0YW5jZShwb3NpdGlvbiwgaW50ZXJzZWN0KTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgcmF5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmF5XCIpKTtcclxudmFyIFJheWNhc3RSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIFN0b3JhZ2UgZm9yIFJheSBjYXN0aW5nIGhpdCBkYXRhLlxyXG4gICAgICogQGNsYXNzIFJheWNhc3RSZXN1bHRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSYXljYXN0UmVzdWx0KCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBub3JtYWwgb2YgdGhlIGhpdCwgb3JpZW50ZWQgaW4gd29ybGQgc3BhY2UuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHthcnJheX0gbm9ybWFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ub3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGhpdCB0cmlhbmdsZSwgaWYgdGhlIGhpdCBzaGFwZSB3YXMgaW5kZXhhYmxlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmYWNlSW5kZXhcclxuICAgICAgICAgKiBAZGVmYXVsdCAtMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmFjZUluZGV4ID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzdGFuY2UgdG8gdGhlIGhpdCwgYXMgYSBmcmFjdGlvbi4gMCBpcyBhdCB0aGUgXCJmcm9tXCIgcG9pbnQsIDEgaXMgYXQgdGhlIFwidG9cIiBwb2ludC4gV2lsbCBiZSBzZXQgdG8gLTEgaWYgdGhlcmUgd2FzIG5vIGhpdCB5ZXQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGZyYWN0aW9uXHJcbiAgICAgICAgICogQGRlZmF1bHQgLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZyYWN0aW9uID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIHJheSBzaG91bGQgc3RvcCB0cmF2ZXJzaW5nLlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNTdG9wcGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgYWxsIHJlc3VsdCBkYXRhLiBNdXN0IGJlIGRvbmUgYmVmb3JlIHJlLXVzaW5nIHRoZSByZXN1bHQgb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCByZXNldFxyXG4gICAgICovXHJcbiAgICBSYXljYXN0UmVzdWx0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodGhpcy5ub3JtYWwsIDAsIDApO1xyXG4gICAgICAgIHRoaXMuc2hhcGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZmFjZUluZGV4ID0gLTE7XHJcbiAgICAgICAgdGhpcy5mcmFjdGlvbiA9IC0xO1xyXG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBoaXQgcG9pbnQuXHJcbiAgICAgKiBAbWV0aG9kIGdldEhpdERpc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge1JheX0gcmF5XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLmdldEhpdERpc3RhbmNlID0gZnVuY3Rpb24gKHJheSkge1xyXG4gICAgICAgIHJldHVybiB2ZWMyXzEuZGVmYXVsdC5kaXN0YW5jZShyYXkuZnJvbSwgcmF5LnRvKSAqIHRoaXMuZnJhY3Rpb247XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJheSBoaXQgc29tZXRoaW5nIHNpbmNlIHRoZSBsYXN0IHJlc2V0KCkuXHJcbiAgICAgKiBAbWV0aG9kIGhhc0hpdFxyXG4gICAgICogQMKuZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLmhhc0hpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mcmFjdGlvbiAhPT0gLTE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgd29ybGQgaGl0IHBvaW50LlxyXG4gICAgICogQG1ldGhvZCBnZXRIaXRQb2ludFxyXG4gICAgICogQHBhcmFtIHthcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0ge1JheX0gcmF5XHJcbiAgICAgKi9cclxuICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLmdldEhpdFBvaW50ID0gZnVuY3Rpb24gKG91dCwgcmF5KSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQubGVycChvdXQsIHJheS5mcm9tLCByYXkudG8sIHRoaXMuZnJhY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FuIGJlIGNhbGxlZCB3aGlsZSBpdGVyYXRpbmcgb3ZlciBoaXRzIHRvIHN0b3Agc2VhcmNoaW5nIGZvciBoaXQgcG9pbnRzLlxyXG4gICAgICogQG1ldGhvZCBzdG9wXHJcbiAgICAgKi9cclxuICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBzaG91bGRTdG9wXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtSYXl9IHJheVxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuc2hvdWxkU3RvcCA9IGZ1bmN0aW9uIChyYXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1N0b3BwZWQgfHwgKHRoaXMuZnJhY3Rpb24gIT09IC0xICYmIHJheS5tb2RlID09PSByYXlfMS5kZWZhdWx0LkFOWSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHNldFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IG5vcm1hbFxyXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyYWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmFjZUluZGV4XHJcbiAgICAgKi9cclxuICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChub3JtYWwsIHNoYXBlLCBib2R5LCBmcmFjdGlvbiwgZmFjZUluZGV4KSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh0aGlzLm5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICB0aGlzLnNoYXBlID0gc2hhcGU7XHJcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuICAgICAgICB0aGlzLmZyYWN0aW9uID0gZnJhY3Rpb247XHJcbiAgICAgICAgdGhpcy5mYWNlSW5kZXggPSBmYWNlSW5kZXg7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJheWNhc3RSZXN1bHQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJheWNhc3RSZXN1bHQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBicm9hZHBoYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYnJvYWRwaGFzZVwiKSk7XHJcbnZhciB1dGlsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy91dGlsc1wiKSk7XHJcbi8vIFRPRE86IHRoaXMgYXBwZWFycyB0byBiZSBhIGJ1YmJsZSBzb3J0LiBXZSBjb3VsZCBwcm9iYWJseSBkbyBiZXR0ZXIuXHJcbmZ1bmN0aW9uIHNvcnRBeGlzTGlzdChhLCBheGlzSW5kZXgpIHtcclxuICAgIGZvciAodmFyIGkgPSAxLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgLy8gV2h5IG5vdCBpPTA/XHJcbiAgICAgICAgdmFyIHYgPSBhW2ldO1xyXG4gICAgICAgIGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgaWYgKGFbal0uYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0gPD0gdi5hYWJiLmxvd2VyQm91bmRbYXhpc0luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYVtqICsgMV0gPSBhW2pdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhW2ogKyAxXSA9IHY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufVxyXG52YXIgU0FQQnJvYWRwaGFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTQVBCcm9hZHBoYXNlLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTd2VlcCBhbmQgcHJ1bmUgYnJvYWRwaGFzZSBhbG9uZyBvbmUgYXhpcy5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgU0FQQnJvYWRwaGFzZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNBUEJyb2FkcGhhc2UoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYnJvYWRwaGFzZV8xLmRlZmF1bHQuU0FQKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmF4aXNMaXN0ID0gW107XHJcbiAgICAgICAgX3RoaXMuYXhpc0luZGV4ID0gMDtcclxuICAgICAgICBfdGhpcy5fYWRkQm9keUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5heGlzTGlzdC5wdXNoKGUuYm9keSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBsaXN0XHJcbiAgICAgICAgICAgIHZhciBpZHggPSBfdGhpcy5heGlzTGlzdC5pbmRleE9mKGUuYm9keSk7XHJcbiAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5heGlzTGlzdC5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgdGhlIHdvcmxkXHJcbiAgICAgKiBAbWV0aG9kIHNldFdvcmxkXHJcbiAgICAgKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxyXG4gICAgICovXHJcbiAgICBTQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uICh3b3JsZCkge1xyXG4gICAgICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxyXG4gICAgICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyBBZGQgYWxsIGJvZGllcyBmcm9tIHRoZSBuZXcgd29ybGRcclxuICAgICAgICB1dGlsc18xLmRlZmF1bHQuYXBwZW5kQXJyYXkodGhpcy5heGlzTGlzdCwgd29ybGQuYm9kaWVzKTtcclxuICAgICAgICAvLyBSZW1vdmUgb2xkIGhhbmRsZXJzLCBpZiBhbnlcclxuICAgICAgICB3b3JsZFxyXG4gICAgICAgICAgICAub2ZmKFwiYWRkQm9keVwiLCB0aGlzLl9hZGRCb2R5SGFuZGxlcilcclxuICAgICAgICAgICAgLm9mZihcInJlbW92ZUJvZHlcIiwgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpO1xyXG4gICAgICAgIC8vIEFkZCBoYW5kbGVycyB0byB1cGRhdGUgdGhlIGxpc3Qgb2YgYm9kaWVzLlxyXG4gICAgICAgIC8vIFRPRE86IG5vdyB0aGF0IEkndmUgYWRkZWQgY29udGV4dCwgd2UgY2FuIHRlc3QgbW92aW5nIHRob3NlIGlubGluZSBmdW5jdGlvbnMgdG8gcHJvcGVyIHByaXZhdGUgbWV0aG9kcy5cclxuICAgICAgICB3b3JsZC5vbihcImFkZEJvZHlcIiwgdGhpcy5fYWRkQm9keUhhbmRsZXIsIHRoaXMpXHJcbiAgICAgICAgICAgIC5vbihcInJlbW92ZUJvZHlcIiwgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMud29ybGQgPSB3b3JsZDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBTQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zb3J0TGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCwgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7XHJcbiAgICAgICAgLy8gU29ydCB0aGUgbGlzdHNcclxuICAgICAgICBzb3J0QXhpc0xpc3QoYm9kaWVzLCBheGlzSW5kZXgpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjb2xsaWRpbmcgcGFpcnNcclxuICAgICAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcclxuICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIFNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24gKCAvKndvcmxkKi8pIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCwgcmVzdWx0ID0gdGhpcy5yZXN1bHQsIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xyXG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSAwO1xyXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgQUFCQnMgaWYgbmVlZGVkXHJcbiAgICAgICAgdmFyIGwgPSBib2RpZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbbF07XHJcbiAgICAgICAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgYi51cGRhdGVBQUJCKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU29ydCB0aGUgbGlzdHNcclxuICAgICAgICB0aGlzLnNvcnRMaXN0KCk7XHJcbiAgICAgICAgLy8gTG9vayB0aHJvdWdoIHRoZSBYIGxpc3RcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgTiA9IGJvZGllcy5sZW5ndGggfCAwOyBpICE9PSBOOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBOOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaiA9IGJvZGllc1tqXTtcclxuICAgICAgICAgICAgICAgIC8vIEJvdW5kcyBvdmVybGFwP1xyXG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBzID0gKGJqLmFhYmIubG93ZXJCb3VuZFtheGlzSW5kZXhdIDw9IGJpLmFhYmIudXBwZXJCb3VuZFtheGlzSW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIGlmICghb3ZlcmxhcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChicm9hZHBoYXNlXzEuZGVmYXVsdC5jYW5Db2xsaWRlKGJpLCBiaikgJiYgdGhpcy5ib3VuZGluZ1ZvbHVtZUNoZWNrKGJpLCBiaikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxyXG4gICAgICogQG1ldGhvZCBhYWJiUXVlcnlcclxuICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gICAgICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXHJcbiAgICAgKiBAcmV0dXJuIHthcnJheX1cclxuICAgICAqIEB0b2RvIHNpbmNlIHRoZSBsaXN0IGlzIHNvcnRlZCwgb3B0aW1pemF0aW9uIGNhbiBiZSBkb25lXHJcbiAgICAgKi9cclxuICAgIFNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uICh3b3JsZCwgYWFiYiwgcmVzdWx0KSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xyXG4gICAgICAgIHRoaXMuc29ydExpc3QoKTtcclxuICAgICAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpc0xpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBheGlzTGlzdFtpXTtcclxuICAgICAgICAgICAgaWYgKGIuYWFiYk5lZWRzVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBiLnVwZGF0ZUFBQkIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBTQVBCcm9hZHBoYXNlO1xyXG59KGJyb2FkcGhhc2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNBUEJyb2FkcGhhc2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBDb25zdHJhaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIGNvbnN0cmFpbnQgY2xhc3MuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIENvbnN0cmFpbnRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkPXRydWVdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB0eXBlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuZXF1YXRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuICAgICAgICB0aGlzLmNvbGxpZGVDb25uZWN0ZWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcclxuICAgICAgICAvLyBXYWtlIHVwIGJvZGllcyB3aGVuIGNvbm5lY3RlZFxyXG4gICAgICAgIGlmICgoKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndha2VVcEJvZGllcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UpICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAoYm9keUEpIHtcclxuICAgICAgICAgICAgICAgIGJvZHlBLndha2VVcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib2R5Qikge1xyXG4gICAgICAgICAgICAgICAgYm9keUIud2FrZVVwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIGNvbnN0cmFpbnQgcGFyYW1ldGVycyBiZWZvcmUgc29sdmUuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIHVwZGF0ZSgpIG5vdCBpbXBsbWVtZW50ZWQgaW4gdGhpcyBDb25zdHJhaW50IHN1YmNsYXNzIVwiKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBzdGlmZm5lc3MgZm9yIHRoaXMgY29uc3RyYWludC5cclxuICAgICAqIEBtZXRob2Qgc2V0U3RpZmZuZXNzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RpZmZuZXNzXHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQucHJvdG90eXBlLnNldFN0aWZmbmVzcyA9IGZ1bmN0aW9uIChzdGlmZm5lc3MpIHtcclxuICAgICAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGVxcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZXEgPSBlcXNbaV07XHJcbiAgICAgICAgICAgIGVxLnN0aWZmbmVzcyA9IHN0aWZmbmVzcztcclxuICAgICAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCByZWxheGF0aW9uIGZvciB0aGlzIGNvbnN0cmFpbnQuXHJcbiAgICAgKiBAbWV0aG9kIHNldFJlbGF4YXRpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWxheGF0aW9uXHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQucHJvdG90eXBlLnNldFJlbGF4YXRpb24gPSBmdW5jdGlvbiAocmVsYXhhdGlvbikge1xyXG4gICAgICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gZXFzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlcSA9IGVxc1tpXTtcclxuICAgICAgICAgICAgZXEucmVsYXhhdGlvbiA9IHJlbGF4YXRpb247XHJcbiAgICAgICAgICAgIGVxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHNldE1heEJpYXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhCaWFzXHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heEJpYXMgPSBmdW5jdGlvbiAobWF4Qmlhcykge1xyXG4gICAgICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gZXFzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlcSA9IGVxc1tpXTtcclxuICAgICAgICAgICAgZXEubWF4QmlhcyA9IG1heEJpYXM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERJU1RBTkNFXHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQuRElTVEFOQ0UgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gR0VBUlxyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LkdFQVIgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gTE9DS1xyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LkxPQ0sgPSAzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gUFJJU01BVElDXHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQuUFJJU01BVElDID0gNDtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFJFVk9MVVRFXHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQuUkVWT0xVVEUgPSA1O1xyXG4gICAgcmV0dXJuIENvbnN0cmFpbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvbnN0cmFpbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBjb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uc3RyYWludFwiKSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIikpO1xyXG52YXIgbiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgcmkgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JBXHJcbnZhciByaiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckJcclxudmFyIERpc3RhbmNlQ29uc3RyYWludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEaXN0YW5jZUNvbnN0cmFpbnQsIF9zdXBlcik7XHJcbiAgICAvLyB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAvLyB0aGlzLnVwcGVyTGltaXQgPSAxO1xyXG4gICAgLy8gdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgLy8gdGhpcy5sb3dlckxpbWl0ID0gMDtcclxuICAgIC8vIHRoaXMucG9zaXRpb24gPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJhaW50IHRoYXQgdHJpZXMgdG8ga2VlcCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gYm9kaWVzIGNvbnN0YW50LlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRpc3RhbmNlXSBUaGUgZGlzdGFuY2UgdG8ga2VlcCBiZXR3ZWVuIHRoZSBhbmNob3IgcG9pbnRzLiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib2RpZXMuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEFuY2hvckFdIFRoZSBhbmNob3IgcG9pbnQgZm9yIGJvZHlBLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEgZnJhbWUuIERlZmF1bHRzIHRvIFswLDBdLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubG9jYWxBbmNob3JCXSBUaGUgYW5jaG9yIHBvaW50IGZvciBib2R5QiwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCIGZyYW1lLiBEZWZhdWx0cyB0byBbMCwwXS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tYXhGb3JjZT1OdW1iZXIuTUFYX1ZBTFVFXSBNYXhpbXVtIGZvcmNlIHRvIGFwcGx5LlxyXG4gICAgICogQGV4dGVuZHMgQ29uc3RyYWludFxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgLy8gSWYgZGlzdGFuY2UgaXMgbm90IGdpdmVuIGFzIGFuIG9wdGlvbiwgdGhlbiB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib2RpZXMgaXMgdXNlZC5cclxuICAgICAqICAgICAvLyBJbiB0aGlzIGV4YW1wbGUsIHRoZSBib2RpZXMgd2lsbCBiZSBjb25zdHJhaW5lZCB0byBoYXZlIGEgZGlzdGFuY2Ugb2YgMiBiZXR3ZWVuIHRoZWlyIGNlbnRlcnMuXHJcbiAgICAgKiAgICAgdmFyIGJvZHlBID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWy0xLCAwXSB9KTtcclxuICAgICAqICAgICB2YXIgYm9keUIgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbMSwgMF0gfSk7XHJcbiAgICAgKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgZGlzdGFuY2UgYW5kIGFuY2hvcnNcclxuICAgICAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XHJcbiAgICAgKiAgICAgICAgIGRpc3RhbmNlOiAxLCAgICAgICAgICAvLyBEaXN0YW5jZSB0byBrZWVwIGJldHdlZW4gdGhlIHBvaW50c1xyXG4gICAgICogICAgICAgICBsb2NhbEFuY2hvckE6IFsxLCAwXSwgLy8gUG9pbnQgb24gYm9keUFcclxuICAgICAqICAgICAgICAgbG9jYWxBbmNob3JCOiBbLTEsIDBdIC8vIFBvaW50IG9uIGJvZHlCXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIGNvbnN0cmFpbnRfMS5kZWZhdWx0LkRJU1RBTkNFLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkaXN0YW5jZSB0byBrZWVwLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkaXN0YW5jZVxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZGlzdGFuY2UgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heCBmb3JjZSB0byBhcHBseS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4Rm9yY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5tYXhGb3JjZSA9IEluZmluaXR5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSB1cHBlciBsaW1pdCBpcyBlbmFibGVkIG9yIG5vdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVwcGVyTGltaXRFbmFibGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdXBwZXIgY29uc3RyYWludCBsaW1pdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdXBwZXJMaW1pdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnVwcGVyTGltaXQgPSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBsb3dlciBsaW1pdCBpcyBlbmFibGVkIG9yIG5vdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGxvd2VyTGltaXRFbmFibGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbG93ZXIgY29uc3RyYWludCBsaW1pdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbG93ZXJMaW1pdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxvd2VyTGltaXQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgY29uc3RyYWludCBwb3NpdGlvbi4gVGhpcyBpcyBlcXVhbCB0byB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB3b3JsZCBhbmNob3IgcG9pbnRzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwb3NpdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnBvc2l0aW9uID0gMDtcclxuICAgICAgICBfdGhpcy5sb2NhbEFuY2hvckEgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQW5jaG9yQSkgPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLmxvY2FsQW5jaG9yQSkgOiB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBfdGhpcy5sb2NhbEFuY2hvckIgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQW5jaG9yQikgPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLmxvY2FsQW5jaG9yQikgOiB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgbG9jYWxBbmNob3JBID0gX3RoaXMubG9jYWxBbmNob3JBO1xyXG4gICAgICAgIHZhciBsb2NhbEFuY2hvckIgPSBfdGhpcy5sb2NhbEFuY2hvckI7XHJcbiAgICAgICAgX3RoaXMuZGlzdGFuY2UgPSAwO1xyXG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRpc3RhbmNlKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgY3VycmVudCB3b3JsZCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB3b3JsZCBhbmNob3IgcG9pbnRzLlxyXG4gICAgICAgICAgICB2YXIgd29ybGRBbmNob3JBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHdvcmxkQW5jaG9yQiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCByID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBsb2NhbCBhbmNob3JzIHRvIHdvcmxkXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh3b3JsZEFuY2hvckEsIGxvY2FsQW5jaG9yQSwgYm9keUEuYW5nbGUpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUod29ybGRBbmNob3JCLCBsb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKHIsIGJvZHlCLnBvc2l0aW9uLCB3b3JsZEFuY2hvckIpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyLCByLCB3b3JsZEFuY2hvckEpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyLCByLCBib2R5QS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIF90aGlzLmRpc3RhbmNlID0gdmVjMl8xLmRlZmF1bHQubGVuZ3RoKHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF4Rm9yY2UgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4Rm9yY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEluZmluaXR5O1xyXG4gICAgICAgIHZhciBub3JtYWwgPSBuZXcgRXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSk7IC8vIEp1c3QgaW4gdGhlIG5vcm1hbCBkaXJlY3Rpb25cclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMgPSBbbm9ybWFsXTtcclxuICAgICAgICBfdGhpcy5tYXhGb3JjZSA9IG1heEZvcmNlO1xyXG4gICAgICAgIC8vIGcgPSAoeGkgLSB4aikuZG90KG4pXHJcbiAgICAgICAgLy8gZGcvZHQgPSAodmkgLSB2aikuZG90KG4pID0gRypXID0gW24gMCAtbiAwXSAqIFt2aSB3aSB2aiB3al0nXHJcbiAgICAgICAgLy8gLi4uYW5kIGlmIHdlIHdlcmUgdG8gaW5jbHVkZSBvZmZzZXQgcG9pbnRzOlxyXG4gICAgICAgIC8vIGcgPVxyXG4gICAgICAgIC8vICAgICAgKHhqICsgcmogLSB4aSAtIHJpKS5kb3QobikgLSBkaXN0YW5jZVxyXG4gICAgICAgIC8vIGRnL2R0ID1cclxuICAgICAgICAvLyAgICAgICh2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmkpLmRvdChuKSA9XHJcbiAgICAgICAgLy8gICAgICB7IHRlcm0gMiBpcyBuZWFyIHplcm8gfSA9XHJcbiAgICAgICAgLy8gICAgICBbLW4gICAtcmkgeCBuICAgbiAgIHJqIHggbl0gKiBbdmkgd2kgdmogd2pdJyA9XHJcbiAgICAgICAgLy8gICAgICBHICogV1xyXG4gICAgICAgIC8vID0+IEcgPSBbLW4gLXJpeG4gbiByanhuXVxyXG4gICAgICAgIHZhciByID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIHJpID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7IC8vIHdvcmxkQW5jaG9yQVxyXG4gICAgICAgIHZhciByaiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckJcclxuICAgICAgICB2YXIgdGhhdCA9IF90aGlzO1xyXG4gICAgICAgIG5vcm1hbC5jb21wdXRlR3EgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUEsIGJvZHlCID0gdGhpcy5ib2R5QiwgeGkgPSBib2R5QS5wb3NpdGlvbiwgeGogPSBib2R5Qi5wb3NpdGlvbjtcclxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHJpLCBsb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHJqLCBsb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKHIsIHhqLCByaik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHIsIHIsIHJpKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QociwgciwgeGkpO1xyXG4gICAgICAgICAgICAvL3ZlYzIuc3VidHJhY3QociwgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZlYzJfMS5kZWZhdWx0Lmxlbmd0aChyKSAtIHRoYXQuZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBNYWtlIHRoZSBjb250YWN0IGNvbnN0cmFpbnQgYmlsYXRlcmFsXHJcbiAgICAgICAgX3RoaXMuc2V0TWF4Rm9yY2UobWF4Rm9yY2UpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBjb25zdHJhaW50IGVxdWF0aW9ucy4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBib2RpZXMgY2hhbmdlZCBwb3NpdGlvbiwgYmVmb3JlIHNvbHZpbmcuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBEaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9ybWFsID0gdGhpcy5lcXVhdGlvbnNbMF0sIGJvZHlBID0gdGhpcy5ib2R5QSwgYm9keUIgPSB0aGlzLmJvZHlCLCB4aSA9IGJvZHlBLnBvc2l0aW9uLCB4aiA9IGJvZHlCLnBvc2l0aW9uLCBub3JtYWxFcXVhdGlvbiA9IHRoaXMuZXF1YXRpb25zWzBdLCBHID0gbm9ybWFsLkc7XHJcbiAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUocmksIHRoaXMubG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHJqLCB0aGlzLmxvY2FsQW5jaG9yQiwgYm9keUIuYW5nbGUpO1xyXG4gICAgICAgIC8vIEdldCB3b3JsZCBhbmNob3IgcG9pbnRzIGFuZCBub3JtYWxcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQobiwgeGosIHJqKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChuLCBuLCByaSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QobiwgbiwgeGkpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB2ZWMyXzEuZGVmYXVsdC5sZW5ndGgobik7XHJcbiAgICAgICAgdmFyIHZpb2xhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLnVwcGVyTGltaXRFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID4gdGhpcy51cHBlckxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxFcXVhdGlvbi5tYXhGb3JjZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxFcXVhdGlvbi5taW5Gb3JjZSA9IC10aGlzLm1heEZvcmNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHRoaXMudXBwZXJMaW1pdDtcclxuICAgICAgICAgICAgICAgIHZpb2xhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPCB0aGlzLmxvd2VyTGltaXQpIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1heEZvcmNlID0gdGhpcy5tYXhGb3JjZTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1pbkZvcmNlID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLmxvd2VyTGltaXQ7XHJcbiAgICAgICAgICAgICAgICB2aW9sYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodGhpcy5sb3dlckxpbWl0RW5hYmxlZCB8fCB0aGlzLnVwcGVyTGltaXRFbmFibGVkKSAmJiAhdmlvbGF0aW5nKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGNvbnN0cmFpbnQgbmVlZGVkLlxyXG4gICAgICAgICAgICBub3JtYWxFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9ybWFsRXF1YXRpb24uZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKG4sIG4pO1xyXG4gICAgICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xyXG4gICAgICAgIHZhciByaXhuID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmksIG4pLCByanhuID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmosIG4pO1xyXG4gICAgICAgIC8vIEcgPSBbLW4gLXJpeG4gbiByanhuXVxyXG4gICAgICAgIEdbMF0gPSAtblswXTtcclxuICAgICAgICBHWzFdID0gLW5bMV07XHJcbiAgICAgICAgR1syXSA9IC1yaXhuO1xyXG4gICAgICAgIEdbM10gPSBuWzBdO1xyXG4gICAgICAgIEdbNF0gPSBuWzFdO1xyXG4gICAgICAgIEdbNV0gPSByanhuO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtYXggZm9yY2UgdG8gYmUgdXNlZFxyXG4gICAgICogQG1ldGhvZCBzZXRNYXhGb3JjZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heEZvcmNlXHJcbiAgICAgKi9cclxuICAgIERpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbiAobWF4Rm9yY2UpIHtcclxuICAgICAgICB2YXIgbm9ybWFsID0gdGhpcy5lcXVhdGlvbnNbMF07XHJcbiAgICAgICAgbm9ybWFsLm1pbkZvcmNlID0gLW1heEZvcmNlO1xyXG4gICAgICAgIG5vcm1hbC5tYXhGb3JjZSA9IG1heEZvcmNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtYXggZm9yY2VcclxuICAgICAqIEBtZXRob2QgZ2V0TWF4Rm9yY2VcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9ybWFsID0gdGhpcy5lcXVhdGlvbnNbMF07XHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbC5tYXhGb3JjZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGlzdGFuY2VDb25zdHJhaW50O1xyXG59KGNvbnN0cmFpbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERpc3RhbmNlQ29uc3RyYWludDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGFuZ2xlX2xvY2tfZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL2FuZ2xlLWxvY2stZXF1YXRpb25cIikpO1xyXG52YXIgY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRcIikpO1xyXG52YXIgR2VhckNvbnN0cmFpbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoR2VhckNvbnN0cmFpbnQsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cmFpbnMgdGhlIGFuZ2xlIG9mIHR3byBib2RpZXMgdG8gZWFjaCBvdGhlciB0byBiZSBlcXVhbC4gSWYgYSBnZWFyIHJhdGlvIGlzIG5vdCBvbmUsIHRoZSBhbmdsZSBvZiBib2R5QSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgdGhlIGFuZ2xlIG9mIGJvZHlCLlxyXG4gICAgICogQGNsYXNzIEdlYXJDb25zdHJhaW50XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBhdXRob3Igc2NodGVwcGVcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gICAgICAgICAgICBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSAgICAgICAgICAgIGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgW29wdGlvbnMuYW5nbGU9MF0gUmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzLiBXaWxsIGJlIHNldCB0byB0aGUgY3VycmVudCBhbmdsZSBiZXR3ZWVuIHRoZSBib2RpZXMgKHRoZSBnZWFyIHJhdGlvIGlzIGFjY291bnRlZCBmb3IpLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLnJhdGlvPTFdIEdlYXIgcmF0aW8uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgW29wdGlvbnMubWF4VG9ycXVlXSBNYXhpbXVtIHRvcnF1ZSB0byBhcHBseS5cclxuICAgICAqIEBleHRlbmRzIENvbnN0cmFpbnRcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IEdlYXJDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IEdlYXJDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xyXG4gICAgICogICAgICAgICByYXRpbzogMixcclxuICAgICAqICAgICAgICAgbWF4VG9ycXVlOiAxMDAwXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gR2VhckNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIGNvbnN0cmFpbnRfMS5kZWZhdWx0LkdFQVIsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGdlYXIgcmF0aW8uXHJcbiAgICAgICAgICogQHByb3BlcnR5IHJhdGlvXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5yYXRpbyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yYXRpbykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVsYXRpdmUgYW5nbGVcclxuICAgICAgICAgKiBAcHJvcGVydHkgYW5nbGVcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmdsZSA6IGJvZHlCLmFuZ2xlIC0gX3RoaXMucmF0aW8gKiBib2R5QS5hbmdsZTtcclxuICAgICAgICAvLyBTZW5kIHNhbWUgcGFyYW1ldGVycyB0byB0aGUgZXF1YXRpb25cclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMgPSBbXHJcbiAgICAgICAgICAgIG5ldyBhbmdsZV9sb2NrX2VxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIsIHtcclxuICAgICAgICAgICAgICAgIHJhdGlvOiBfdGhpcy5yYXRpbyxcclxuICAgICAgICAgICAgICAgIGFuZ2xlOiBfdGhpcy5hbmdsZVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgICAgIC8vIFNldCBtYXggdG9ycXVlXHJcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4VG9ycXVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgX3RoaXMuc2V0TWF4VG9ycXVlKG9wdGlvbnMubWF4VG9ycXVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZXEgPSB0aGlzLmVxdWF0aW9uc1swXTtcclxuICAgICAgICB2YXIgcmF0aW8gPSB0aGlzLnJhdGlvO1xyXG4gICAgICAgIGlmIChlcS5yYXRpbyAhPT0gcmF0aW8pIHtcclxuICAgICAgICAgICAgZXEuc2V0UmF0aW8ocmF0aW8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlcS5hbmdsZSA9IHRoaXMuYW5nbGU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG1heCB0b3JxdWUgZm9yIHRoZSBjb25zdHJhaW50LlxyXG4gICAgICogQG1ldGhvZCBzZXRNYXhUb3JxdWVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3JxdWVcclxuICAgICAqL1xyXG4gICAgR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUpIHtcclxuICAgICAgICB0aGlzLmVxdWF0aW9uc1swXS5zZXRNYXhUb3JxdWUodG9ycXVlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbWF4IHRvcnF1ZSBmb3IgdGhlIGNvbnN0cmFpbnQuXHJcbiAgICAgKiBAbWV0aG9kIGdldE1heFRvcnF1ZVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBHZWFyQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TWF4VG9ycXVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVxdWF0aW9uc1swXS5tYXhGb3JjZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gR2VhckNvbnN0cmFpbnQ7XHJcbn0oY29uc3RyYWludF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gR2VhckNvbnN0cmFpbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBjb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uc3RyYWludFwiKSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIikpO1xyXG52YXIgbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgciA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgdCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgeEF4aXMgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDEsIDApO1xyXG52YXIgeUF4aXMgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDAsIDEpO1xyXG52YXIgTG9ja0NvbnN0cmFpbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTG9ja0NvbnN0cmFpbnQsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIExvY2tzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gYmV0d2VlbiB0d28gYm9kaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBMb2NrQ29uc3RyYWludFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxPZmZzZXRCXSBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuIElmIG5vdCBnaXZlbiB0aGUgb2Zmc2V0IGlzIGNvbXB1dGVkIGZyb20gY3VycmVudCBwb3NpdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9jYWxBbmdsZUJdIFRoZSBhbmdsZSBvZiBib2R5QiBpbiBib2R5QSdzIGZyYW1lLiBJZiBub3QgZ2l2ZW4sIHRoZSBhbmdsZSBpcyBjb21wdXRlZCBmcm9tIGN1cnJlbnQgYW5nbGVzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlXVxyXG4gICAgICogQGV4dGVuZHMgQ29uc3RyYWludFxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgLy8gTG9ja3MgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGFuZCByb3RhdGlvbiBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5QlxyXG4gICAgICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IExvY2tDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgY29uc3RyYWludF8xLmRlZmF1bHQuTE9DSywgb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICB2YXIgbWF4Rm9yY2UgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4Rm9yY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEluZmluaXR5O1xyXG4gICAgICAgIC8vIFVzZSAzIGVxdWF0aW9uczpcclxuICAgICAgICAvLyBneCA9ICAgKHhqIC0geGkgLSBsKSAqIHhoYXQgPSAwXHJcbiAgICAgICAgLy8gZ3kgPSAgICh4aiAtIHhpIC0gbCkgKiB5aGF0ID0gMFxyXG4gICAgICAgIC8vIGdyID0gICAoeGkgLSB4aiArIHIpICogdGhhdCA9IDBcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIC4uLndoZXJlOlxyXG4gICAgICAgIC8vICAgbCBpcyB0aGUgbG9jYWxPZmZzZXRCIHZlY3RvciByb3RhdGVkIHRvIHdvcmxkIGluIGJvZHlBIGZyYW1lXHJcbiAgICAgICAgLy8gICByIGlzIHRoZSBzYW1lIHZlY3RvciBidXQgcmV2ZXJzZWQgYW5kIHJvdGF0ZWQgZnJvbSBib2R5QiBmcmFtZVxyXG4gICAgICAgIC8vICAgeGhhdCwgeWhhdCBhcmUgd29ybGQgYXhpcyB2ZWN0b3JzXHJcbiAgICAgICAgLy8gICB0aGF0IGlzIHRoZSB0YW5nZW50IG9mIHJcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIEZvciB0aGUgZmlyc3QgdHdvIGNvbnN0cmFpbnRzLCB3ZSBnZXRcclxuICAgICAgICAvLyBHKlcgPSAodmogLSB2aSAtIGxkb3QgICkgKiB4aGF0XHJcbiAgICAgICAgLy8gICAgID0gKHZqIC0gdmkgLSB3aSB4IGwpICogeGhhdFxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gU2luY2UgKHdpIHggbCkgKiB4aGF0ID0gKGwgeCB4aGF0KSAqIHdpLCB3ZSBnZXRcclxuICAgICAgICAvLyBHKlcgPSBbIC0xICAgMCAgICgtbCB4IHhoYXQpICAxICAgMCAgIDBdICogW3ZpIHdpIHZqIHdqXVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhlIGxhc3QgY29uc3RyYWludCBnaXZlc1xyXG4gICAgICAgIC8vIEdXID0gKHZpIC0gdmogKyB3aiB4IHIpICogdGhhdFxyXG4gICAgICAgIC8vICAgID0gWyAgdGhhdCAgIDAgIC10aGF0ICAociB4IHQpIF1cclxuICAgICAgICB2YXIgeCA9IG5ldyBFcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKSwgeSA9IG5ldyBFcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKSwgcm90ID0gbmV3IEVxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIsIC1tYXhGb3JjZSwgbWF4Rm9yY2UpO1xyXG4gICAgICAgIHZhciBsID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGcgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgdGhhdCA9IF90aGlzO1xyXG4gICAgICAgIHguY29tcHV0ZUdxID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUobCwgdGhhdC5sb2NhbE9mZnNldEIsIGJvZHlBLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoZywgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoZywgZywgbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBnWzBdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgeS5jb21wdXRlR3EgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShsLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUEuYW5nbGUpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChnLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChnLCBnLCBsKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdbMV07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgciA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB0ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgcm90LmNvbXB1dGVHcSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHIsIHRoYXQubG9jYWxPZmZzZXRCLCBib2R5Qi5hbmdsZSAtIHRoYXQubG9jYWxBbmdsZUIpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShyLCByLCAtMSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KGcsIGJvZHlBLnBvc2l0aW9uLCBib2R5Qi5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChnLCBnLCByKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHQsIHIsIC1NYXRoLlBJIC8gMik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZSh0LCB0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHZlYzJfMS5kZWZhdWx0LmRvdChnLCB0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvZmZzZXQgb2YgYm9keUIgaW4gYm9keUEncyBmcmFtZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBsb2NhbE9mZnNldEJcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5sb2NhbE9mZnNldEIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsT2Zmc2V0Qikge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KF90aGlzLmxvY2FsT2Zmc2V0Qiwgb3B0aW9ucy5sb2NhbE9mZnNldEIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ29uc3RydWN0IGZyb20gY3VycmVudCBwb3NpdGlvbnNcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoX3RoaXMubG9jYWxPZmZzZXRCLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUoX3RoaXMubG9jYWxPZmZzZXRCLCBfdGhpcy5sb2NhbE9mZnNldEIsIC1ib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvZmZzZXQgYW5nbGUgb2YgYm9keUIgaW4gYm9keUEncyBmcmFtZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbG9jYWxBbmdsZUJcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5sb2NhbEFuZ2xlQiA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbEFuZ2xlQikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogYm9keUIuYW5nbGUgLSBib2R5QS5hbmdsZTtcclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMucHVzaCh4KTtcclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMucHVzaCh5KTtcclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMucHVzaChyb3QpO1xyXG4gICAgICAgIF90aGlzLnNldE1heEZvcmNlKG1heEZvcmNlKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbWF4aW11bSBmb3JjZSB0byBiZSBhcHBsaWVkLlxyXG4gICAgICogQG1ldGhvZCBzZXRNYXhGb3JjZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZvcmNlXHJcbiAgICAgKi9cclxuICAgIExvY2tDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNYXhGb3JjZSA9IGZ1bmN0aW9uIChmb3JjZSkge1xyXG4gICAgICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXF1YXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGVxc1tpXS5tYXhGb3JjZSA9IGZvcmNlO1xyXG4gICAgICAgICAgICBlcXNbaV0ubWluRm9yY2UgPSAtZm9yY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtYXggZm9yY2UuXHJcbiAgICAgKiBAbWV0aG9kIGdldE1heEZvcmNlXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIExvY2tDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lcXVhdGlvbnNbMF0ubWF4Rm9yY2U7XHJcbiAgICB9O1xyXG4gICAgTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMuZXF1YXRpb25zWzBdLCB5ID0gdGhpcy5lcXVhdGlvbnNbMV0sIHJvdCA9IHRoaXMuZXF1YXRpb25zWzJdLCBib2R5QSA9IHRoaXMuYm9keUEsIGJvZHlCID0gdGhpcy5ib2R5QjtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUobCwgdGhpcy5sb2NhbE9mZnNldEIsIGJvZHlBLmFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUociwgdGhpcy5sb2NhbE9mZnNldEIsIGJvZHlCLmFuZ2xlIC0gdGhpcy5sb2NhbEFuZ2xlQik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUociwgciwgLTEpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh0LCByLCBNYXRoLlBJIC8gMik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKHQsIHQpO1xyXG4gICAgICAgIHguR1swXSA9IC0xO1xyXG4gICAgICAgIHguR1sxXSA9IDA7XHJcbiAgICAgICAgeC5HWzJdID0gLXZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKGwsIHhBeGlzKTtcclxuICAgICAgICB4LkdbM10gPSAxO1xyXG4gICAgICAgIHkuR1swXSA9IDA7XHJcbiAgICAgICAgeS5HWzFdID0gLTE7XHJcbiAgICAgICAgeS5HWzJdID0gLXZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKGwsIHlBeGlzKTtcclxuICAgICAgICB5LkdbNF0gPSAxO1xyXG4gICAgICAgIHJvdC5HWzBdID0gLXRbMF07XHJcbiAgICAgICAgcm90LkdbMV0gPSAtdFsxXTtcclxuICAgICAgICByb3QuR1szXSA9IHRbMF07XHJcbiAgICAgICAgcm90LkdbNF0gPSB0WzFdO1xyXG4gICAgICAgIHJvdC5HWzVdID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgociwgdCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExvY2tDb25zdHJhaW50O1xyXG59KGNvbnN0cmFpbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IExvY2tDb25zdHJhaW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRcIikpO1xyXG52YXIgY29udGFjdF9lcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvY29udGFjdC1lcXVhdGlvblwiKSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIikpO1xyXG52YXIgcm90YXRpb25hbF9sb2NrX2VxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2VxdWF0aW9ucy9yb3RhdGlvbmFsLWxvY2stZXF1YXRpb25cIikpO1xyXG52YXIgd29ybGRBeGlzQSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB3b3JsZEFuY2hvckEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgd29ybGRBbmNob3JCID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIG9yaWVudGVkQW5jaG9yQSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBvcmllbnRlZEFuY2hvckIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgdG1wID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBQcmlzbWF0aWNDb25zdHJhaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByaXNtYXRpY0NvbnN0cmFpbnQsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cmFpbnQgdGhhdCBvbmx5IGFsbG93cyBib2RpZXMgdG8gbW92ZSBhbG9uZyBhIGxpbmUsIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIuIFNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy5pZm9yY2UyZC5uZXQvYjJkdHV0L2pvaW50cy1wcmlzbWF0aWNcIj50aGlzIHR1dG9yaWFsPC9hPi4gQWxzbyBjYWxsZWQgXCJzbGlkZXIgY29uc3RyYWludFwiLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBQcmlzbWF0aWNDb25zdHJhaW50XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIENvbnN0cmFpbnRcclxuICAgICAqIEBhdXRob3Igc2NodGVwcGVcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZV0gTWF4IGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gQm9keSBBJ3MgYW5jaG9yIHBvaW50LCBkZWZpbmVkIGluIGl0cyBvd24gbG9jYWwgZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEFuY2hvckJdIEJvZHkgQidzIGFuY2hvciBwb2ludCwgZGVmaW5lZCBpbiBpdHMgb3duIGxvY2FsIGZyYW1lLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubG9jYWxBeGlzQV0gQW4gYXhpcywgZGVmaW5lZCBpbiBib2R5IEEgZnJhbWUsIHRoYXQgYm9keSBCJ3MgYW5jaG9yIHBvaW50IG1heSBzbGlkZSBhbG9uZy5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGlzYWJsZVJvdGF0aW9uYWxMb2NrXSBJZiBzZXQgdG8gdHJ1ZSwgYm9keUIgd2lsbCBiZSBmcmVlIHRvIHJvdGF0ZSBhcm91bmQgaXRzIGFuY2hvciBwb2ludC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy51cHBlckxpbWl0XVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxvd2VyTGltaXRdXHJcbiAgICAgKiBAdG9kbyBBYmlsaXR5IHRvIGNyZWF0ZSB1c2luZyBvbmx5IGEgcG9pbnQgYW5kIGEgd29ybGRBeGlzXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFByaXNtYXRpY0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XHJcbiAgICAgKiAgICAgICAgIGxvY2FsQXhpc0E6IFswLCAxXVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFByaXNtYXRpY0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBjb25zdHJhaW50XzEuZGVmYXVsdC5QUklTTUFUSUMsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLy8gR2V0IGFuY2hvcnNcclxuICAgICAgICB2YXIgbG9jYWxBbmNob3JBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGxvY2FsQXhpc0EgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDEsIDApLCBsb2NhbEFuY2hvckIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQW5jaG9yQSkge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KGxvY2FsQW5jaG9yQSwgb3B0aW9ucy5sb2NhbEFuY2hvckEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQXhpc0EpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShsb2NhbEF4aXNBLCBvcHRpb25zLmxvY2FsQXhpc0EpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQW5jaG9yQikge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KGxvY2FsQW5jaG9yQiwgb3B0aW9ucy5sb2NhbEFuY2hvckIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5sb2NhbEFuY2hvckEgPSBsb2NhbEFuY2hvckE7XHJcbiAgICAgICAgX3RoaXMubG9jYWxBbmNob3JCID0gbG9jYWxBbmNob3JCO1xyXG4gICAgICAgIF90aGlzLmxvY2FsQXhpc0EgPSBsb2NhbEF4aXNBO1xyXG4gICAgICAgIC8qXHJcblxyXG4gICAgICAgIFRoZSBjb25zdHJhaW50IHZpb2xhdGlvbiBmb3IgdGhlIGNvbW1vbiBheGlzIHBvaW50IGlzXHJcblxyXG4gICAgICAgICAgICBnID0gKCB4aiArIHJqIC0geGkgLSByaSApICogdCAgIDo9ICBnZyp0XHJcblxyXG4gICAgICAgIHdoZXJlIHIgYXJlIGJvZHktbG9jYWwgYW5jaG9yIHBvaW50cywgYW5kIHQgaXMgYSB0YW5nZW50IHRvIHRoZSBjb25zdHJhaW50IGF4aXMgZGVmaW5lZCBpbiBib2R5IGkgZnJhbWUuXHJcblxyXG4gICAgICAgICAgICBnZG90ID0gICggdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpICkgKiB0ICsgKCB4aiArIHJqIC0geGkgLSByaSApICogKCB3aSB4IHQgKVxyXG5cclxuICAgICAgICBOb3RlIHRoZSB1c2Ugb2YgdGhlIGNoYWluIHJ1bGUuIE5vdyB3ZSBpZGVudGlmeSB0aGUgamFjb2JpYW5cclxuXHJcbiAgICAgICAgICAgIEcqVyA9IFsgLXQgICAgICAtcmkgeCB0ICsgdCB4IGdnICAgICB0ICAgIHJqIHggdCBdICogW3ZpIHdpIHZqIHdqXVxyXG5cclxuICAgICAgICBUaGUgcm90YXRpb25hbCBwYXJ0IGlzIGp1c3QgYSByb3RhdGlvbiBsb2NrLlxyXG5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHZhciBtYXhGb3JjZSA9IF90aGlzLm1heEZvcmNlID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1heEZvcmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eTtcclxuICAgICAgICAvLyBUcmFuc2xhdGlvbmFsIHBhcnRcclxuICAgICAgICB2YXIgdHJhbnMgPSBuZXcgRXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSk7XHJcbiAgICAgICAgdmFyIHJpID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHJqID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGdnID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHQgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGEgYmFkIHByYWN0aWNlLlxyXG4gICAgICAgIHRyYW5zLmNvbXB1dGVHcSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gZyA9ICggeGogKyByaiAtIHhpIC0gcmkgKSAqIHRcclxuICAgICAgICAgICAgcmV0dXJuIHZlYzJfMS5kZWZhdWx0LmRvdChnZywgdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGEgYmFkIHByYWN0aWNlLlxyXG4gICAgICAgIHRyYW5zLnVwZGF0ZUphY29iaWFuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgRyA9IHRoaXMuRywgeGkgPSBib2R5QS5wb3NpdGlvbiwgeGogPSBib2R5Qi5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHJpLCBsb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHJqLCBsb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKGdnLCB4aiwgcmopO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChnZywgZ2csIHhpKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoZ2csIGdnLCByaSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh0LCBsb2NhbEF4aXNBLCBib2R5QS5hbmdsZSArIE1hdGguUEkgLyAyKTtcclxuICAgICAgICAgICAgR1swXSA9IC10WzBdO1xyXG4gICAgICAgICAgICBHWzFdID0gLXRbMV07XHJcbiAgICAgICAgICAgIEdbMl0gPSAtdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmksIHQpICsgdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgodCwgZ2cpO1xyXG4gICAgICAgICAgICBHWzNdID0gdFswXTtcclxuICAgICAgICAgICAgR1s0XSA9IHRbMV07XHJcbiAgICAgICAgICAgIEdbNV0gPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyaiwgdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMucHVzaCh0cmFucyk7XHJcbiAgICAgICAgLy8gUm90YXRpb25hbCBwYXJ0XHJcbiAgICAgICAgaWYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVSb3RhdGlvbmFsTG9jaykpIHtcclxuICAgICAgICAgICAgdmFyIHJvdCA9IG5ldyByb3RhdGlvbmFsX2xvY2tfZXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgICAgIF90aGlzLmVxdWF0aW9ucy5wdXNoKHJvdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBwb3NpdGlvbiBvZiBhbmNob3IgQSByZWxhdGl2ZSB0byBhbmNob3IgQiwgYWxvbmcgdGhlIGNvbnN0cmFpbnQgYXhpcy5cclxuICAgICAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnBvc2l0aW9uID0gMDtcclxuICAgICAgICAvLyBJcyB0aGlzIG9uZSB1c2VkIGF0IGFsbD9cclxuICAgICAgICBfdGhpcy52ZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIGxvd2VyIGxpbWl0LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0RW5hYmxlZFxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxvd2VyTGltaXRFbmFibGVkID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb3dlckxpbWl0KSAhPT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSB1cHBlciBsaW1pdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdEVuYWJsZWRcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXBwZXJMaW1pdCkgIT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb3dlciBjb25zdHJhaW50IGxpbWl0LiBUaGUgY29uc3RyYWludCBwb3NpdGlvbiBpcyBmb3JjZWQgdG8gYmUgbGFyZ2VyIHRoYW4gdGhpcyB2YWx1ZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgbG93ZXJMaW1pdFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubG93ZXJMaW1pdCA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb3dlckxpbWl0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwcGVyIGNvbnN0cmFpbnQgbGltaXQuIFRoZSBjb25zdHJhaW50IHBvc2l0aW9uIGlzIGZvcmNlZCB0byBiZSBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudXBwZXJMaW1pdCA9IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cHBlckxpbWl0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAxO1xyXG4gICAgICAgIC8vIEVxdWF0aW9ucyB1c2VkIGZvciBsaW1pdHNcclxuICAgICAgICBfdGhpcy51cHBlckxpbWl0RXF1YXRpb24gPSBuZXcgY29udGFjdF9lcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCKTtcclxuICAgICAgICBfdGhpcy5sb3dlckxpbWl0RXF1YXRpb24gPSBuZXcgY29udGFjdF9lcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCKTtcclxuICAgICAgICAvLyBTZXQgbWF4L21pbiBmb3JjZXNcclxuICAgICAgICBfdGhpcy51cHBlckxpbWl0RXF1YXRpb24ubWluRm9yY2UgPSBfdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWluRm9yY2UgPSAwO1xyXG4gICAgICAgIF90aGlzLnVwcGVyTGltaXRFcXVhdGlvbi5tYXhGb3JjZSA9IF90aGlzLmxvd2VyTGltaXRFcXVhdGlvbi5tYXhGb3JjZSA9IG1heEZvcmNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVxdWF0aW9uIHVzZWQgZm9yIHRoZSBtb3Rvci5cclxuICAgICAgICAgKiBAcHJvcGVydHkgbW90b3JFcXVhdGlvblxyXG4gICAgICAgICAqIEB0eXBlIHtFcXVhdGlvbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5tb3RvckVxdWF0aW9uID0gbmV3IEVxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjdXJyZW50IG1vdG9yIHN0YXRlLiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgbW90b3IgdXNpbmcgLmVuYWJsZU1vdG9yXHJcbiAgICAgICAgICogQHByb3BlcnR5IG1vdG9yRW5hYmxlZFxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgdGFyZ2V0IHNwZWVkIGZvciB0aGUgbW90b3IuXHJcbiAgICAgICAgICogQHByb3BlcnR5IG1vdG9yU3BlZWRcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLm1vdG9yU3BlZWQgPSAwO1xyXG4gICAgICAgIHZhciB0aGF0ID0gX3RoaXM7XHJcbiAgICAgICAgdmFyIG1vdG9yRXF1YXRpb24gPSBfdGhpcy5tb3RvckVxdWF0aW9uO1xyXG4gICAgICAgIG1vdG9yRXF1YXRpb24uY29tcHV0ZUdxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcclxuICAgICAgICBtb3RvckVxdWF0aW9uLmNvbXB1dGVHVyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIEcgPSB0aGlzLkcsIGJpID0gdGhpcy5ib2R5QSwgYmogPSB0aGlzLmJvZHlCLCB2aSA9IGJpLnZlbG9jaXR5LCB2aiA9IGJqLnZlbG9jaXR5LCB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eSwgd2ogPSBiai5hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdtdWx0KEcsIHZpLCB3aSwgdmosIHdqKSArIHRoYXQubW90b3JTcGVlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBjb25zdHJhaW50IGVxdWF0aW9ucy4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBib2RpZXMgY2hhbmdlZCBwb3NpdGlvbiwgYmVmb3JlIHNvbHZpbmcuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBQcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zLCB0cmFucyA9IGVxc1swXSwgdXBwZXJMaW1pdCA9IHRoaXMudXBwZXJMaW1pdCwgbG93ZXJMaW1pdCA9IHRoaXMubG93ZXJMaW1pdCwgdXBwZXJMaW1pdEVxdWF0aW9uID0gdGhpcy51cHBlckxpbWl0RXF1YXRpb24sIGxvd2VyTGltaXRFcXVhdGlvbiA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uLCBib2R5QSA9IHRoaXMuYm9keUEsIGJvZHlCID0gdGhpcy5ib2R5QiwgbG9jYWxBeGlzQSA9IHRoaXMubG9jYWxBeGlzQSwgbG9jYWxBbmNob3JBID0gdGhpcy5sb2NhbEFuY2hvckEsIGxvY2FsQW5jaG9yQiA9IHRoaXMubG9jYWxBbmNob3JCO1xyXG4gICAgICAgIHRyYW5zLnVwZGF0ZUphY29iaWFuKCk7XHJcbiAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIHRoaW5ncyB0byB3b3JsZFxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh3b3JsZEF4aXNBLCBsb2NhbEF4aXNBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKG9yaWVudGVkQW5jaG9yQSwgbG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKHdvcmxkQW5jaG9yQSwgb3JpZW50ZWRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKG9yaWVudGVkQW5jaG9yQiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKHdvcmxkQW5jaG9yQiwgb3JpZW50ZWRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XHJcbiAgICAgICAgdmFyIHJlbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9IHZlYzJfMS5kZWZhdWx0LmRvdCh3b3JsZEFuY2hvckIsIHdvcmxkQXhpc0EpIC0gdmVjMl8xLmRlZmF1bHQuZG90KHdvcmxkQW5jaG9yQSwgd29ybGRBeGlzQSk7XHJcbiAgICAgICAgLy8gTW90b3JcclxuICAgICAgICBpZiAodGhpcy5tb3RvckVuYWJsZWQpIHtcclxuICAgICAgICAgICAgLy8gRyA9IFsgYSAgICAgYSB4IHJpICAgLWEgICAtYSB4IHJqIF1cclxuICAgICAgICAgICAgdmFyIEcgPSB0aGlzLm1vdG9yRXF1YXRpb24uRztcclxuICAgICAgICAgICAgR1swXSA9IHdvcmxkQXhpc0FbMF07XHJcbiAgICAgICAgICAgIEdbMV0gPSB3b3JsZEF4aXNBWzFdO1xyXG4gICAgICAgICAgICBHWzJdID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgod29ybGRBeGlzQSwgb3JpZW50ZWRBbmNob3JCKTtcclxuICAgICAgICAgICAgR1szXSA9IC13b3JsZEF4aXNBWzBdO1xyXG4gICAgICAgICAgICBHWzRdID0gLXdvcmxkQXhpc0FbMV07XHJcbiAgICAgICAgICAgIEdbNV0gPSAtdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgod29ybGRBeGlzQSwgb3JpZW50ZWRBbmNob3JBKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICAgICAgTGltaXRzIHN0cmF0ZWd5OlxyXG4gICAgICAgICAgICBBZGQgY29udGFjdCBlcXVhdGlvbiwgd2l0aCBub3JtYWwgYWxvbmcgdGhlIGNvbnN0cmFpbnQgYXhpcy5cclxuICAgICAgICAgICAgbWluL21heEZvcmNlIGlzIHNldCBzbyB0aGUgY29uc3RyYWludCBpcyByZXB1bHNpdmUgaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uLlxyXG4gICAgICAgICAgICBTb21lIG9mZnNldCBpcyBhZGRlZCB0byBlaXRoZXIgZXF1YXRpb24uY29udGFjdFBvaW50QSBvciAuY29udGFjdFBvaW50QiB0byBnZXQgdGhlIGNvcnJlY3QgdXBwZXIvbG93ZXIgbGltaXQuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF5cclxuICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgdXBwZXJMaW1pdCB4XHJcbiAgICAgICAgICAgICAgICAgICAgfCAgICAtLS0tLS1cclxuICAgICAgICAgICAgYW5jaG9yQiB4PC0tLXwgIEIgfFxyXG4gICAgICAgICAgICAgICAgICAgIHwgICAgfCAgICB8XHJcbiAgICAgICAgICAgIC0tLS0tLSAgIHwgICAgLS0tLS0tXHJcbiAgICAgICAgICAgIHwgICAgfCAgIHxcclxuICAgICAgICAgICAgfCAgQSB8LS0+eCBhbmNob3JBXHJcbiAgICAgICAgICAgIC0tLS0tLSAgIHxcclxuICAgICAgICAgICAgICAgICAgICB4IGxvd2VyTGltaXRcclxuICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgaWYgKHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgJiYgcmVsUG9zaXRpb24gPiB1cHBlckxpbWl0KSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjb250YWN0IGNvbnN0cmFpbnQgbm9ybWFsLCBldGNcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUodXBwZXJMaW1pdEVxdWF0aW9uLm5vcm1hbEEsIHdvcmxkQXhpc0EsIC0xKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QodXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdCh1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qiwgd29ybGRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKHRtcCwgd29ybGRBeGlzQSwgdXBwZXJMaW1pdCk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZCh1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSwgdXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHRtcCk7XHJcbiAgICAgICAgICAgIGlmIChlcXMuaW5kZXhPZih1cHBlckxpbWl0RXF1YXRpb24pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZXFzLnB1c2godXBwZXJMaW1pdEVxdWF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgJiYgcmVsUG9zaXRpb24gPCBsb3dlckxpbWl0KSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjb250YWN0IGNvbnN0cmFpbnQgbm9ybWFsLCBldGNcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUobG93ZXJMaW1pdEVxdWF0aW9uLm5vcm1hbEEsIHdvcmxkQXhpc0EsIDEpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSwgd29ybGRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLCB3b3JsZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUodG1wLCB3b3JsZEF4aXNBLCBsb3dlckxpbWl0KTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QobG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLCB0bXApO1xyXG4gICAgICAgICAgICBpZiAoZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGVxcy5wdXNoKGxvd2VyTGltaXRFcXVhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pO1xyXG4gICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlIHRoZSBtb3RvclxyXG4gICAgICogQG1ldGhvZCBlbmFibGVNb3RvclxyXG4gICAgICovXHJcbiAgICBQcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5tb3RvckVuYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHRoaXMubW90b3JFcXVhdGlvbik7XHJcbiAgICAgICAgdGhpcy5tb3RvckVuYWJsZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGlzYWJsZSB0aGUgcm90YXRpb25hbCBtb3RvclxyXG4gICAgICogQG1ldGhvZCBkaXNhYmxlTW90b3JcclxuICAgICAqL1xyXG4gICAgUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5tb3RvckVuYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcclxuICAgICAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY29uc3RyYWludCBsaW1pdHMuXHJcbiAgICAgKiBAbWV0aG9kIHNldExpbWl0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIExvd2VyIGxpbWl0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFVwcGVyIGxpbWl0LlxyXG4gICAgICovXHJcbiAgICBQcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5zZXRMaW1pdHMgPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAobG93ZXIpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcclxuICAgICAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcclxuICAgICAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mICh1cHBlcikgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xyXG4gICAgICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xyXG4gICAgICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBQcmlzbWF0aWNDb25zdHJhaW50O1xyXG59KGNvbnN0cmFpbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFByaXNtYXRpY0NvbnN0cmFpbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBjb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uc3RyYWludFwiKSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgcm90YXRpb25hbF92ZWxvY2l0eV9lcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvcm90YXRpb25hbC12ZWxvY2l0eS1lcXVhdGlvblwiKSk7XHJcbnZhciByb3RhdGlvbmFsX2xvY2tfZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL3JvdGF0aW9uYWwtbG9jay1lcXVhdGlvblwiKSk7XHJcbnZhciBzdWIgPSB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdDtcclxudmFyIGFkZCA9IHZlYzJfMS5kZWZhdWx0LmFkZDtcclxudmFyIGRvdCA9IHZlYzJfMS5kZWZhdWx0LmRvdDtcclxudmFyIHJvdGF0ZSA9IHZlYzJfMS5kZWZhdWx0LnJvdGF0ZTtcclxudmFyIGNvcHkgPSB2ZWMyXzEuZGVmYXVsdC5jb3B5O1xyXG52YXIgY3Jvc3NMZW5ndGggPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aDtcclxudmFyIHdvcmxkUGl2b3RBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHdvcmxkUGl2b3RCID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHhBeGlzID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygxLCAwKSwgeUF4aXMgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDAsIDEpLCBnID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBSZXZvbHV0ZUNvbnN0cmFpbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUmV2b2x1dGVDb25zdHJhaW50LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0cyB0d28gYm9kaWVzIGF0IGdpdmVuIG9mZnNldCBwb2ludHMsIGxldHRpbmcgdGhlbSByb3RhdGUgcmVsYXRpdmUgdG8gZWFjaCBvdGhlciBhcm91bmQgdGhpcyBwb2ludC5cclxuICAgICAqIEBjbGFzcyBSZXZvbHV0ZUNvbnN0cmFpbnRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSAgICBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSAgICBib2R5QlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMud29ybGRQaXZvdF0gQSBwaXZvdCBwb2ludCBnaXZlbiBpbiB3b3JsZCBjb29yZGluYXRlcy4gSWYgc3BlY2lmaWVkLCBsb2NhbFBpdm90QSBhbmQgbG9jYWxQaXZvdEIgYXJlIGF1dG9tYXRpY2FsbHkgY29tcHV0ZWQgZnJvbSB0aGlzIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbFBpdm90QV0gVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyBvZiBib2R5QSB3aGljaCBib2R5QSBpcyBjb25zdHJhaW5lZCB0by5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxQaXZvdEJdIFNlZSBsb2NhbFBpdm90QS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgW29wdGlvbnMubWF4Rm9yY2VdIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuXHJcbiAgICAgKiBAZXh0ZW5kcyBDb25zdHJhaW50XHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgcmV2b2x1dGUgY29uc3RyYWludCBiZXR3ZWVuIHR3byBib2RpZXMgd2l0aCBwaXZvdCBwb2ludCBpbiBiZXR3ZWVuIHRoZW0uXHJcbiAgICAgKiAgICAgdmFyIGJvZHlBID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWy0xLCAwXSB9KTtcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHlBKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgdmFyIGJvZHlCID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWzEsIDBdIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keUIpO1xyXG4gICAgICpcclxuICAgICAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBSZXZvbHV0ZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XHJcbiAgICAgKiAgICAgICAgIHdvcmxkUGl2b3Q6IFswLCAwXVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIFVzaW5nIGJvZHktbG9jYWwgcGl2b3QgcG9pbnRzLCB0aGUgY29uc3RyYWludCBjb3VsZCBoYXZlIGJlZW4gY29uc3RydWN0ZWQgbGlrZSB0aGlzOlxyXG4gICAgICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFJldm9sdXRlQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcclxuICAgICAqICAgICAgICAgbG9jYWxQaXZvdEE6IFsxLCAwXSxcclxuICAgICAqICAgICAgICAgbG9jYWxQaXZvdEI6IFstMSwgMF1cclxuICAgICAqICAgICB9KTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmV2b2x1dGVDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIGNvbnN0cmFpbnRfMS5kZWZhdWx0LlJFVk9MVVRFLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIHZhciBtYXhGb3JjZSA9IF90aGlzLm1heEZvcmNlID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1heEZvcmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eTtcclxuICAgICAgICB2YXIgcGl2b3RBID0gX3RoaXMucGl2b3RBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIHBpdm90QiA9IF90aGlzLnBpdm90QiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud29ybGRQaXZvdCkge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHBpdm90QSBhbmQgcGl2b3RCXHJcbiAgICAgICAgICAgIHN1YihwaXZvdEEsIG9wdGlvbnMud29ybGRQaXZvdCwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICBzdWIocGl2b3RCLCBvcHRpb25zLndvcmxkUGl2b3QsIGJvZHlCLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgLy8gUm90YXRlIHRvIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgICAgICAgICAgIHJvdGF0ZShwaXZvdEEsIHBpdm90QSwgLWJvZHlBLmFuZ2xlKTtcclxuICAgICAgICAgICAgcm90YXRlKHBpdm90QiwgcGl2b3RCLCAtYm9keUIuYW5nbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gR2V0IHBpdm90QSBhbmQgcGl2b3RCXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9jYWxQaXZvdEEpIHtcclxuICAgICAgICAgICAgICAgIGNvcHkocGl2b3RBLCBvcHRpb25zLmxvY2FsUGl2b3RBKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsUGl2b3RCKSB7XHJcbiAgICAgICAgICAgICAgICBjb3B5KHBpdm90Qiwgb3B0aW9ucy5sb2NhbFBpdm90Qik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1vdG9yRXF1YXRpb24gPSBfdGhpcy5tb3RvckVxdWF0aW9uID0gbmV3IHJvdGF0aW9uYWxfdmVsb2NpdHlfZXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgbW90b3JFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHVwcGVyTGltaXRFcXVhdGlvbiA9IF90aGlzLnVwcGVyTGltaXRFcXVhdGlvbiA9IG5ldyByb3RhdGlvbmFsX2xvY2tfZXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgdmFyIGxvd2VyTGltaXRFcXVhdGlvbiA9IF90aGlzLmxvd2VyTGltaXRFcXVhdGlvbiA9IG5ldyByb3RhdGlvbmFsX2xvY2tfZXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uLm1pbkZvcmNlID0gbG93ZXJMaW1pdEVxdWF0aW9uLm1heEZvcmNlID0gMDtcclxuICAgICAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcclxuICAgICAgICB2YXIgZXFzID0gX3RoaXMuZXF1YXRpb25zID0gW1xyXG4gICAgICAgICAgICBuZXcgRXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSksXHJcbiAgICAgICAgICAgIG5ldyBFcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKSxcclxuICAgICAgICAgICAgbW90b3JFcXVhdGlvbixcclxuICAgICAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uLFxyXG4gICAgICAgICAgICBsb3dlckxpbWl0RXF1YXRpb25cclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciB4ID0gZXFzWzBdO1xyXG4gICAgICAgIHZhciB5ID0gZXFzWzFdO1xyXG4gICAgICAgIC8vIFRPRE86IGJhZCBwcmFjdGljZS5cclxuICAgICAgICB4LmNvbXB1dGVHcSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcm90YXRlKHdvcmxkUGl2b3RBLCBwaXZvdEEsIGJvZHlBLmFuZ2xlKTtcclxuICAgICAgICAgICAgcm90YXRlKHdvcmxkUGl2b3RCLCBwaXZvdEIsIGJvZHlCLmFuZ2xlKTtcclxuICAgICAgICAgICAgYWRkKGcsIGJvZHlCLnBvc2l0aW9uLCB3b3JsZFBpdm90Qik7XHJcbiAgICAgICAgICAgIHN1YihnLCBnLCBib2R5QS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHN1YihnLCBnLCB3b3JsZFBpdm90QSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkb3QoZywgeEF4aXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgeS5jb21wdXRlR3EgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJvdGF0ZSh3b3JsZFBpdm90QSwgcGl2b3RBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgICAgIHJvdGF0ZSh3b3JsZFBpdm90QiwgcGl2b3RCLCBib2R5Qi5hbmdsZSk7XHJcbiAgICAgICAgICAgIGFkZChnLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRQaXZvdEIpO1xyXG4gICAgICAgICAgICBzdWIoZywgZywgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICBzdWIoZywgZywgd29ybGRQaXZvdEEpO1xyXG4gICAgICAgICAgICByZXR1cm4gZG90KGcsIHlBeGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHkubWluRm9yY2UgPSB4Lm1pbkZvcmNlID0gLW1heEZvcmNlO1xyXG4gICAgICAgIHkubWF4Rm9yY2UgPSB4Lm1heEZvcmNlID0gbWF4Rm9yY2U7XHJcbiAgICAgICAgLy8gVGhlc2UgbmV2ZXIgY2hhbmdlIGJ1dCB0aGUgYW5ndWxhciBwYXJ0cyBkb1xyXG4gICAgICAgIHguR1swXSA9IC0xO1xyXG4gICAgICAgIHguR1sxXSA9IDA7XHJcbiAgICAgICAgeC5HWzNdID0gMTtcclxuICAgICAgICB4LkdbNF0gPSAwO1xyXG4gICAgICAgIHkuR1swXSA9IDA7XHJcbiAgICAgICAgeS5HWzFdID0gLTE7XHJcbiAgICAgICAgeS5HWzNdID0gMDtcclxuICAgICAgICB5LkdbNF0gPSAxO1xyXG4gICAgICAgIF90aGlzLmFuZ2xlID0gMDtcclxuICAgICAgICBfdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubG93ZXJMaW1pdCA9IDA7XHJcbiAgICAgICAgX3RoaXMudXBwZXJMaW1pdCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNvbnN0cmFpbnQgYW5nbGUgbGltaXRzLCBhbmQgZW5hYmxlIHRoZW0uXHJcbiAgICAgKiBAbWV0aG9kIHNldExpbWl0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIExvd2VyIGFuZ2xlIGxpbWl0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFVwcGVyIGFuZ2xlIGxpbWl0LlxyXG4gICAgICovXHJcbiAgICBSZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcclxuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcclxuICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcclxuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSwgYm9keUIgPSB0aGlzLmJvZHlCLCBwaXZvdEEgPSB0aGlzLnBpdm90QSwgcGl2b3RCID0gdGhpcy5waXZvdEIsIGVxcyA9IHRoaXMuZXF1YXRpb25zLCB4ID0gZXFzWzBdLCB5ID0gZXFzWzFdLCB1cHBlckxpbWl0ID0gdGhpcy51cHBlckxpbWl0LCBsb3dlckxpbWl0ID0gdGhpcy5sb3dlckxpbWl0LCB1cHBlckxpbWl0RXF1YXRpb24gPSB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbiwgbG93ZXJMaW1pdEVxdWF0aW9uID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb247XHJcbiAgICAgICAgdmFyIHJlbEFuZ2xlID0gdGhpcy5hbmdsZSA9IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XHJcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uLmFuZ2xlID0gdXBwZXJMaW1pdDtcclxuICAgICAgICB1cHBlckxpbWl0RXF1YXRpb24uZW5hYmxlZCA9IHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgJiYgcmVsQW5nbGUgPiB1cHBlckxpbWl0O1xyXG4gICAgICAgIGxvd2VyTGltaXRFcXVhdGlvbi5hbmdsZSA9IGxvd2VyTGltaXQ7XHJcbiAgICAgICAgbG93ZXJMaW1pdEVxdWF0aW9uLmVuYWJsZWQgPSB0aGlzLmxvd2VyTGltaXRFbmFibGVkICYmIHJlbEFuZ2xlIDwgbG93ZXJMaW1pdDtcclxuICAgICAgICAvKlxyXG5cclxuICAgICAgICBUaGUgY29uc3RyYWludCB2aW9sYXRpb24gaXNcclxuXHJcbiAgICAgICAgICAgIGcgPSB4aiArIHJqIC0geGkgLSByaVxyXG5cclxuICAgICAgICAuLi53aGVyZSB4aSBhbmQgeGogYXJlIHRoZSBib2R5IHBvc2l0aW9ucyBhbmQgcmkgYW5kIHJqIHdvcmxkLW9yaWVudGVkIG9mZnNldCB2ZWN0b3JzLiBEaWZmZXJlbnRpYXRlOlxyXG5cclxuICAgICAgICAgICAgZ2RvdCA9IHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaVxyXG5cclxuICAgICAgICBXZSBzcGxpdCB0aGlzIGludG8geCBhbmQgeSBkaXJlY3Rpb25zLiAobGV0IHggYW5kIHkgYmUgdW5pdCB2ZWN0b3JzIGFsb25nIHRoZSByZXNwZWN0aXZlIGF4ZXMpXHJcblxyXG4gICAgICAgICAgICBnZG90ICogeCA9ICggdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpICkgKiB4XHJcbiAgICAgICAgICAgICAgICAgICAgPSAoIHZqKnggKyAod2ogeCByaikqeCAtdmkqeCAtKHdpIHggcmkpKnhcclxuICAgICAgICAgICAgICAgICAgICA9ICggdmoqeCArIChyaiB4IHgpKndqIC12aSp4IC0ocmkgeCB4KSp3aVxyXG4gICAgICAgICAgICAgICAgICAgID0gWyAteCAgIC0ocmkgeCB4KSAgIHggICAocmogeCB4KV0gKiBbdmkgd2kgdmogd2pdXHJcbiAgICAgICAgICAgICAgICAgICAgPSBHKldcclxuXHJcbiAgICAgICAgLi4uYW5kIHNpbWlsYXIgZm9yIHkuIFdlIGhhdmUgdGhlbiBpZGVudGlmaWVkIHRoZSBqYWNvYmlhbiBlbnRyaWVzIGZvciB4IGFuZCB5IGRpcmVjdGlvbnM6XHJcblxyXG4gICAgICAgICAgICBHeCA9IFsgeCAgIChyaiB4IHgpICAgLXggICAtKHJpIHggeCldXHJcbiAgICAgICAgICAgIEd5ID0gWyB5ICAgKHJqIHggeSkgICAteSAgIC0ocmkgeCB5KV1cclxuXHJcbiAgICAgICAgU28gZm9yIGV4YW1wbGUsIGluIHRoZSBYIGRpcmVjdGlvbiB3ZSB3b3VsZCBnZXQgaW4gMiBkaW1lbnNpb25zXHJcblxyXG4gICAgICAgICAgICBHID0gWyBbMSAgIDAgICAocmogeCBbMSwwXSkgICAtMSAgIDAgICAtKHJpIHggWzEsMF0pXVxyXG4gICAgICAgICAgICAgICAgWzAgICAxICAgKHJqIHggWzAsMV0pICAgIDAgIC0xICAgLShyaSB4IFswLDFdKV1cclxuICAgICAgICAqL1xyXG4gICAgICAgIHJvdGF0ZSh3b3JsZFBpdm90QSwgcGl2b3RBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgcm90YXRlKHdvcmxkUGl2b3RCLCBwaXZvdEIsIGJvZHlCLmFuZ2xlKTtcclxuICAgICAgICAvLyBAdG9kbzogdGhlc2UgYXJlIGEgYml0IHNwYXJzZS4gV2UgY291bGQgc2F2ZSBzb21lIGNvbXB1dGF0aW9ucyBvbiBtYWtpbmcgY3VzdG9tIGVxLmNvbXB1dGVHVyBmdW5jdGlvbnMsIGV0Y1xyXG4gICAgICAgIHZhciB4RyA9IHguRztcclxuICAgICAgICB4R1syXSA9IC1jcm9zc0xlbmd0aCh3b3JsZFBpdm90QSwgeEF4aXMpO1xyXG4gICAgICAgIHhHWzVdID0gY3Jvc3NMZW5ndGgod29ybGRQaXZvdEIsIHhBeGlzKTtcclxuICAgICAgICB2YXIgeUcgPSB5Lkc7XHJcbiAgICAgICAgeUdbMl0gPSAtY3Jvc3NMZW5ndGgod29ybGRQaXZvdEEsIHlBeGlzKTtcclxuICAgICAgICB5R1s1XSA9IGNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RCLCB5QXhpcyk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUsIFwibW90b3JFbmFibGVkXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG1vdG9yRW5hYmxlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3RvckVxdWF0aW9uLmVuYWJsZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLCBcIm1vdG9yU3BlZWRcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3RvclNwZWVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdG9yRXF1YXRpb24ucmVsYXRpdmVWZWxvY2l0eTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW90b3JFcXVhdGlvbi5yZWxhdGl2ZVZlbG9jaXR5ID0gdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUsIFwibW90b3JNYXhGb3JjZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdG9yTWF4Rm9yY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW90b3JFcXVhdGlvbi5tYXhGb3JjZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBlcSA9IHRoaXMubW90b3JFcXVhdGlvbjtcclxuICAgICAgICAgICAgZXEubWF4Rm9yY2UgPSB2YWx1ZTtcclxuICAgICAgICAgICAgZXEubWluRm9yY2UgPSAtdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFJldm9sdXRlQ29uc3RyYWludDtcclxufShjb25zdHJhaW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSZXZvbHV0ZUNvbnN0cmFpbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbi8vIFNob3J0Y3V0cy5cclxudmFyIHNjYWxlID0gdmVjMl8xLmRlZmF1bHQuc2NhbGUsIG11bHRpcGx5ID0gdmVjMl8xLmRlZmF1bHQubXVsdGlwbHksIGNyZWF0ZVZlYzIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGU7XHJcbnZhciBFcXVhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQmFzZSBjbGFzcyBmb3IgY29uc3RyYWludCBlcXVhdGlvbnMuXHJcbiAgICAgKiBAY2xhc3MgRXF1YXRpb25cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QSBGaXJzdCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGVxdWF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCIFNlY29uZCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGVxdWF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluRm9yY2UgTWluaW11bSBmb3JjZSB0byBhcHBseS4gRGVmYXVsdDogLUluZmluaXR5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4Rm9yY2UgTWF4aW11bSBmb3JjZSB0byBhcHBseS4gRGVmYXVsdDogSW5maW5pdHlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtaW5Gb3JjZSwgbWF4Rm9yY2UpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYXAgdGhlIGNvbnN0cmFpbnQgdmlvbGF0aW9uIChHKnEpIHRvIHRoaXMgdmFsdWUuXHJcbiAgICAgICAgICogQHByb3BlcnR5IG1heEJpYXNcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWF4QmlhcyA9IEluZmluaXR5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzdGlmZm5lc3Mgb2YgdGhpcyBlcXVhdGlvbi4gVHlwaWNhbGx5IGNob3NlbiB0byBhIGxhcmdlIG51bWJlciAofjFlNyksIGJ1dCBjYW4gYmUgY2hvc2VuIHNvbWV3aGF0IGZyZWVseSB0byBnZXQgYSBzdGFibGUgc2ltdWxhdGlvbi5cclxuICAgICAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0aWZmbmVzcyA9IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgdGltZSBzdGVwcyBuZWVkZWQgdG8gc3RhYmlsaXplIHRoZSBjb25zdHJhaW50IGVxdWF0aW9uLiBUeXBpY2FsbHkgYmV0d2VlbiAzIGFuZCA1IHRpbWUgc3RlcHMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHJlbGF4YXRpb25cclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVsYXhhdGlvbiA9IEVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTjtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5hID0gMDtcclxuICAgICAgICB0aGlzLmIgPSAwO1xyXG4gICAgICAgIHRoaXMuZXBzaWxvbiA9IDA7XHJcbiAgICAgICAgdGhpcy50aW1lU3RlcCA9IDEgLyA2MDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgc3RpZmZuZXNzIG9yIHJlbGF4YXRpb24gd2FzIGNoYW5nZWQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBuZWVkc1VwZGF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSByZXN1bHRpbmcgY29uc3RyYWludCBtdWx0aXBsaWVyIGZyb20gdGhlIGxhc3Qgc29sdmUuIFRoaXMgaXMgbW9zdGx5IGVxdWl2YWxlbnQgdG8gdGhlIGZvcmNlIHByb2R1Y2VkIGJ5IHRoZSBjb25zdHJhaW50LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbGF0aXZlIHZlbG9jaXR5LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZWxhdGl2ZVZlbG9jaXR5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZWxhdGl2ZVZlbG9jaXR5ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgZXF1YXRpb24gaXMgZW5hYmxlZCBvciBub3QuIElmIHRydWUsIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNvbHZlci5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGVuYWJsZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIFRlbXAgc3R1ZmZcclxuICAgICAgICB0aGlzLm1heEZvcmNlRHQgPSAwO1xyXG4gICAgICAgIHRoaXMubWluRm9yY2VEdCA9IDA7XHJcbiAgICAgICAgdGhpcy5pbnZDID0gMDtcclxuICAgICAgICB0aGlzLkIgPSAwO1xyXG4gICAgICAgIHRoaXMubGFtYmRhID0gMDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XHJcbiAgICAgICAgdGhpcy5taW5Gb3JjZSA9IG1pbkZvcmNlICE9PSBudWxsICYmIG1pbkZvcmNlICE9PSB2b2lkIDAgPyBtaW5Gb3JjZSA6IC1JbmZpbml0eTtcclxuICAgICAgICB0aGlzLm1heEZvcmNlID0gbWF4Rm9yY2UgIT09IG51bGwgJiYgbWF4Rm9yY2UgIT09IHZvaWQgMCA/IG1heEZvcmNlIDogSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5tYXhCaWFzID0gSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBICE9PSBudWxsICYmIGJvZHlBICE9PSB2b2lkIDAgPyBib2R5QSA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib2R5QiA9IGJvZHlCICE9PSBudWxsICYmIGJvZHlCICE9PSB2b2lkIDAgPyBib2R5QiA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgPSBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcclxuICAgICAgICB0aGlzLnJlbGF4YXRpb24gPSBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XHJcbiAgICAgICAgdGhpcy5HID0gbmV3IEZsb2F0MzJBcnJheSg2KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLkdbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSBTUE9PSyBwYXJhbWV0ZXJzIC5hLCAuYiBhbmQgLmVwc2lsb24gYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhcmFtZXRlcnMuIFNlZSBlcXVhdGlvbnMgOSwgMTAgYW5kIDExIGluIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci81RFYwNTgvVlQwOS9sZWN0dXJlcy9zcG9va25vdGVzLnBkZlwiPlNQT09LIG5vdGVzPC9hPi5cclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEVxdWF0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcywgZCA9IHRoaXMucmVsYXhhdGlvbiwgaCA9IHRoaXMudGltZVN0ZXA7XHJcbiAgICAgICAgdGhpcy5hID0gNCAvIChoICogKDEgKyA0ICogZCkpO1xyXG4gICAgICAgIHRoaXMuYiA9ICg0ICogZCkgLyAoMSArIDQgKiBkKTtcclxuICAgICAgICB0aGlzLmVwc2lsb24gPSA0IC8gKGggKiBoICogayAqICgxICsgNCAqIGQpKTtcclxuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBseSBhIGphY29iaWFuIGVudHJ5IHdpdGggY29ycmVzcG9uZGluZyBwb3NpdGlvbnMgb3IgdmVsb2NpdGllc1xyXG4gICAgICogQG1ldGhvZCBnbXVsdFxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUuZ211bHQgPSBmdW5jdGlvbiAoRywgdmksIHdpLCB2aiwgd2opIHtcclxuICAgICAgICByZXR1cm4gR1swXSAqIHZpWzBdICtcclxuICAgICAgICAgICAgR1sxXSAqIHZpWzFdICtcclxuICAgICAgICAgICAgR1syXSAqIHdpICtcclxuICAgICAgICAgICAgR1szXSAqIHZqWzBdICtcclxuICAgICAgICAgICAgR1s0XSAqIHZqWzFdICtcclxuICAgICAgICAgICAgR1s1XSAqIHdqO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIFJIUyBvZiB0aGUgU1BPT0sgZXF1YXRpb25cclxuICAgICAqIEBtZXRob2QgY29tcHV0ZUJcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24gKGEsIGIsIGgpIHtcclxuICAgICAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xyXG4gICAgICAgIHZhciBHcSA9IHRoaXMuY29tcHV0ZUdxKCk7XHJcbiAgICAgICAgdmFyIG1heEJpYXMgPSB0aGlzLm1heEJpYXM7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKEdxKSA+IG1heEJpYXMpIHtcclxuICAgICAgICAgICAgR3EgPSBHcSA+IDAgPyBtYXhCaWFzIDogLW1heEJpYXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xyXG4gICAgICAgIHZhciBCID0gLUdxICogYSAtIEdXICogYiAtIEdpTWYgKiBoO1xyXG4gICAgICAgIHJldHVybiBCO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgR1xcKnEsIHdoZXJlIHEgYXJlIHRoZSBnZW5lcmFsaXplZCBib2R5IGNvb3JkaW5hdGVzXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVHcVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBHID0gdGhpcy5HLCBiaSA9IHRoaXMuYm9keUEsIGJqID0gdGhpcy5ib2R5QjtcclxuICAgICAgICBpZiAoIWJpIHx8ICFiailcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgdmFyIGFpID0gYmkuYW5nbGUsIGFqID0gYmouYW5nbGU7XHJcbiAgICAgICAgdmFyIHFpID0gY3JlYXRlVmVjMigpLCBxaiA9IGNyZWF0ZVZlYzIoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbXVsdChHLCBxaSwgYWksIHFqLCBhaikgKyB0aGlzLm9mZnNldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIEdcXCpXLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVHV1xyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdXID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBHID0gdGhpcy5HLCBiaSA9IHRoaXMuYm9keUEsIGJqID0gdGhpcy5ib2R5QjtcclxuICAgICAgICBpZiAoIWJpIHx8ICFiailcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgdmFyIHZpID0gYmkudmVsb2NpdHksIHZqID0gYmoudmVsb2NpdHksIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LCB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbXVsdChHLCB2aSwgd2ksIHZqLCB3aikgKyB0aGlzLnJlbGF0aXZlVmVsb2NpdHk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBHXFwqV2xhbWJkYSwgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllc1xyXG4gICAgICogQG1ldGhvZCBjb21wdXRlR1dsYW1iZGFcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHV2xhbWJkYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgRyA9IHRoaXMuRywgYmkgPSB0aGlzLmJvZHlBLCBiaiA9IHRoaXMuYm9keUI7XHJcbiAgICAgICAgaWYgKCFiaSB8fCAhYmopXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHZhciB2aSA9IGJpLnZsYW1iZGEsIHZqID0gYmoudmxhbWJkYSwgd2kgPSBiaS53bGFtYmRhLCB3aiA9IGJqLndsYW1iZGE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ211bHQoRywgdmksIHdpLCB2aiwgd2opO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgR1xcKmludihNKVxcKmYsIHdoZXJlIE0gaXMgdGhlIG1hc3MgbWF0cml4IHdpdGggZGlhZ29uYWwgYmxvY2tzIGZvciBlYWNoIGJvZHksIGFuZCBmIGFyZSB0aGUgZm9yY2VzIG9uIHRoZSBib2RpZXMuXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVHaU1mXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLCBiaiA9IHRoaXMuYm9keUI7XHJcbiAgICAgICAgaWYgKCFiaSB8fCAhYmopXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHZhciBmaSA9IGJpLmZvcmNlLCB0aSA9IGJpLmFuZ3VsYXJGb3JjZSwgZmogPSBiai5mb3JjZSwgdGogPSBiai5hbmd1bGFyRm9yY2UsIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLCBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSwgaW52SWkgPSBiaS5pbnZJbmVydGlhU29sdmUsIGludklqID0gYmouaW52SW5lcnRpYVNvbHZlLCBHID0gdGhpcy5HO1xyXG4gICAgICAgIHZhciBpTWZpID0gY3JlYXRlVmVjMigpLCBpTWZqID0gY3JlYXRlVmVjMigpO1xyXG4gICAgICAgIHNjYWxlKGlNZmksIGZpLCBpbnZNYXNzaSk7XHJcbiAgICAgICAgbXVsdGlwbHkoaU1maSwgYmkubWFzc011bHRpcGxpZXIsIGlNZmkpO1xyXG4gICAgICAgIHNjYWxlKGlNZmosIGZqLCBpbnZNYXNzaik7XHJcbiAgICAgICAgbXVsdGlwbHkoaU1maiwgYmoubWFzc011bHRpcGxpZXIsIGlNZmopO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdtdWx0KEcsIGlNZmksIHRpICogaW52SWksIGlNZmosIHRqICogaW52SWopO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgR1xcKmludihNKVxcKkcnXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVHaU1HdFxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdpTUd0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiaSA9IHRoaXMuYm9keUEsIGJqID0gdGhpcy5ib2R5QjtcclxuICAgICAgICBpZiAoIWJpIHx8ICFiailcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgdmFyIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLCBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSwgaW52SWkgPSBiaS5pbnZJbmVydGlhU29sdmUsIGludklqID0gYmouaW52SW5lcnRpYVNvbHZlLCBHID0gdGhpcy5HO1xyXG4gICAgICAgIHJldHVybiBHWzBdICogR1swXSAqIGludk1hc3NpICogYmkubWFzc011bHRpcGxpZXJbMF0gK1xyXG4gICAgICAgICAgICBHWzFdICogR1sxXSAqIGludk1hc3NpICogYmkubWFzc011bHRpcGxpZXJbMV0gK1xyXG4gICAgICAgICAgICBHWzJdICogR1syXSAqIGludklpICtcclxuICAgICAgICAgICAgR1szXSAqIEdbM10gKiBpbnZNYXNzaiAqIGJqLm1hc3NNdWx0aXBsaWVyWzBdICtcclxuICAgICAgICAgICAgR1s0XSAqIEdbNF0gKiBpbnZNYXNzaiAqIGJqLm1hc3NNdWx0aXBsaWVyWzFdICtcclxuICAgICAgICAgICAgR1s1XSAqIEdbNV0gKiBpbnZJajtcclxuICAgIH07XHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUudXBkYXRlSmFjb2JpYW4gPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBjb25zdHJhaW50IHZlbG9jaXR5IHRvIHRoZSBib2RpZXMuXHJcbiAgICAgKiBAbWV0aG9kIGFkZFRvV2xhbWJkYVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhbGFtYmRhXHJcbiAgICAgKi9cclxuICAgIEVxdWF0aW9uLnByb3RvdHlwZS5hZGRUb1dsYW1iZGEgPSBmdW5jdGlvbiAoZGVsdGFsYW1iZGEpIHtcclxuICAgICAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLCBiaiA9IHRoaXMuYm9keUI7XHJcbiAgICAgICAgaWYgKCFiaSB8fCAhYmopXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLCBpbnZJaSA9IGJpLmludkluZXJ0aWFTb2x2ZSwgaW52SWogPSBiai5pbnZJbmVydGlhU29sdmUsIEcgPSB0aGlzLkc7XHJcbiAgICAgICAgLy8gdl9sYW1iZGEgPSBHICogaW52KE0pICogZGVsdGFfbGFtYmRhXHJcbiAgICAgICAgYWRkVG9WTGFtYmRhKGJpLnZsYW1iZGEsIEdbMF0sIEdbMV0sIGludk1hc3NpLCBkZWx0YWxhbWJkYSwgYmkubWFzc011bHRpcGxpZXIpO1xyXG4gICAgICAgIGJpLndsYW1iZGEgKz0gaW52SWkgKiBHWzJdICogZGVsdGFsYW1iZGE7XHJcbiAgICAgICAgYWRkVG9WTGFtYmRhKGJqLnZsYW1iZGEsIEdbM10sIEdbNF0sIGludk1hc3NqLCBkZWx0YWxhbWJkYSwgYmoubWFzc011bHRpcGxpZXIpO1xyXG4gICAgICAgIGJqLndsYW1iZGEgKz0gaW52SWogKiBHWzVdICogZGVsdGFsYW1iZGE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBkZW5vbWluYXRvciBwYXJ0IG9mIHRoZSBTUE9PSyBlcXVhdGlvbjogQyA9IEdcXCppbnYoTSlcXCpHJyArIGVwc1xyXG4gICAgICogQG1ldGhvZCBjb21wdXRlSW52Q1xyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBlcHNcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVJbnZDID0gZnVuY3Rpb24gKGVwcykge1xyXG4gICAgICAgIHZhciBpbnZDID0gMSAvICh0aGlzLmNvbXB1dGVHaU1HdCgpICsgZXBzKTtcclxuICAgICAgICByZXR1cm4gaW52QztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IHN0aWZmbmVzcyB3aGVuIGNyZWF0aW5nIGEgbmV3IEVxdWF0aW9uLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IERFRkFVTFRfU1RJRkZORVNTXHJcbiAgICAgKiBAZGVmYXVsdCAxZTZcclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1MgPSAxZTY7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IHJlbGF4YXRpb24gd2hlbiBjcmVhdGluZyBhIG5ldyBFcXVhdGlvbi5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBERUZBVUxUX1JFTEFYQVRJT05cclxuICAgICAqIEBkZWZhdWx0IDRcclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OID0gNDtcclxuICAgIHJldHVybiBFcXVhdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXF1YXRpb247XHJcbmZ1bmN0aW9uIGFkZFRvVkxhbWJkYSh2bGFtYmRhLCBHeCwgR3ksIGludk1hc3MsIGRlbHRhbGFtYmRhLCBtYXNzTXVsdGlwbGllcikge1xyXG4gICAgdmxhbWJkYVswXSArPSBHeCAqIGludk1hc3MgKiBkZWx0YWxhbWJkYSAqIG1hc3NNdWx0aXBsaWVyWzBdO1xyXG4gICAgdmxhbWJkYVsxXSArPSBHeSAqIGludk1hc3MgKiBkZWx0YWxhbWJkYSAqIG1hc3NNdWx0aXBsaWVyWzFdO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0VxdWF0aW9uXCIpKTtcclxudmFyIEFuZ2xlTG9ja0VxdWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFuZ2xlTG9ja0VxdWF0aW9uLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2NrcyB0aGUgcmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0d28gYm9kaWVzLiBUaGUgY29uc3RyYWludCB0cmllcyB0byBrZWVwIHRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIHR3byB2ZWN0b3JzLCBsb2NhbCBpbiBlYWNoIGJvZHksIHRvIHplcm8uIFRoZSBsb2NhbCBhbmdsZSBpbiBib2R5IGkgaXMgYSBwYXJhbWV0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIEFuZ2xlTG9ja0VxdWF0aW9uXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIEVxdWF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5nbGVdIEFuZ2xlIHRvIGFkZCB0byB0aGUgbG9jYWwgdmVjdG9yIGluIGJvZHkgQS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYXRpb10gR2VhciByYXRpb1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBbmdsZUxvY2tFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgLUluZmluaXR5LCBJbmZpbml0eSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5hbmdsZSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmdsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICBfdGhpcy5yYXRpbyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yYXRpbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcclxuICAgICAgICBfdGhpcy5zZXRSYXRpbyhfdGhpcy5yYXRpbyk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yYXRpbyAqIHRoaXMuYm9keUEuYW5nbGUgLSB0aGlzLmJvZHlCLmFuZ2xlICsgdGhpcy5hbmdsZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZ2VhciByYXRpbyBmb3IgdGhpcyBlcXVhdGlvblxyXG4gICAgICogQG1ldGhvZCBzZXRSYXRpb1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXHJcbiAgICAgKi9cclxuICAgIEFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5zZXRSYXRpbyA9IGZ1bmN0aW9uIChyYXRpbykge1xyXG4gICAgICAgIHZhciBHID0gdGhpcy5HO1xyXG4gICAgICAgIEdbMl0gPSByYXRpbztcclxuICAgICAgICBHWzVdID0gLTE7XHJcbiAgICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtYXggZm9yY2UgZm9yIHRoZSBlcXVhdGlvbi5cclxuICAgICAqIEBtZXRob2Qgc2V0TWF4VG9ycXVlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9ycXVlXHJcbiAgICAgKi9cclxuICAgIEFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5zZXRNYXhUb3JxdWUgPSBmdW5jdGlvbiAodG9ycXVlKSB7XHJcbiAgICAgICAgdGhpcy5tYXhGb3JjZSA9IHRvcnF1ZTtcclxuICAgICAgICB0aGlzLm1pbkZvcmNlID0gLXRvcnF1ZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQW5nbGVMb2NrRXF1YXRpb247XHJcbn0oRXF1YXRpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFuZ2xlTG9ja0VxdWF0aW9uO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9FcXVhdGlvblwiKSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbmZ1bmN0aW9uIGFkZFN1YlN1YihvdXQsIGEsIGIsIGMsIGQpIHtcclxuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdIC0gY1swXSAtIGRbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXSAtIGNbMV0gLSBkWzFdO1xyXG59XHJcbnZhciB2aSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgdmogPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHJlbFZlbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgQ29udGFjdEVxdWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbnRhY3RFcXVhdGlvbiwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogTm9uLXBlbmV0cmF0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb24uIFRyaWVzIHRvIG1ha2UgdGhlIGNvbnRhY3RQb2ludEEgYW5kIGNvbnRhY3RQb2ludEIgdmVjdG9ycyBjb2luY2lkZSwgd2hpbGUga2VlcGluZyB0aGUgYXBwbGllZCBmb3JjZSByZXB1bHNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIENvbnRhY3RFcXVhdGlvblxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAwLCBJbmZpbml0eSkgfHwgdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWZWN0b3IgZnJvbSBib2R5IGkgY2VudGVyIG9mIG1hc3MgdG8gdGhlIGNvbnRhY3QgcG9pbnQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEFcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuY29udGFjdFBvaW50QSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIF90aGlzLnBlbmV0cmF0aW9uVmVjID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV29ybGQtb3JpZW50ZWQgdmVjdG9yIGZyb20gYm9keSBBIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBjb250YWN0IHBvaW50LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRCXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNvbnRhY3RQb2ludEIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbm9ybWFsIHZlY3RvciwgcG9pbnRpbmcgb3V0IG9mIGJvZHkgaVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBub3JtYWxBXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLm5vcm1hbEEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVzdGl0dXRpb24gdG8gdXNlICgwPW5vIGJvdW5jaW5lc3MsIDE9bWF4IGJvdW5jaW5lc3MpLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSByZXN0aXR1dGlvblxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMucmVzdGl0dXRpb24gPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIHRydWUgaWYgdGhpcyBpcyB0aGUgZmlyc3QgaW1wYWN0IGJldHdlZW4gdGhlIGJvZGllcyAobm90IHBlcnNpc3RhbnQgY29udGFjdCkuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGZpcnN0SW1wYWN0XHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRPbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZmlyc3RJbXBhY3QgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY29udGFjdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgc2hhcGVBXHJcbiAgICAgICAgICogQHR5cGUge1NoYXBlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNoYXBlQSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNoYXBlIGluIGJvZHkgaiB0aGF0IHRyaWdnZXJlZCB0aGlzIGNvbnRhY3QuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNoYXBlQlxyXG4gICAgICAgICAqIEB0eXBlIHtTaGFwZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5zaGFwZUIgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIENvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbiAoYSwgYiwgaCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdmFyIGJpID0gdGhpcy5ib2R5QSwgYmogPSB0aGlzLmJvZHlCLCByaSA9IHRoaXMuY29udGFjdFBvaW50QSwgcmogPSB0aGlzLmNvbnRhY3RQb2ludEIsIHhpID0gKF9hID0gYmkgPT09IG51bGwgfHwgYmkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJpLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgRmxvYXQzMkFycmF5KDIpLCB4aiA9IChfYiA9IGJqID09PSBudWxsIHx8IGJqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiai5wb3NpdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuICAgICAgICB2YXIgbiA9IHRoaXMubm9ybWFsQSwgRyA9IHRoaXMuRztcclxuICAgICAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcclxuICAgICAgICB2YXIgcml4biA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHJpLCBuKSwgcmp4biA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHJqLCBuKTtcclxuICAgICAgICAvLyBHID0gWy1uIC1yaXhuIG4gcmp4bl1cclxuICAgICAgICBHWzBdID0gLW5bMF07XHJcbiAgICAgICAgR1sxXSA9IC1uWzFdO1xyXG4gICAgICAgIEdbMl0gPSAtcml4bjtcclxuICAgICAgICBHWzNdID0gblswXTtcclxuICAgICAgICBHWzRdID0gblsxXTtcclxuICAgICAgICBHWzVdID0gcmp4bjtcclxuICAgICAgICAvLyBDb21wdXRlIGl0ZXJhdGlvblxyXG4gICAgICAgIHZhciBHVywgR3E7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RJbXBhY3QgJiYgdGhpcy5yZXN0aXR1dGlvbiAhPT0gMCkge1xyXG4gICAgICAgICAgICBHcSA9IDA7XHJcbiAgICAgICAgICAgIEdXID0gKDEgLyBiKSAqICgxICsgdGhpcy5yZXN0aXR1dGlvbikgKiB0aGlzLmNvbXB1dGVHVygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHEgPSB4aityaiAtKHhpK3JpKSBpLmUuIHRoZSBwZW5ldHJhdGlvbiB2ZWN0b3JcclxuICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uVmVjID0gdGhpcy5wZW5ldHJhdGlvblZlYztcclxuICAgICAgICAgICAgYWRkU3ViU3ViKHBlbmV0cmF0aW9uVmVjLCB4aiwgcmosIHhpLCByaSk7XHJcbiAgICAgICAgICAgIEdxID0gdmVjMl8xLmRlZmF1bHQuZG90KG4sIHBlbmV0cmF0aW9uVmVjKSArIHRoaXMub2Zmc2V0O1xyXG4gICAgICAgICAgICBHVyA9IHRoaXMuY29tcHV0ZUdXKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xyXG4gICAgICAgIHZhciBCID0gLUdxICogYSAtIEdXICogYiAtIGggKiBHaU1mO1xyXG4gICAgICAgIHJldHVybiBCO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSByZWxhdGl2ZSB2ZWxvY2l0eSBhbG9uZyB0aGUgbm9ybWFsIHZlY3Rvci5cclxuICAgICAqIEBtZXRob2QgZ2V0VmVsb2NpdHlBbG9uZ05vcm1hbFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBDb250YWN0RXF1YXRpb24ucHJvdG90eXBlLmdldFZlbG9jaXR5QWxvbmdOb3JtYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ib2R5QSAmJiB0aGlzLmJvZHlBLmdldFZlbG9jaXR5QXRQb2ludCh2aSwgdGhpcy5jb250YWN0UG9pbnRBKTtcclxuICAgICAgICB0aGlzLmJvZHlCICYmIHRoaXMuYm9keUIuZ2V0VmVsb2NpdHlBdFBvaW50KHZqLCB0aGlzLmNvbnRhY3RQb2ludEIpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHJlbFZlbCwgdmksIHZqKTtcclxuICAgICAgICByZXR1cm4gdmVjMl8xLmRlZmF1bHQuZG90KHRoaXMubm9ybWFsQSwgcmVsVmVsKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gQ29udGFjdEVxdWF0aW9uO1xyXG59KEVxdWF0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb250YWN0RXF1YXRpb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0VxdWF0aW9uXCIpKTtcclxudmFyIEZyaWN0aW9uRXF1YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRnJpY3Rpb25FcXVhdGlvbiwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RyYWlucyB0aGUgc2xpcHBpbmcgaW4gYSBjb250YWN0IGFsb25nIGEgdGFuZ2VudFxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBGcmljdGlvbkVxdWF0aW9uXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzbGlwRm9yY2VcclxuICAgICAqIEBleHRlbmRzIEVxdWF0aW9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEZyaWN0aW9uRXF1YXRpb24oYm9keUEsIGJvZHlCLCBzbGlwRm9yY2UpIHtcclxuICAgICAgICBpZiAoc2xpcEZvcmNlID09PSB2b2lkIDApIHsgc2xpcEZvcmNlID0gSW5maW5pdHk7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1zbGlwRm9yY2UsIHNsaXBGb3JjZSkgfHwgdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWxhdGl2ZSB2ZWN0b3IgZnJvbSBjZW50ZXIgb2YgYm9keSBBIHRvIHRoZSBjb250YWN0IHBvaW50LCB3b3JsZCBvcmllbnRlZC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QVxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5jb250YWN0UG9pbnRBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVsYXRpdmUgdmVjdG9yIGZyb20gY2VudGVyIG9mIGJvZHkgQiB0byB0aGUgY29udGFjdCBwb2ludCwgd29ybGQgb3JpZW50ZWQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEJcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuY29udGFjdFBvaW50QiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRhbmdlbnQgdmVjdG9yIHRoYXQgdGhlIGZyaWN0aW9uIGZvcmNlIHdpbGwgYWN0IGFsb25nLiBXb3JsZCBvcmllbnRlZC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgdFxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy50ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udGFjdEVxdWF0aW9ucyBjb25uZWN0ZWQgdG8gdGhpcyBmcmljdGlvbiBlcXVhdGlvbi4gVGhlIGNvbnRhY3QgZXF1YXRpb25zIGNhbiBiZSB1c2VkIHRvIHJlc2NhbGUgdGhlIG1heCBmb3JjZSBmb3IgdGhlIGZyaWN0aW9uLiBJZiBtb3JlIHRoYW4gb25lIGNvbnRhY3QgZXF1YXRpb24gaXMgZ2l2ZW4sIHRoZW4gdGhlIG1heCBmb3JjZSBjYW4gYmUgc2V0IHRvIHRoZSBhdmVyYWdlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb250YWN0RXF1YXRpb25zXHJcbiAgICAgICAgICogQHR5cGUge0NvbnRhY3RFcXVhdGlvbltdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNvbnRhY3RFcXVhdGlvbnMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnJpY3Rpb24uXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNoYXBlQVxyXG4gICAgICAgICAqIEB0eXBlIHtTaGFwZX1cclxuICAgICAgICAgKiBAdG9kbyBOZWVkZWQ/IFRoZSBzaGFwZSBjYW4gYmUgbG9va2VkIHVwIHZpYSBjb250YWN0RXF1YXRpb24uc2hhcGVBLi4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuc2hhcGVBID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBqIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnJpY3Rpb24uXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNoYXBlQlxyXG4gICAgICAgICAqIEB0eXBlIHtTaGFwZX1cclxuICAgICAgICAgKiBAdG9kbyBOZWVkZWQ/IFRoZSBzaGFwZSBjYW4gYmUgbG9va2VkIHVwIHZpYSBjb250YWN0RXF1YXRpb24uc2hhcGVCLi4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuc2hhcGVCID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnJpY3Rpb24gY29lZmZpY2llbnQgdG8gdXNlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkNvZWZmaWNpZW50XHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5mcmljdGlvbkNvZWZmaWNpZW50ID0gMC4zO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBzbGlwcGluZyBjb25kaXRpb24gZm9yIHRoZSBjb25zdHJhaW50LiBUaGUgZnJpY3Rpb24gZm9yY2UgY2Fubm90IGJlXHJcbiAgICAgKiBsYXJnZXIgdGhhbiB0aGlzIHZhbHVlLlxyXG4gICAgICogQG1ldGhvZCBzZXRTbGlwRm9yY2VcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2xpcEZvcmNlXHJcbiAgICAgKi9cclxuICAgIEZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLnNldFNsaXBGb3JjZSA9IGZ1bmN0aW9uIChzbGlwRm9yY2UpIHtcclxuICAgICAgICB0aGlzLm1heEZvcmNlID0gc2xpcEZvcmNlO1xyXG4gICAgICAgIHRoaXMubWluRm9yY2UgPSAtc2xpcEZvcmNlO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtYXggZm9yY2UgZm9yIHRoZSBjb25zdHJhaW50LlxyXG4gICAgICogQG1ldGhvZCBnZXRTbGlwRm9yY2VcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuZ2V0U2xpcEZvcmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1heEZvcmNlO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIEZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24gKGEsIGIsIGgpIHtcclxuICAgICAgICB2YXIgcmkgPSB0aGlzLmNvbnRhY3RQb2ludEEsIHJqID0gdGhpcy5jb250YWN0UG9pbnRCLCB0ID0gdGhpcy50LCBHID0gdGhpcy5HO1xyXG4gICAgICAgIC8vIEcgPSBbLXQgLXJpeHQgdCByanh0XVxyXG4gICAgICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyFcclxuICAgICAgICBHWzBdID0gLXRbMF07XHJcbiAgICAgICAgR1sxXSA9IC10WzFdO1xyXG4gICAgICAgIEdbMl0gPSAtdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmksIHQpO1xyXG4gICAgICAgIEdbM10gPSB0WzBdO1xyXG4gICAgICAgIEdbNF0gPSB0WzFdO1xyXG4gICAgICAgIEdbNV0gPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyaiwgdCk7XHJcbiAgICAgICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKSwgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcclxuICAgICAgICB2YXIgQiA9IC8qIC0gZyAqIGEgICovIC1HVyAqIGIgLSBoICogR2lNZjtcclxuICAgICAgICByZXR1cm4gQjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gRnJpY3Rpb25FcXVhdGlvbjtcclxufShFcXVhdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRnJpY3Rpb25FcXVhdGlvbjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEVxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vRXF1YXRpb25cIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgd29ybGRWZWN0b3JBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHdvcmxkVmVjdG9yQiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB4QXhpcyA9IHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoMSwgMCksIHlBeGlzID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygwLCAxKTtcclxudmFyIFJvdGF0aW9uYWxMb2NrRXF1YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUm90YXRpb25hbExvY2tFcXVhdGlvbiwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogTG9ja3MgdGhlIHJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdHdvIGJvZGllcy4gVGhlIGNvbnN0cmFpbnQgdHJpZXMgdG8ga2VlcCB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0d28gdmVjdG9ycywgbG9jYWwgaW4gZWFjaCBib2R5LCB0byB6ZXJvLiBUaGUgbG9jYWwgYW5nbGUgaW4gYm9keSBpIGlzIGEgcGFyYW1ldGVyLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIEVxdWF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5nbGVdIEFuZ2xlIHRvIGFkZCB0byB0aGUgbG9jYWwgdmVjdG9yIGluIGJvZHlBLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1JbmZpbml0eSwgSW5maW5pdHkpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuYW5nbGUgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYW5nbGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XHJcbiAgICAgICAgdmFyIEcgPSBfdGhpcy5HO1xyXG4gICAgICAgIEdbMl0gPSAxO1xyXG4gICAgICAgIEdbNV0gPSAtMTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR3EgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHdvcmxkVmVjdG9yQSwgeEF4aXMsIHRoaXMuYm9keUEuYW5nbGUgKyB0aGlzLmFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUod29ybGRWZWN0b3JCLCB5QXhpcywgdGhpcy5ib2R5Qi5hbmdsZSk7XHJcbiAgICAgICAgcmV0dXJuIHZlYzJfMS5kZWZhdWx0LmRvdCh3b3JsZFZlY3RvckEsIHdvcmxkVmVjdG9yQik7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIFJvdGF0aW9uYWxMb2NrRXF1YXRpb247XHJcbn0oRXF1YXRpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJvdGF0aW9uYWxMb2NrRXF1YXRpb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0VxdWF0aW9uXCIpKTtcclxudmFyIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTeW5jcyByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHR3byBib2RpZXMsIG9yIHNldHMgYSByZWxhdGl2ZSB2ZWxvY2l0eSAobW90b3IpLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvblxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbihib2R5QSwgYm9keUIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1JbmZpbml0eSwgSW5maW5pdHkpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMucmVsYXRpdmVWZWxvY2l0eSA9IDE7XHJcbiAgICAgICAgX3RoaXMucmF0aW8gPSAxO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uIChhLCBiLCBoKSB7XHJcbiAgICAgICAgdmFyIEcgPSB0aGlzLkc7XHJcbiAgICAgICAgR1syXSA9IC0xO1xyXG4gICAgICAgIEdbNV0gPSB0aGlzLnJhdGlvO1xyXG4gICAgICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xyXG4gICAgICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCk7XHJcbiAgICAgICAgdmFyIEIgPSAtR1cgKiBiIC0gaCAqIEdpTWY7XHJcbiAgICAgICAgcmV0dXJuIEI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uO1xyXG59KEVxdWF0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIG9iamVjdHMgdGhhdCBkaXNwYXRjaGVzIGV2ZW50cy5cclxuICogQGNsYXNzIEV2ZW50RW1pdHRlclxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgdmFyIGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAqICAgICBlbWl0dGVyLm9uKCdteUV2ZW50JywgZnVuY3Rpb24oZXZ0KXtcclxuICogICAgICAgICBjb25zb2xlLmxvZyhldnQubWVzc2FnZSk7XHJcbiAqICAgICB9KTtcclxuICogICAgIGVtaXR0ZXIuZW1pdCh7XHJcbiAqICAgICAgICAgdHlwZTogJ215RXZlbnQnLFxyXG4gKiAgICAgICAgIG1lc3NhZ2U6ICdIZWxsbyB3b3JsZCEnXHJcbiAqICAgICB9KTtcclxuICovXHJcbnZhciBFdmVudEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5fY29udGV4dHMgPSB7fTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgKiBAbWV0aG9kIG9uXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gICAgICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIGVtaXR0ZXIub24oJ215RXZlbnQnLCBmdW5jdGlvbihldnQpe1xyXG4gICAgICogICAgICAgICBjb25zb2xlLmxvZygnbXlFdnQgd2FzIHRyaWdnZXJlZCEnKTtcclxuICAgICAqICAgICB9KTtcclxuICAgICAqL1xyXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lciwgY29udGV4dCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dHNbdHlwZV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0c1t0eXBlXS5wdXNoKGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lclxyXG4gICAgICogQG1ldGhvZCBvZmZcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxyXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXHJcbiAgICAgKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgZW1pdHRlci5vbignbXlFdmVudCcsIGhhbmRsZXIpOyAvLyBBZGQgaGFuZGxlclxyXG4gICAgICogICAgIGVtaXR0ZXIub2ZmKCdteUV2ZW50JywgaGFuZGxlcik7IC8vIFJlbW92ZSBoYW5kbGVyXHJcbiAgICAgKi9cclxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMgfHwgIXRoaXMuX2xpc3RlbmVyc1t0eXBlXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHRzW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYW4gZXZlbnQgbGlzdGVuZXIgaXMgYWRkZWRcclxuICAgICAqIEBtZXRob2QgaGFzXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW3R5cGVdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRW1pdCBhbiBldmVudC5cclxuICAgICAqIEBtZXRob2QgZW1pdFxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBldmVudFxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBldmVudC50eXBlXHJcbiAgICAgKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgZW1pdHRlci5lbWl0KHtcclxuICAgICAqICAgICAgICAgdHlwZTogJ215RXZlbnQnLFxyXG4gICAgICogICAgICAgICBjdXN0b21EYXRhOiAxMjNcclxuICAgICAqICAgICB9KTtcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogdGhlIHVua25vd24gdHlwZSBoZXJlIGlzIGRpc3R1cmJpbmcuXHJcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsaXN0ZW5lckFycmF5ID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50LnR5cGVdO1xyXG4gICAgICAgIHZhciBjb250ZXh0QXJyYXkgPSB0aGlzLl9jb250ZXh0c1tldmVudC50eXBlXTtcclxuICAgICAgICBpZiAobGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY29weSB0aGUgbGlzdGVuZXIgYXJyYXksIGluIGNhc2Ugc29tZSBsaXN0ZW5lciB3YXMgYWRkZWQvcmVtb3ZlZCBpbnNpZGUgYSBsaXN0ZW5lclxyXG4gICAgICAgICAgICB2YXIgdG1wTGlzdGVuZXJBcnJheSA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgdG1wQ29udGV4dEFycmF5ID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRtcExpc3RlbmVyQXJyYXkucHVzaChsaXN0ZW5lckFycmF5W2ldKTtcclxuICAgICAgICAgICAgICAgIHRtcENvbnRleHRBcnJheS5wdXNoKGNvbnRleHRBcnJheVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dEFycmF5W2ldO1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChjb250ZXh0LCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRFbWl0dGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnZlcnNpb24gPSBleHBvcnRzLnZlYzIgPSBleHBvcnRzLldvcmxkID0gZXhwb3J0cy5VdGlscyA9IGV4cG9ydHMuUm90YXRpb25hbFNwcmluZyA9IGV4cG9ydHMuTGluZWFyU3ByaW5nID0gZXhwb3J0cy5Ub3BEb3duVmVoaWNsZSA9IGV4cG9ydHMuU3ByaW5nID0gZXhwb3J0cy5Tb2x2ZXIgPSBleHBvcnRzLlNoYXBlID0gZXhwb3J0cy5TQVBCcm9hZHBoYXNlID0gZXhwb3J0cy5Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiA9IGV4cG9ydHMuQm94ID0gZXhwb3J0cy5SYXljYXN0UmVzdWx0ID0gZXhwb3J0cy5SYXkgPSBleHBvcnRzLlByaXNtYXRpY0NvbnN0cmFpbnQgPSBleHBvcnRzLlJldm9sdXRlQ29uc3RyYWludCA9IGV4cG9ydHMuUG9vbCA9IGV4cG9ydHMuUGxhbmUgPSBleHBvcnRzLlBhcnRpY2xlID0gZXhwb3J0cy5OYWl2ZUJyb2FkcGhhc2UgPSBleHBvcnRzLk5hcnJvd3BoYXNlID0gZXhwb3J0cy5NYXRlcmlhbCA9IGV4cG9ydHMuTG9ja0NvbnN0cmFpbnQgPSBleHBvcnRzLkxpbmUgPSBleHBvcnRzLkhlaWdodGZpZWxkID0gZXhwb3J0cy5HU1NvbHZlciA9IGV4cG9ydHMuR2VhckNvbnN0cmFpbnQgPSBleHBvcnRzLkZyaWN0aW9uRXF1YXRpb25Qb29sID0gZXhwb3J0cy5GcmljdGlvbkVxdWF0aW9uID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBleHBvcnRzLkVxdWF0aW9uID0gZXhwb3J0cy5EaXN0YW5jZUNvbnN0cmFpbnQgPSBleHBvcnRzLkNvbnZleCA9IGV4cG9ydHMuQ29udGFjdE1hdGVyaWFsID0gZXhwb3J0cy5Db250YWN0RXF1YXRpb25Qb29sID0gZXhwb3J0cy5Db250YWN0RXF1YXRpb24gPSBleHBvcnRzLkNvbnN0cmFpbnQgPSBleHBvcnRzLkNpcmNsZSA9IGV4cG9ydHMuQ2Fwc3VsZSA9IGV4cG9ydHMuQnJvYWRwaGFzZSA9IGV4cG9ydHMuQm9keSA9IGV4cG9ydHMuQW5nbGVMb2NrRXF1YXRpb24gPSBleHBvcnRzLkFBQkIgPSB2b2lkIDA7XHJcbnZhciBhYWJiXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29sbGlzaW9uL2FhYmJcIikpO1xyXG5leHBvcnRzLkFBQkIgPSBhYWJiXzEuZGVmYXVsdDtcclxudmFyIGFuZ2xlX2xvY2tfZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9lcXVhdGlvbnMvYW5nbGUtbG9jay1lcXVhdGlvblwiKSk7XHJcbmV4cG9ydHMuQW5nbGVMb2NrRXF1YXRpb24gPSBhbmdsZV9sb2NrX2VxdWF0aW9uXzEuZGVmYXVsdDtcclxudmFyIGJvZHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9vYmplY3RzL2JvZHlcIikpO1xyXG5leHBvcnRzLkJvZHkgPSBib2R5XzEuZGVmYXVsdDtcclxudmFyIGJyb2FkcGhhc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb2xsaXNpb24vYnJvYWRwaGFzZVwiKSk7XHJcbmV4cG9ydHMuQnJvYWRwaGFzZSA9IGJyb2FkcGhhc2VfMS5kZWZhdWx0O1xyXG52YXIgY2Fwc3VsZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlcy9jYXBzdWxlXCIpKTtcclxuZXhwb3J0cy5DYXBzdWxlID0gY2Fwc3VsZV8xLmRlZmF1bHQ7XHJcbnZhciBjaXJjbGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZXMvY2lyY2xlXCIpKTtcclxuZXhwb3J0cy5DaXJjbGUgPSBjaXJjbGVfMS5kZWZhdWx0O1xyXG52YXIgY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRzL2NvbnN0cmFpbnRcIikpO1xyXG5leHBvcnRzLkNvbnN0cmFpbnQgPSBjb25zdHJhaW50XzEuZGVmYXVsdDtcclxudmFyIGNvbnRhY3RfZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9lcXVhdGlvbnMvY29udGFjdC1lcXVhdGlvblwiKSk7XHJcbmV4cG9ydHMuQ29udGFjdEVxdWF0aW9uID0gY29udGFjdF9lcXVhdGlvbl8xLmRlZmF1bHQ7XHJcbnZhciBjb250YWN0X2VxdWF0aW9uX3Bvb2xfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9jb250YWN0LWVxdWF0aW9uLXBvb2xcIikpO1xyXG5leHBvcnRzLkNvbnRhY3RFcXVhdGlvblBvb2wgPSBjb250YWN0X2VxdWF0aW9uX3Bvb2xfMS5kZWZhdWx0O1xyXG52YXIgY29udGFjdF9tYXRlcmlhbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21hdGVyaWFsL2NvbnRhY3QtbWF0ZXJpYWxcIikpO1xyXG5leHBvcnRzLkNvbnRhY3RNYXRlcmlhbCA9IGNvbnRhY3RfbWF0ZXJpYWxfMS5kZWZhdWx0O1xyXG52YXIgY29udmV4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcGVzL2NvbnZleFwiKSk7XHJcbmV4cG9ydHMuQ29udmV4ID0gY29udmV4XzEuZGVmYXVsdDtcclxudmFyIGRpc3RhbmNlX2NvbnN0cmFpbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb25zdHJhaW50cy9kaXN0YW5jZS1jb25zdHJhaW50XCIpKTtcclxuZXhwb3J0cy5EaXN0YW5jZUNvbnN0cmFpbnQgPSBkaXN0YW5jZV9jb25zdHJhaW50XzEuZGVmYXVsdDtcclxudmFyIGVxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZXF1YXRpb25zL2VxdWF0aW9uXCIpKTtcclxuZXhwb3J0cy5FcXVhdGlvbiA9IGVxdWF0aW9uXzEuZGVmYXVsdDtcclxudmFyIGV2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9ldmVudHMvZXZlbnQtZW1pdHRlclwiKSk7XHJcbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQ7XHJcbnZhciBmcmljdGlvbl9lcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2VxdWF0aW9ucy9mcmljdGlvbi1lcXVhdGlvblwiKSk7XHJcbmV4cG9ydHMuRnJpY3Rpb25FcXVhdGlvbiA9IGZyaWN0aW9uX2VxdWF0aW9uXzEuZGVmYXVsdDtcclxudmFyIGZyaWN0aW9uX2VxdWF0aW9uX3Bvb2xfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9mcmljdGlvbi1lcXVhdGlvbi1wb29sXCIpKTtcclxuZXhwb3J0cy5GcmljdGlvbkVxdWF0aW9uUG9vbCA9IGZyaWN0aW9uX2VxdWF0aW9uX3Bvb2xfMS5kZWZhdWx0O1xyXG52YXIgZ2Vhcl9jb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uc3RyYWludHMvZ2Vhci1jb25zdHJhaW50XCIpKTtcclxuZXhwb3J0cy5HZWFyQ29uc3RyYWludCA9IGdlYXJfY29uc3RyYWludF8xLmRlZmF1bHQ7XHJcbnZhciBnc19zb2x2ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zb2x2ZXIvZ3Mtc29sdmVyXCIpKTtcclxuZXhwb3J0cy5HU1NvbHZlciA9IGdzX3NvbHZlcl8xLmRlZmF1bHQ7XHJcbnZhciBoZWlnaHRmaWVsZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlcy9oZWlnaHRmaWVsZFwiKSk7XHJcbmV4cG9ydHMuSGVpZ2h0ZmllbGQgPSBoZWlnaHRmaWVsZF8xLmRlZmF1bHQ7XHJcbnZhciBsaW5lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcGVzL2xpbmVcIikpO1xyXG5leHBvcnRzLkxpbmUgPSBsaW5lXzEuZGVmYXVsdDtcclxudmFyIGxvY2tfY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRzL2xvY2stY29uc3RyYWludFwiKSk7XHJcbmV4cG9ydHMuTG9ja0NvbnN0cmFpbnQgPSBsb2NrX2NvbnN0cmFpbnRfMS5kZWZhdWx0O1xyXG52YXIgbWF0ZXJpYWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXRlcmlhbC9tYXRlcmlhbFwiKSk7XHJcbmV4cG9ydHMuTWF0ZXJpYWwgPSBtYXRlcmlhbF8xLmRlZmF1bHQ7XHJcbnZhciBuYXJyb3dwaGFzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbGxpc2lvbi9uYXJyb3dwaGFzZVwiKSk7XHJcbmV4cG9ydHMuTmFycm93cGhhc2UgPSBuYXJyb3dwaGFzZV8xLmRlZmF1bHQ7XHJcbnZhciBuYWl2ZV9icm9hZHBoYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29sbGlzaW9uL25haXZlLWJyb2FkcGhhc2VcIikpO1xyXG5leHBvcnRzLk5haXZlQnJvYWRwaGFzZSA9IG5haXZlX2Jyb2FkcGhhc2VfMS5kZWZhdWx0O1xyXG52YXIgcGFydGljbGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZXMvcGFydGljbGVcIikpO1xyXG5leHBvcnRzLlBhcnRpY2xlID0gcGFydGljbGVfMS5kZWZhdWx0O1xyXG52YXIgcGxhbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZXMvcGxhbmVcIikpO1xyXG5leHBvcnRzLlBsYW5lID0gcGxhbmVfMS5kZWZhdWx0O1xyXG52YXIgcG9vbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL3Bvb2xcIikpO1xyXG5leHBvcnRzLlBvb2wgPSBwb29sXzEuZGVmYXVsdDtcclxudmFyIHJldm9sdXRlX2NvbnN0cmFpbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb25zdHJhaW50cy9yZXZvbHV0ZS1jb25zdHJhaW50XCIpKTtcclxuZXhwb3J0cy5SZXZvbHV0ZUNvbnN0cmFpbnQgPSByZXZvbHV0ZV9jb25zdHJhaW50XzEuZGVmYXVsdDtcclxudmFyIHByaXNtYXRpY19jb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uc3RyYWludHMvcHJpc21hdGljLWNvbnN0cmFpbnRcIikpO1xyXG5leHBvcnRzLlByaXNtYXRpY0NvbnN0cmFpbnQgPSBwcmlzbWF0aWNfY29uc3RyYWludF8xLmRlZmF1bHQ7XHJcbnZhciByYXlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb2xsaXNpb24vcmF5XCIpKTtcclxuZXhwb3J0cy5SYXkgPSByYXlfMS5kZWZhdWx0O1xyXG52YXIgcmF5Y2FzdF9yZXN1bHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb2xsaXNpb24vcmF5Y2FzdC1yZXN1bHRcIikpO1xyXG5leHBvcnRzLlJheWNhc3RSZXN1bHQgPSByYXljYXN0X3Jlc3VsdF8xLmRlZmF1bHQ7XHJcbnZhciBCb3hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZXMvQm94XCIpKTtcclxuZXhwb3J0cy5Cb3ggPSBCb3hfMS5kZWZhdWx0O1xyXG52YXIgcm90YXRpb25hbF92ZWxvY2l0eV9lcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2VxdWF0aW9ucy9yb3RhdGlvbmFsLXZlbG9jaXR5LWVxdWF0aW9uXCIpKTtcclxuZXhwb3J0cy5Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiA9IHJvdGF0aW9uYWxfdmVsb2NpdHlfZXF1YXRpb25fMS5kZWZhdWx0O1xyXG52YXIgc2FwX2Jyb2FkcGhhc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb2xsaXNpb24vc2FwLWJyb2FkcGhhc2VcIikpO1xyXG5leHBvcnRzLlNBUEJyb2FkcGhhc2UgPSBzYXBfYnJvYWRwaGFzZV8xLmRlZmF1bHQ7XHJcbnZhciBzaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlcy9zaGFwZVwiKSk7XHJcbmV4cG9ydHMuU2hhcGUgPSBzaGFwZV8xLmRlZmF1bHQ7XHJcbnZhciBzb2x2ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zb2x2ZXIvc29sdmVyXCIpKTtcclxuZXhwb3J0cy5Tb2x2ZXIgPSBzb2x2ZXJfMS5kZWZhdWx0O1xyXG52YXIgc3ByaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb2JqZWN0cy9zcHJpbmdcIikpO1xyXG5leHBvcnRzLlNwcmluZyA9IHNwcmluZ18xLmRlZmF1bHQ7XHJcbnZhciB0b3BfZG93bl92ZWhpY2xlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb2JqZWN0cy90b3AtZG93bi12ZWhpY2xlXCIpKTtcclxuZXhwb3J0cy5Ub3BEb3duVmVoaWNsZSA9IHRvcF9kb3duX3ZlaGljbGVfMS5kZWZhdWx0O1xyXG52YXIgbGluZWFyX3NwcmluZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL29iamVjdHMvbGluZWFyLXNwcmluZ1wiKSk7XHJcbmV4cG9ydHMuTGluZWFyU3ByaW5nID0gbGluZWFyX3NwcmluZ18xLmRlZmF1bHQ7XHJcbnZhciByb3RhdGlvbmFsX3NwcmluZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL29iamVjdHMvcm90YXRpb25hbC1zcHJpbmdcIikpO1xyXG5leHBvcnRzLlJvdGF0aW9uYWxTcHJpbmcgPSByb3RhdGlvbmFsX3NwcmluZ18xLmRlZmF1bHQ7XHJcbnZhciB1dGlsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL3V0aWxzXCIpKTtcclxuZXhwb3J0cy5VdGlscyA9IHV0aWxzXzEuZGVmYXVsdDtcclxudmFyIHdvcmxkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vd29ybGQvd29ybGRcIikpO1xyXG5leHBvcnRzLldvcmxkID0gd29ybGRfMS5kZWZhdWx0O1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21hdGgvdmVjMlwiKSk7XHJcbmV4cG9ydHMudmVjMiA9IHZlYzJfMS5kZWZhdWx0O1xyXG52YXIgdmVyc2lvbiA9IFwiMC4wLjFcIjtcclxuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIE1hdGVyaWFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGEgcGh5c2ljcyBtYXRlcmlhbC4gVG8gYmUgdXNlZCB3aXRoIHt7I2Nyb3NzTGluayBcIkNvbnRhY3RNYXRlcmlhbFwifX17ey9jcm9zc0xpbmt9fS5cclxuICAgICAqIEBjbGFzcyBNYXRlcmlhbFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIC8vIENyZWF0ZSBhIHdvb2RlbiBib3hcclxuICAgICAqICAgICB2YXIgd29vZE1hdGVyaWFsID0gbmV3IE1hdGVyaWFsKCk7XHJcbiAgICAgKiAgICAgdmFyIGJveFNoYXBlID0gbmV3IEJveCh7XHJcbiAgICAgKiAgICAgICAgIG1hdGVyaWFsOiB3b29kTWF0ZXJpYWxcclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICBib2R5LmFkZFNoYXBlKGJveFNoYXBlKTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTWF0ZXJpYWwoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1hdGVyaWFsIGlkZW50aWZpZXIuIFJlYWQgb25seS5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgaWRcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaWQgPSArK01hdGVyaWFsLmlkQ291bnRlcjtcclxuICAgIH1cclxuICAgIE1hdGVyaWFsLmlkQ291bnRlciA9IDA7XHJcbiAgICByZXR1cm4gTWF0ZXJpYWw7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1hdGVyaWFsO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgTWF0ZXJpYWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9NYXRlcmlhbFwiKSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIikpO1xyXG52YXIgQ29udGFjdE1hdGVyaWFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldCwgc3VjaCBhcyB3aGF0IGZyaWN0aW9uIGNvZWZmaWNpZW50IHRvIHVzZS4gWW91IGNhbiBhbHNvIHNldCBvdGhlciB0aGluZ3Mgc3VjaCBhcyByZXN0aXR1dGlvbiwgc3VyZmFjZSB2ZWxvY2l0eSBhbmQgY29uc3RyYWludCBwYXJhbWV0ZXJzLiBBbHNvIHNlZSB7eyNjcm9zc0xpbmsgXCJNYXRlcmlhbFwifX17ey9jcm9zc0xpbmt9fS5cclxuICAgICAqIEBjbGFzcyBDb250YWN0TWF0ZXJpYWxcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxBXHJcbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuZnJpY3Rpb249MC4zXSAgICAgICBGcmljdGlvbiBjb2VmZmljaWVudC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbl0gRnJpY3Rpb25FcXVhdGlvbiByZWxheGF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuZnJpY3Rpb25TdGlmZm5lc3NdICBGcmljdGlvbkVxdWF0aW9uIHN0aWZmbmVzcy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnJlbGF4YXRpb25dICAgICAgICAgQ29udGFjdEVxdWF0aW9uIHJlbGF4YXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5yZXN0aXR1dGlvbj0wXSAgICAgIFJlc3RpdHV0aW9uIGNvZWZmaWNpZW50IGFrYSBcImJvdW5jaW5lc3NcIi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnN0aWZmbmVzc10gICAgICAgICAgQ29udGFjdEVxdWF0aW9uIHN0aWZmbmVzcy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnN1cmZhY2VWZWxvY2l0eT0wXSAgU3VyZmFjZSB2ZWxvY2l0eS5cclxuICAgICAqIEBhdXRob3Igc2NodGVwcGVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGljZSA9IG5ldyBNYXRlcmlhbCgpO1xyXG4gICAgICogICAgIHZhciB3b29kID0gbmV3IE1hdGVyaWFsKCk7XHJcbiAgICAgKiAgICAgdmFyIGljZVdvb2RDb250YWN0TWF0ZXJpYWwgPSBuZXcgQ29udGFjdE1hdGVyaWFsKGljZSwgd29vZCwge1xyXG4gICAgICogICAgICAgICBmcmljdGlvbjogMC4yLFxyXG4gICAgICogICAgICAgICByZXN0aXR1dGlvbjogMC4zXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQ29udGFjdE1hdGVyaWFsKGljZVdvb2RDb250YWN0TWF0ZXJpYWwpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb250YWN0TWF0ZXJpYWwobWF0ZXJpYWxBLCBtYXRlcmlhbEIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRnJpY3Rpb24gY29lZmZpY2llbnQgdG8gdXNlIGluIHRoZSBjb250YWN0IG9mIHRoZXNlIHR3byBtYXRlcmlhbHMuIEZyaWN0aW9uID0gMCB3aWxsIG1ha2UgdGhlIGludm9sdmVkIG9iamVjdHMgc3VwZXIgc2xpcHBlcnksIGFuZCBmcmljdGlvbiA9IDEgd2lsbCBtYWtlIGl0IG11Y2ggbGVzcyBzbGlwcGVyeS4gQSBmcmljdGlvbiBjb2VmZmljaWVudCBsYXJnZXIgdGhhbiAxIHdpbGwgYWxsb3cgZm9yIHZlcnkgbGFyZ2UgZnJpY3Rpb24gZm9yY2VzLCB3aGljaCBjYW4gYmUgY29udmVuaWVudCBmb3IgcHJldmVudGluZyBjYXIgdGlyZXMgbm90IHNsaXAgb24gdGhlIGdyb3VuZC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25cclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuM1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb24gPSAwLjM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzdGl0dXRpb24sIG9yIFwiYm91bmNpbmVzc1wiIHRvIHVzZSBpbiB0aGUgY29udGFjdCBvZiB0aGVzZSB0d28gbWF0ZXJpYWxzLiBBIHJlc3RpdHV0aW9uIG9mIDAgd2lsbCBtYWtlIG5vIGJvdW5jZSwgd2hpbGUgcmVzdGl0dXRpb249MSB3aWxsIGFwcHJveGltYXRlbHkgYm91bmNlIGJhY2sgd2l0aCB0aGUgc2FtZSB2ZWxvY2l0eSB0aGUgb2JqZWN0IGNhbWUgd2l0aC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlc3RpdHV0aW9uID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYXJkbmVzcyBvZiB0aGUgY29udGFjdC4gTGVzcyBzdGlmZm5lc3Mgd2lsbCBtYWtlIHRoZSBvYmplY3RzIHBlbmV0cmF0ZSBtb3JlLCBhbmQgd2lsbCBtYWtlIHRoZSBjb250YWN0IGFjdCBtb3JlIGxpa2UgYSBzcHJpbmcgdGhhbiBhIGNvbnRhY3QgZm9yY2UuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9TVElGRk5FU1M6cHJvcGVydHlcIn19RXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1N7ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0aWZmbmVzcyA9IEVxdWF0aW9uXzEuZGVmYXVsdC5ERUZBVUxUX1NUSUZGTkVTUztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWxheGF0aW9uIG9mIHRoZSByZXN1bHRpbmcgQ29udGFjdEVxdWF0aW9uIHRoYXQgdGhpcyBDb250YWN0TWF0ZXJpYWwgZ2VuZXJhdGUuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9SRUxBWEFUSU9OOnByb3BlcnR5XCJ9fUVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTnt7L2Nyb3NzTGlua319LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSByZWxheGF0aW9uXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlbGF4YXRpb24gPSBFcXVhdGlvbl8xLmRlZmF1bHQuREVGQVVMVF9SRUxBWEFUSU9OO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgcmVzdWx0aW5nIGZyaWN0aW9uIGZvcmNlLiBGb3IgbW9zdCBjYXNlcywgdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgc2hvdWxkIGJlIGEgbGFyZ2UgbnVtYmVyLiBJIGNhbm5vdCB0aGluayBvZiBhbnkgY2FzZSB3aGVyZSB5b3Ugd291bGQgd2FudCBsZXNzIGZyaWN0aW9uU3RpZmZuZXNzLiBEZWZhdWx0IHZhbHVlIGlzIHt7I2Nyb3NzTGluayBcIkVxdWF0aW9uL0RFRkFVTFRfU1RJRkZORVNTOnByb3BlcnR5XCJ9fUVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTe3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICogQHByb3BlcnR5IGZyaWN0aW9uU3RpZmZuZXNzXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZyaWN0aW9uU3RpZmZuZXNzID0gRXF1YXRpb25fMS5kZWZhdWx0LkRFRkFVTFRfU1RJRkZORVNTO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbGF4YXRpb24gb2YgdGhlIHJlc3VsdGluZyBmcmljdGlvbiBmb3JjZS4gVGhlIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIGdvb2QgZm9yIG1vc3Qgc2ltdWxhdGlvbnMuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9SRUxBWEFUSU9OOnByb3BlcnR5XCJ9fUVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTnt7L2Nyb3NzTGlua319LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblJlbGF4YXRpb25cclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb25SZWxheGF0aW9uID0gRXF1YXRpb25fMS5kZWZhdWx0LkRFRkFVTFRfUkVMQVhBVElPTjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaWxsIGFkZCBzdXJmYWNlIHZlbG9jaXR5IHRvIHRoaXMgbWF0ZXJpYWwuIElmIGJvZHlBIHJlc3RzIG9uIHRvcCBpZiBib2R5QiwgYW5kIHRoZSBzdXJmYWNlIHZlbG9jaXR5IGlzIHBvc2l0aXZlLCBib2R5QSB3aWxsIHNsaWRlIHRvIHRoZSByaWdodC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3VyZmFjZVZlbG9jaXR5XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3VyZmFjZVZlbG9jaXR5ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPZmZzZXQgdG8gYmUgc2V0IG9uIENvbnRhY3RFcXVhdGlvbnMuIEEgcG9zaXRpdmUgdmFsdWUgd2lsbCBtYWtlIHRoZSBib2RpZXMgcGVuZXRyYXRlIG1vcmUgaW50byBlYWNoIG90aGVyLiBDYW4gYmUgdXNlZnVsIGluIHNjZW5lcyB3aGVyZSBjb250YWN0cyBuZWVkIHRvIGJlIG1vcmUgcGVyc2lzdGVudCwgZm9yIGV4YW1wbGUgd2hlbiBzdGFja2luZy4gQWthIFwiY3VyZSBmb3IgbmVydm91cyBjb250YWN0c1wiLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb250YWN0U2tpblNpemVcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGFjdFNraW5TaXplID0gMC4wMDU7XHJcbiAgICAgICAgaWYgKCEobWF0ZXJpYWxBIGluc3RhbmNlb2YgTWF0ZXJpYWxfMS5kZWZhdWx0KSB8fCAhKG1hdGVyaWFsQiBpbnN0YW5jZW9mIE1hdGVyaWFsXzEuZGVmYXVsdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgdHdvIGFyZ3VtZW50cyBtdXN0IGJlIE1hdGVyaWFsIGluc3RhbmNlcy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaWQgPSArK0NvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXI7XHJcbiAgICAgICAgdGhpcy5tYXRlcmlhbEEgPSBtYXRlcmlhbEE7XHJcbiAgICAgICAgdGhpcy5tYXRlcmlhbEIgPSBtYXRlcmlhbEI7XHJcbiAgICAgICAgdGhpcy5mcmljdGlvbiA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mcmljdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMC4zO1xyXG4gICAgICAgIHRoaXMucmVzdGl0dXRpb24gPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVzdGl0dXRpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XHJcbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RpZmZuZXNzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBFcXVhdGlvbl8xLmRlZmF1bHQuREVGQVVMVF9TVElGRk5FU1M7XHJcbiAgICAgICAgdGhpcy5yZWxheGF0aW9uID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlbGF4YXRpb24pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IEVxdWF0aW9uXzEuZGVmYXVsdC5ERUZBVUxUX1JFTEFYQVRJT047XHJcbiAgICAgICAgdGhpcy5mcmljdGlvblN0aWZmbmVzcyA9IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mcmljdGlvblN0aWZmbmVzcykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogRXF1YXRpb25fMS5kZWZhdWx0LkRFRkFVTFRfU1RJRkZORVNTO1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb25SZWxheGF0aW9uID0gKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogRXF1YXRpb25fMS5kZWZhdWx0LkRFRkFVTFRfUkVMQVhBVElPTjtcclxuICAgICAgICB0aGlzLnN1cmZhY2VWZWxvY2l0eSA9IChfZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdXJmYWNlVmVsb2NpdHkpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IDA7XHJcbiAgICAgICAgdGhpcy5jb250YWN0U2tpblNpemUgPSAwLjAwNTtcclxuICAgIH1cclxuICAgIENvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xyXG4gICAgcmV0dXJuIENvbnRhY3RNYXRlcmlhbDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29udGFjdE1hdGVyaWFsO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGxpbmVzLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgbGluZUludFxyXG4gKiBAcGFyYW0gIHtBcnJheX0gIGwxICAgICAgICAgIExpbmUgdmVjdG9yIDFcclxuICogQHBhcmFtICB7QXJyYXl9ICBsMiAgICAgICAgICBMaW5lIHZlY3RvciAyXHJcbiAqIEBwYXJhbSAge051bWJlcn0gcHJlY2lzaW9uICAgUHJlY2lzaW9uIHRvIHVzZSB3aGVuIGNoZWNraW5nIGlmIHRoZSBsaW5lcyBhcmUgcGFyYWxsZWxcclxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxyXG4gKi9cclxuZnVuY3Rpb24gbGluZUludChsMSwgbDIsIHByZWNpc2lvbikge1xyXG4gICAgaWYgKHByZWNpc2lvbiA9PT0gdm9pZCAwKSB7IHByZWNpc2lvbiA9IDA7IH1cclxuICAgIHZhciBpID0gbmV3IEZsb2F0MzJBcnJheSgyKTsgLy8gcG9pbnRcclxuICAgIHZhciBhMSwgYjEsIGMxLCBhMiwgYjIsIGMyLCBkZXQ7IC8vIHNjYWxhcnNcclxuICAgIGExID0gbDFbMV1bMV0gLSBsMVswXVsxXTtcclxuICAgIGIxID0gbDFbMF1bMF0gLSBsMVsxXVswXTtcclxuICAgIGMxID0gYTEgKiBsMVswXVswXSArIGIxICogbDFbMF1bMV07XHJcbiAgICBhMiA9IGwyWzFdWzFdIC0gbDJbMF1bMV07XHJcbiAgICBiMiA9IGwyWzBdWzBdIC0gbDJbMV1bMF07XHJcbiAgICBjMiA9IGEyICogbDJbMF1bMF0gKyBiMiAqIGwyWzBdWzFdO1xyXG4gICAgZGV0ID0gYTEgKiBiMiAtIGEyICogYjE7XHJcbiAgICBpZiAoIXNjYWxhcl9lcShkZXQsIDAsIHByZWNpc2lvbikpIHsgLy8gbGluZXMgYXJlIG5vdCBwYXJhbGxlbFxyXG4gICAgICAgIGlbMF0gPSAoYjIgKiBjMSAtIGIxICogYzIpIC8gZGV0O1xyXG4gICAgICAgIGlbMV0gPSAoYTEgKiBjMiAtIGEyICogYzEpIC8gZGV0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RzLlxyXG4gKiBAbWV0aG9kIHNlZ21lbnRzSW50ZXJzZWN0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IHAxIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cclxuICogQHBhcmFtIHtBcnJheX0gcDIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cclxuICogQHBhcmFtIHtBcnJheX0gcTEgVGhlIHN0YXJ0IHZlcnRleCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC5cclxuICogQHBhcmFtIHtBcnJheX0gcTIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdFxyXG4gKi9cclxuZnVuY3Rpb24gbGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgcTEsIHEyKSB7XHJcbiAgICB2YXIgZHggPSBwMlswXSAtIHAxWzBdO1xyXG4gICAgdmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcclxuICAgIHZhciBkYSA9IHEyWzBdIC0gcTFbMF07XHJcbiAgICB2YXIgZGIgPSBxMlsxXSAtIHExWzFdO1xyXG4gICAgLy8gc2VnbWVudHMgYXJlIHBhcmFsbGVsXHJcbiAgICBpZiAoKGRhICogZHkgLSBkYiAqIGR4KSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBzID0gKGR4ICogKHExWzFdIC0gcDFbMV0pICsgZHkgKiAocDFbMF0gLSBxMVswXSkpIC8gKGRhICogZHkgLSBkYiAqIGR4KTtcclxuICAgIHZhciB0ID0gKGRhICogKHAxWzFdIC0gcTFbMV0pICsgZGIgKiAocTFbMF0gLSBwMVswXSkpIC8gKGRiICogZHggLSBkYSAqIGR5KTtcclxuICAgIHJldHVybiAocyA+PSAwICYmIHMgPD0gMSAmJiB0ID49IDAgJiYgdCA8PSAxKTtcclxufVxyXG4vKipcclxuICogR2V0IHRoZSBhcmVhIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB0aGUgdGhyZWUgZ2l2ZW4gcG9pbnRzLiBOb3RlIHRoYXQgdGhlIGFyZWEgd2lsbCBiZSBuZWdhdGl2ZSBpZiB0aGUgcG9pbnRzIGFyZSBub3QgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIuXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBhcmVhXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAqIEBwYXJhbSAge0FycmF5fSBiXHJcbiAqIEBwYXJhbSAge0FycmF5fSBjXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSB7XHJcbiAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSkgLSAoKGNbMF0gLSBhWzBdKSAqIChiWzFdIC0gYVsxXSkpKTtcclxufVxyXG5mdW5jdGlvbiBpc0xlZnQoYSwgYiwgYykge1xyXG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA+IDA7XHJcbn1cclxuZnVuY3Rpb24gaXNMZWZ0T24oYSwgYiwgYykge1xyXG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA+PSAwO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmlnaHQoYSwgYiwgYykge1xyXG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA8IDA7XHJcbn1cclxuZnVuY3Rpb24gaXNSaWdodE9uKGEsIGIsIGMpIHtcclxuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPD0gMDtcclxufVxyXG52YXIgdG1wUG9pbnQxID0gbmV3IEZsb2F0MzJBcnJheSgyKSwgdG1wUG9pbnQyID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuLyoqXHJcbiAqIENoZWNrIGlmIHRocmVlIHBvaW50cyBhcmUgY29sbGluZWFyXHJcbiAqIEBtZXRob2QgY29sbGluZWFyXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAqIEBwYXJhbSAge0FycmF5fSBiXHJcbiAqIEBwYXJhbSAge0FycmF5fSBjXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW3RocmVzaG9sZEFuZ2xlPTBdIFRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBjb21wYXJpbmcgdGhlIHZlY3RvcnMuIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSByZXN1bHRpbmcgdmVjdG9ycyBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZS4gVXNlIHplcm8gZm9yIG1heCBwcmVjaXNpb24uXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBjb2xsaW5lYXIoYSwgYiwgYywgdGhyZXNob2xkQW5nbGUpIHtcclxuICAgIGlmICghdGhyZXNob2xkQW5nbGUpIHtcclxuICAgICAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpID09PSAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGFiID0gdG1wUG9pbnQxLCBiYyA9IHRtcFBvaW50MjtcclxuICAgICAgICBhYlswXSA9IGJbMF0gLSBhWzBdO1xyXG4gICAgICAgIGFiWzFdID0gYlsxXSAtIGFbMV07XHJcbiAgICAgICAgYmNbMF0gPSBjWzBdIC0gYlswXTtcclxuICAgICAgICBiY1sxXSA9IGNbMV0gLSBiWzFdO1xyXG4gICAgICAgIHZhciBkb3QgPSBhYlswXSAqIGJjWzBdICsgYWJbMV0gKiBiY1sxXSwgbWFnQSA9IE1hdGguc3FydChhYlswXSAqIGFiWzBdICsgYWJbMV0gKiBhYlsxXSksIG1hZ0IgPSBNYXRoLnNxcnQoYmNbMF0gKiBiY1swXSArIGJjWzFdICogYmNbMV0pLCBhbmdsZSA9IE1hdGguYWNvcyhkb3QgLyAobWFnQSAqIG1hZ0IpKTtcclxuICAgICAgICByZXR1cm4gYW5nbGUgPCB0aHJlc2hvbGRBbmdsZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzcWRpc3QoYSwgYikge1xyXG4gICAgdmFyIGR4ID0gYlswXSAtIGFbMF07XHJcbiAgICB2YXIgZHkgPSBiWzFdIC0gYVsxXTtcclxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxufVxyXG4vKipcclxuICogR2V0IGEgdmVydGV4IGF0IHBvc2l0aW9uIGkuIEl0IGRvZXMgbm90IG1hdHRlciBpZiBpIGlzIG91dCBvZiBib3VuZHMsIHRoaXMgZnVuY3Rpb24gd2lsbCBqdXN0IGN5Y2xlLlxyXG4gKiBAbWV0aG9kIGF0XHJcbiAqIEBwYXJhbSAge051bWJlcn0gaVxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25BdChwb2x5Z29uLCBpKSB7XHJcbiAgICB2YXIgcyA9IHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgcmV0dXJuIHBvbHlnb25baSA8IDAgPyBpICUgcyArIHMgOiBpICUgc107XHJcbn1cclxuLyoqXHJcbiAqIENsZWFyIHRoZSBwb2x5Z29uIGRhdGFcclxuICogQG1ldGhvZCBjbGVhclxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25DbGVhcihwb2x5Z29uKSB7XHJcbiAgICBwb2x5Z29uLmxlbmd0aCA9IDA7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGVuZCBwb2ludHMgXCJmcm9tXCIgdG8gXCJ0b1wiLTEgZnJvbSBhbiBvdGhlciBwb2x5Z29uIFwicG9seVwiIG9udG8gdGhpcyBvbmUuXHJcbiAqIEBtZXRob2QgYXBwZW5kXHJcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seSBUaGUgcG9seWdvbiB0byBnZXQgcG9pbnRzIGZyb20uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSAgZnJvbSBUaGUgdmVydGV4IGluZGV4IGluIFwicG9seVwiLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gIHRvIFRoZSBlbmQgdmVydGV4IGluZGV4IGluIFwicG9seVwiLiBOb3RlIHRoYXQgdGhpcyB2ZXJ0ZXggaXMgTk9UIGluY2x1ZGVkIHdoZW4gYXBwZW5kaW5nLlxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25BcHBlbmQocG9seWdvbiwgcG9seSwgZnJvbSwgdG8pIHtcclxuICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xyXG4gICAgICAgIHBvbHlnb24ucHVzaChwb2x5W2ldKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFrZSBzdXJlIHRoYXQgdGhlIHBvbHlnb24gdmVydGljZXMgYXJlIG9yZGVyZWQgY291bnRlci1jbG9ja3dpc2UuXHJcbiAqIEBtZXRob2QgbWFrZUNDV1xyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbk1ha2VDQ1cocG9seWdvbikge1xyXG4gICAgdmFyIGJyID0gMCwgdiA9IHBvbHlnb247XHJcbiAgICAvLyBmaW5kIGJvdHRvbSByaWdodCBwb2ludFxyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2x5Z29uLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgaWYgKHZbaV1bMV0gPCB2W2JyXVsxXSB8fCAodltpXVsxXSA9PT0gdlticl1bMV0gJiYgdltpXVswXSA+IHZbYnJdWzBdKSkge1xyXG4gICAgICAgICAgICBiciA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gcmV2ZXJzZSBwb2x5IGlmIGNsb2Nrd2lzZVxyXG4gICAgaWYgKCFpc0xlZnQocG9seWdvbkF0KHBvbHlnb24sIGJyIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBiciksIHBvbHlnb25BdChwb2x5Z29uLCBiciArIDEpKSkge1xyXG4gICAgICAgIHBvbHlnb25SZXZlcnNlKHBvbHlnb24pO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXZlcnNlIHRoZSB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvblxyXG4gKiBAbWV0aG9kIHJldmVyc2VcclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25SZXZlcnNlKHBvbHlnb24pIHtcclxuICAgIHZhciB0bXAgPSBbXTtcclxuICAgIHZhciBOID0gcG9seWdvbi5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTjsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHAgPSBwb2x5Z29uLnBvcCgpO1xyXG4gICAgICAgIHRtcC5wdXNoKHApO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xyXG4gICAgICAgIHBvbHlnb25baV0gPSB0bXBbaV07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgcG9pbnQgaW4gdGhlIHBvbHlnb24gaXMgYSByZWZsZXggcG9pbnRcclxuICogQG1ldGhvZCBpc1JlZmxleFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBpXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uSXNSZWZsZXgocG9seWdvbiwgaSkge1xyXG4gICAgcmV0dXJuIGlzUmlnaHQocG9seWdvbkF0KHBvbHlnb24sIGkgLSAxKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaSArIDEpKTtcclxufVxyXG52YXIgdG1wTGluZTEgPSBbXSwgdG1wTGluZTIgPSBbXTtcclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcclxuICogQG1ldGhvZCBjYW5TZWVcclxuICogQHBhcmFtICB7TnVtYmVyfSBhIFZlcnRleCBpbmRleCAxXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYiBWZXJ0ZXggaW5kZXggMlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbkNhblNlZShwb2x5Z29uLCBhLCBiKSB7XHJcbiAgICB2YXIgcCwgZGlzdCwgbDEgPSB0bXBMaW5lMSwgbDIgPSB0bXBMaW5lMjtcclxuICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seWdvbiwgYSArIDEpLCBwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5Z29uLCBhIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGRpc3QgPSBzcWRpc3QocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYikpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHBvbHlnb24ubGVuZ3RoOyArK2kpIHsgLy8gZm9yIGVhY2ggZWRnZVxyXG4gICAgICAgIGlmICgoaSArIDEpICUgcG9seWdvbi5sZW5ndGggPT09IGEgfHwgaSA9PT0gYSkgeyAvLyBpZ25vcmUgaW5jaWRlbnQgZWRnZXNcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpLCBwb2x5Z29uQXQocG9seWdvbiwgaSkpKSB7IC8vIGlmIGRpYWcgaW50ZXJzZWN0cyBhbiBlZGdlXHJcbiAgICAgICAgICAgIGwxWzBdID0gcG9seWdvbkF0KHBvbHlnb24sIGEpO1xyXG4gICAgICAgICAgICBsMVsxXSA9IHBvbHlnb25BdChwb2x5Z29uLCBiKTtcclxuICAgICAgICAgICAgbDJbMF0gPSBwb2x5Z29uQXQocG9seWdvbiwgaSk7XHJcbiAgICAgICAgICAgIGwyWzFdID0gcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKTtcclxuICAgICAgICAgICAgcCA9IGxpbmVJbnQobDEsIGwyKTtcclxuICAgICAgICAgICAgaWYgKHNxZGlzdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHApIDwgZGlzdCkgeyAvLyBpZiBlZGdlIGlzIGJsb2NraW5nIHZpc2liaWxpdHkgdG8gYlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcclxuICogQG1ldGhvZCBjYW5TZWUyXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYSBWZXJ0ZXggaW5kZXggMVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGIgVmVydGV4IGluZGV4IDJcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25DYW5TZWUyKHBvbHlnb24sIGEsIGIpIHtcclxuICAgIC8vIGZvciBlYWNoIGVkZ2VcclxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBwb2x5Z29uLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXHJcbiAgICAgICAgaWYgKGkgPT09IGEgfHwgaSA9PT0gYiB8fCAoaSArIDEpICUgcG9seWdvbi5sZW5ndGggPT09IGEgfHwgKGkgKyAxKSAlIHBvbHlnb24ubGVuZ3RoID09PSBiKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGluZVNlZ21lbnRzSW50ZXJzZWN0KHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpLCBwb2x5Z29uQXQocG9seWdvbiwgaSksIHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogQ29weSB0aGUgcG9seWdvbiBmcm9tIHZlcnRleCBpIHRvIHZlcnRleCBqLlxyXG4gKiBAbWV0aG9kIGNvcHlcclxuICogQHBhcmFtICB7TnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge051bWJlcn0galxyXG4gKiBAcGFyYW0gIHtQb2x5Z29ufSBbdGFyZ2V0UG9seV0gICBPcHRpb25hbCB0YXJnZXQgcG9seWdvbiB0byBzYXZlIGluLlxyXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSAgICAgICAgICAgICAgICBUaGUgcmVzdWx0aW5nIGNvcHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uQ29weShwb2x5Z29uLCBpLCBqLCB0YXJnZXRQb2x5KSB7XHJcbiAgICB2YXIgcCA9IHRhcmdldFBvbHkgIT09IG51bGwgJiYgdGFyZ2V0UG9seSAhPT0gdm9pZCAwID8gdGFyZ2V0UG9seSA6IFtdO1xyXG4gICAgcG9seWdvbkNsZWFyKHApO1xyXG4gICAgaWYgKGkgPCBqKSB7XHJcbiAgICAgICAgLy8gSW5zZXJ0IGFsbCB2ZXJ0aWNlcyBmcm9tIGkgdG8galxyXG4gICAgICAgIGZvciAodmFyIGsgPSBpOyBrIDw9IGo7IGsrKykge1xyXG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gSW5zZXJ0IHZlcnRpY2VzIDAgdG8galxyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDw9IGo7IGsrKykge1xyXG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyBpIHRvIGVuZFxyXG4gICAgICAgIGZvciAodmFyIGsgPSBpOyBrIDwgcG9seWdvbi5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHA7XHJcbn1cclxuLyoqXHJcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBjb252ZXggcGllY2VzLiBSZXR1cm5zIGEgbGlzdCBvZiBlZGdlcyBbW3AxLHAyXSxbcDIscDNdLC4uLl0gdGhhdCBjdXRzIHRoZSBwb2x5Z29uLlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBhbGdvcml0aG0gaGFzIGNvbXBsZXhpdHkgTyhOXjQpIGFuZCB3aWxsIGJlIHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtYW55IHZlcnRpY2VzLlxyXG4gKiBAbWV0aG9kIGdldEN1dEVkZ2VzXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb24pIHtcclxuICAgIHZhciBtaW4gPSBbXSwgdG1wMSA9IFtdLCB0bXAyID0gW10sIHRtcFBvbHkgPSBbXTtcclxuICAgIHZhciBuRGlhZ3MgPSBJbmZpbml0eTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChwb2x5Z29uSXNSZWZsZXgocG9seWdvbiwgaSkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2x5Z29uLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbkNhblNlZShwb2x5Z29uLCBpLCBqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcDEgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaSwgaiwgdG1wUG9seSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcDIgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaiwgaSwgdG1wUG9seSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdG1wMi5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAxLnB1c2godG1wMltrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0bXAxLmxlbmd0aCA8IG5EaWFncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB0bXAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuRGlhZ3MgPSB0bXAxLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBbcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaildO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4ucHVzaChwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWluO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNvbXBvc2VzIHRoZSBwb2x5Z29uIGludG8gb25lIG9yIG1vcmUgY29udmV4IHN1Yi1Qb2x5Z29ucy5cclxuICogQG1ldGhvZCBkZWNvbXBcclxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9yIFBvbHlnb24gb2JqZWN0cy5cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25EZWNvbXAocG9seWdvbikge1xyXG4gICAgdmFyIGVkZ2VzID0gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb24pO1xyXG4gICAgaWYgKGVkZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICByZXR1cm4gcG9seWdvblNsaWNlKHBvbHlnb24sIGVkZ2VzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbcG9seWdvbl07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNsaWNlcyB0aGUgcG9seWdvbiBnaXZlbiBvbmUgb3IgbW9yZSBjdXQgZWRnZXMuIElmIGdpdmVuIG9uZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0d28gcG9seWdvbnMgKGZhbHNlIG9uIGZhaWx1cmUpLiBJZiBtYW55LCBhbiBhcnJheSBvZiBwb2x5Z29ucy5cclxuICogQHdhcm5pbmcgVGhlIGlubmVyIHdvcmtpbmdzIG9mIHRoaXMgZnVuY3Rpb24gd2FzIG1hc3NpdmVseSBtb2RpZmllZCB3aGVuIHN3aXRjaGluZyB0byB0eXBlc2NyaXB0LiBOZWVkcyB0aG9yb3VnaCB0ZXN0aW5nLlxyXG4gKiBAbWV0aG9kIHNsaWNlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGN1dEVkZ2VzIEEgbGlzdCBvZiBlZGdlcywgYXMgcmV0dXJuZWQgYnkgLmdldEN1dEVkZ2VzKClcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uU2xpY2UocG9seWdvbiwgY3V0RWRnZXMpIHtcclxuICAgIGlmIChjdXRFZGdlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gW3BvbHlnb25dO1xyXG4gICAgfVxyXG4gICAgaWYgKGN1dEVkZ2VzWzBdLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIHZhciBwb2x5cyA9IFtwb2x5Z29uXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1dEVkZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXRFZGdlID0gW2N1dEVkZ2VzW2ldXTtcclxuICAgICAgICAgICAgLy8gQ3V0IGFsbCBwb2x5c1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvbHlzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9seSA9IHBvbHlzW2pdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBvbHlnb25TbGljZShwb2x5LCBjdXRFZGdlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBwb2x5ISBDdXQgYW5kIHF1aXRcclxuICAgICAgICAgICAgICAgICAgICBwb2x5cy5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seXMucHVzaChyZXN1bHRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnB1c2gocmVzdWx0WzFdKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9seXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBXYXMgZ2l2ZW4gb25lIGVkZ2VcclxuICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzO1xyXG4gICAgICAgIHZhciBpID0gcG9seWdvbi5pbmRleE9mKGN1dEVkZ2VbMF1bMF0pO1xyXG4gICAgICAgIHZhciBqID0gcG9seWdvbi5pbmRleE9mKGN1dEVkZ2VbMF1bMV0pO1xyXG4gICAgICAgIGlmIChpICE9PSAtMSAmJiBqICE9PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3BvbHlnb25Db3B5KHBvbHlnb24sIGksIGopLFxyXG4gICAgICAgICAgICAgICAgcG9seWdvbkNvcHkocG9seWdvbiwgaiwgaSldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2hlY2tzIHRoYXQgdGhlIGxpbmUgc2VnbWVudHMgb2YgdGhpcyBwb2x5Z29uIGRvIG5vdCBpbnRlcnNlY3QgZWFjaCBvdGhlci5cclxuICogQG1ldGhvZCBpc1NpbXBsZVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiB2ZXJ0aWNlcyBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEB0b2RvIFNob3VsZCBpdCBjaGVjayBhbGwgc2VnbWVudHMgd2l0aCBhbGwgb3RoZXJzP1xyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbklzU2ltcGxlKHBvbHlnb24pIHtcclxuICAgIHZhciBwYXRoID0gcG9seWdvbiwgaTtcclxuICAgIC8vIENoZWNrXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgLSAxOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKGxpbmVTZWdtZW50c0ludGVyc2VjdChwYXRoW2ldLCBwYXRoW2kgKyAxXSwgcGF0aFtqXSwgcGF0aFtqICsgMV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDaGVjayB0aGUgc2VnbWVudCBiZXR3ZWVuIHRoZSBsYXN0IGFuZCB0aGUgZmlyc3QgcG9pbnQgdG8gYWxsIG90aGVyc1xyXG4gICAgZm9yIChpID0gMTsgaSA8IHBhdGgubGVuZ3RoIC0gMjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGxpbmVTZWdtZW50c0ludGVyc2VjdChwYXRoWzBdLCBwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGhbaV0sIHBhdGhbaSArIDFdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocDEsIHAyLCBxMSwgcTIsIGRlbHRhKSB7XHJcbiAgICBpZiAoZGVsdGEgPT09IHZvaWQgMCkgeyBkZWx0YSA9IDA7IH1cclxuICAgIHZhciBhMSA9IHAyWzFdIC0gcDFbMV07XHJcbiAgICB2YXIgYjEgPSBwMVswXSAtIHAyWzBdO1xyXG4gICAgdmFyIGMxID0gKGExICogcDFbMF0pICsgKGIxICogcDFbMV0pO1xyXG4gICAgdmFyIGEyID0gcTJbMV0gLSBxMVsxXTtcclxuICAgIHZhciBiMiA9IHExWzBdIC0gcTJbMF07XHJcbiAgICB2YXIgYzIgPSAoYTIgKiBxMVswXSkgKyAoYjIgKiBxMVsxXSk7XHJcbiAgICB2YXIgZGV0ID0gKGExICogYjIpIC0gKGEyICogYjEpO1xyXG4gICAgdmFyIHB0ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuICAgIGlmICghc2NhbGFyX2VxKGRldCwgMCwgZGVsdGEpKSB7XHJcbiAgICAgICAgcHRbMF0gPSAoKGIyICogYzEpIC0gKGIxICogYzIpKSAvIGRldDtcclxuICAgICAgICBwdFsxXSA9ICgoYTEgKiBjMikgLSAoYTIgKiBjMSkpIC8gZGV0O1xyXG4gICAgICAgIHJldHVybiBwdDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHB0WzBdID0gMDtcclxuICAgICAgICBwdFsxXSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHB0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBRdWlja2x5IGRlY29tcG9zZSB0aGUgUG9seWdvbiBpbnRvIGNvbnZleCBzdWItcG9seWdvbnMuXHJcbiAqIEBtZXRob2QgcXVpY2tEZWNvbXBcclxuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxyXG4gKiBAcGFyYW0gIHtBcnJheX0gW3JlZmxleFZlcnRpY2VzXVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gW3N0ZWluZXJQb2ludHNdXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW2RlbHRhXVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXhsZXZlbF1cclxuICogQHBhcmFtICB7TnVtYmVyfSBbbGV2ZWxdXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvblF1aWNrRGVjb21wKHBvbHlnb24sIHJlc3VsdCwgcmVmbGV4VmVydGljZXMsIHN0ZWluZXJQb2ludHMsIGRlbHRhLCBtYXhsZXZlbCwgbGV2ZWwpIHtcclxuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgeyByZXN1bHQgPSBuZXcgQXJyYXkoKTsgfVxyXG4gICAgaWYgKHJlZmxleFZlcnRpY2VzID09PSB2b2lkIDApIHsgcmVmbGV4VmVydGljZXMgPSBbXTsgfVxyXG4gICAgaWYgKHN0ZWluZXJQb2ludHMgPT09IHZvaWQgMCkgeyBzdGVpbmVyUG9pbnRzID0gW107IH1cclxuICAgIGlmIChkZWx0YSA9PT0gdm9pZCAwKSB7IGRlbHRhID0gMjU7IH1cclxuICAgIGlmIChtYXhsZXZlbCA9PT0gdm9pZCAwKSB7IG1heGxldmVsID0gMTAwOyB9XHJcbiAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IDA7IH1cclxuICAgIC8vIFRPRE86IHNob3VsZCB1cHBlckludCByZWFsbHkgYmUgaW5pdGlhbGl6ZWQgaGVyZT8gSXQgbG9va3MgbGlrZSBpdCdzIG92ZXJ3cml0dGVuLlxyXG4gICAgdmFyIHVwcGVySW50ID0gbmV3IEZsb2F0MzJBcnJheSgyKSwgbG93ZXJJbnQgPSBuZXcgRmxvYXQzMkFycmF5KDIpLCBwID0gbmV3IEZsb2F0MzJBcnJheSgyKTsgLy8gUG9pbnRzXHJcbiAgICB1cHBlckludFswXSA9IDA7XHJcbiAgICB1cHBlckludFsxXSA9IDA7XHJcbiAgICBsb3dlckludFswXSA9IDA7XHJcbiAgICBsb3dlckludFsxXSA9IDA7XHJcbiAgICBwWzBdID0gMDtcclxuICAgIHBbMV0gPSAwO1xyXG4gICAgdmFyIHVwcGVyRGlzdCA9IDAsIGxvd2VyRGlzdCA9IDAsIGQgPSAwLCBjbG9zZXN0RGlzdCA9IDA7IC8vIHNjYWxhcnNcclxuICAgIHZhciB1cHBlckluZGV4ID0gMCwgbG93ZXJJbmRleCA9IDAsIGNsb3Nlc3RJbmRleCA9IDA7IC8vIEludGVnZXJzXHJcbiAgICB2YXIgbG93ZXJQb2x5ID0gbmV3IEFycmF5KCksIHVwcGVyUG9seSA9IG5ldyBBcnJheSgpOyAvLyBwb2x5Z29uc1xyXG4gICAgdmFyIHBvbHkgPSBwb2x5Z29uLCB2ID0gcG9seWdvbjtcclxuICAgIGlmICh2Lmxlbmd0aCA8IDMpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgbGV2ZWwrKztcclxuICAgIGlmIChsZXZlbCA+IG1heGxldmVsKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLndhcm4oXCJxdWlja0RlY29tcDogbWF4IGxldmVsIChcIittYXhsZXZlbCtcIikgcmVhY2hlZC5cIik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChwb2x5Z29uSXNSZWZsZXgocG9seSwgaSkpIHtcclxuICAgICAgICAgICAgcmVmbGV4VmVydGljZXMucHVzaChwb2x5W2ldKTtcclxuICAgICAgICAgICAgdXBwZXJEaXN0ID0gbG93ZXJEaXN0ID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9seWdvbi5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpIC0gMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGogLSAxKSkpIHsgLy8gaWYgbGluZSBpbnRlcnNlY3RzIHdpdGggYW4gZWRnZVxyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSwgcG9seWdvbkF0KHBvbHksIGogLSAxKSk7IC8vIGZpbmQgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JpZ2h0KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcCkpIHsgLy8gbWFrZSBzdXJlIGl0J3MgaW5zaWRlIHRoZSBwb2x5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seVtpXSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgbG93ZXJEaXN0KSB7IC8vIGtlZXAgb25seSB0aGUgY2xvc2VzdCBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyRGlzdCA9IGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckludCA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaiArIDEpKSAmJiBpc1JpZ2h0T24ocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IGdldEludGVyc2VjdGlvblBvaW50KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopLCBwb2x5Z29uQXQocG9seSwgaiArIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KHBvbHlnb25BdChwb2x5LCBpIC0gMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHNxZGlzdChwb2x5W2ldLCBwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCB1cHBlckRpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyRGlzdCA9IGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckludCA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdmVydGljZXMgdG8gY29ubmVjdCB0bywgY2hvb3NlIGEgcG9pbnQgaW4gdGhlIG1pZGRsZVxyXG4gICAgICAgICAgICBpZiAobG93ZXJJbmRleCA9PT0gKHVwcGVySW5kZXggKyAxKSAlIHBvbHlnb24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2FzZSAxOiBWZXJ0ZXgoXCIraStcIiksIGxvd2VySW5kZXgoXCIrbG93ZXJJbmRleCtcIiksIHVwcGVySW5kZXgoXCIrdXBwZXJJbmRleCtcIiksIHBvbHkuc2l6ZShcIitwb2x5Z29uLmxlbmd0aCtcIilcIik7XHJcbiAgICAgICAgICAgICAgICBwWzBdID0gKGxvd2VySW50WzBdICsgdXBwZXJJbnRbMF0pIC8gMjtcclxuICAgICAgICAgICAgICAgIHBbMV0gPSAobG93ZXJJbnRbMV0gKyB1cHBlckludFsxXSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgc3RlaW5lclBvaW50cy5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCB1cHBlckluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LCBpLCB1cHBlckluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5lbmQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LCBsb3dlckluZGV4LCBwb2x5Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LCAwLCBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBpLCBwb2x5LmVuZCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksIGksIHBvbHkubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksIDAsIHVwcGVySW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkucHVzaChwKTtcclxuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkucHVzaChwKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBsb3dlckluZGV4LCBwb2x5LmJlZ2luKCkgKyBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksIGxvd2VySW5kZXgsIGkgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgd2l0aGluIHRoZSB0cmlhbmdsZVxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMjogVmVydGV4KFwiK2krXCIpLCBjbG9zZXN0SW5kZXgoXCIrY2xvc2VzdEluZGV4K1wiKSwgcG9seS5zaXplKFwiK3BvbHlnb24ubGVuZ3RoK1wiKVxcblwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID4gdXBwZXJJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwcGVySW5kZXggKz0gcG9seWdvbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHVwcGVySW5kZXggPCBsb3dlckluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBsb3dlckluZGV4OyBqIDw9IHVwcGVySW5kZXg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gc3FkaXN0KHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBjbG9zZXN0RGlzdCAmJiBwb2x5Z29uQ2FuU2VlMihwb2x5LCBpLCBqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gaiAlIHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCBjbG9zZXN0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwgaSwgY2xvc2VzdEluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RJbmRleCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSwgY2xvc2VzdEluZGV4LCB2Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LCAwLCBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwgaSwgdi5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwgMCwgY2xvc2VzdEluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksIGNsb3Nlc3RJbmRleCwgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNvbHZlIHNtYWxsZXN0IHBvbHkgZmlyc3RcclxuICAgICAgICAgICAgaWYgKGxvd2VyUG9seS5sZW5ndGggPCB1cHBlclBvbHkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LCByZXN1bHQsIHJlZmxleFZlcnRpY2VzLCBzdGVpbmVyUG9pbnRzLCBkZWx0YSwgbWF4bGV2ZWwsIGxldmVsKTtcclxuICAgICAgICAgICAgICAgIHBvbHlnb25RdWlja0RlY29tcCh1cHBlclBvbHksIHJlc3VsdCwgcmVmbGV4VmVydGljZXMsIHN0ZWluZXJQb2ludHMsIGRlbHRhLCBtYXhsZXZlbCwgbGV2ZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKHVwcGVyUG9seSwgcmVzdWx0LCByZWZsZXhWZXJ0aWNlcywgc3RlaW5lclBvaW50cywgZGVsdGEsIG1heGxldmVsLCBsZXZlbCk7XHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LCByZXN1bHQsIHJlZmxleFZlcnRpY2VzLCBzdGVpbmVyUG9pbnRzLCBkZWx0YSwgbWF4bGV2ZWwsIGxldmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VsdC5wdXNoKHBvbHlnb24pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIGNvbGxpbmVhciBwb2ludHMgaW4gdGhlIHBvbHlnb24uXHJcbiAqIEBtZXRob2QgcmVtb3ZlQ29sbGluZWFyUG9pbnRzXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBlZGdlcyBhcmUgY29sbGluZWFyLiBVc2UgemVybyBmb3IgZmluZXN0IHByZWNpc2lvbi5cclxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVtb3ZlZFxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvblJlbW92ZUNvbGxpbmVhclBvaW50cyhwb2x5Z29uLCBwcmVjaXNpb24pIHtcclxuICAgIHZhciBudW0gPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IHBvbHlnb24ubGVuZ3RoIC0gMTsgcG9seWdvbi5sZW5ndGggPiAzICYmIGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgaWYgKGNvbGxpbmVhcihwb2x5Z29uQXQocG9seWdvbiwgaSAtIDEpLCBwb2x5Z29uQXQocG9seWdvbiwgaSksIHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSksIHByZWNpc2lvbikpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBtaWRkbGUgcG9pbnRcclxuICAgICAgICAgICAgcG9seWdvbi5zcGxpY2UoaSAlIHBvbHlnb24ubGVuZ3RoLCAxKTtcclxuICAgICAgICAgICAgbnVtKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bTtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIGR1cGxpY2F0ZSBwb2ludHMgaW4gdGhlIHBvbHlnb24uXHJcbiAqIEBtZXRob2QgcmVtb3ZlRHVwbGljYXRlUG9pbnRzXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBwb2ludHMgYXJlIHRoZSBzYW1lLiBVc2UgemVybyBmb3IgYmVzdCBwcmVjaXNpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uUmVtb3ZlRHVwbGljYXRlUG9pbnRzKHBvbHlnb24sIHByZWNpc2lvbikge1xyXG4gICAgZm9yICh2YXIgaSA9IHBvbHlnb24ubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcclxuICAgICAgICB2YXIgcGkgPSBwb2x5Z29uW2ldO1xyXG4gICAgICAgIGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSAwOyAtLWopIHtcclxuICAgICAgICAgICAgaWYgKHBvaW50c19lcShwaSwgcG9seWdvbltqXSwgcHJlY2lzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcG9seWdvbi5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgdHdvIHNjYWxhcnMgYXJlIGVxdWFsXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBlcVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFcclxuICogQHBhcmFtICB7TnVtYmVyfSBiXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl1cclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIHNjYWxhcl9lcShhLCBiLCBwcmVjaXNpb24pIHtcclxuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBwcmVjaXNpb247XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBwb2ludHNfZXFcclxuICogQHBhcmFtICB7QXJyYXl9IGFcclxuICogQHBhcmFtICB7QXJyYXl9IGJcclxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gcG9pbnRzX2VxKGEsIGIsIHByZWNpc2lvbikge1xyXG4gICAgcmV0dXJuIHNjYWxhcl9lcShhWzBdLCBiWzBdLCBwcmVjaXNpb24pICYmIHNjYWxhcl9lcShhWzFdLCBiWzFdLCBwcmVjaXNpb24pO1xyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICAgIGRlY29tcDogcG9seWdvbkRlY29tcCxcclxuICAgIHF1aWNrRGVjb21wOiBwb2x5Z29uUXVpY2tEZWNvbXAsXHJcbiAgICBpc1NpbXBsZTogcG9seWdvbklzU2ltcGxlLFxyXG4gICAgcmVtb3ZlQ29sbGluZWFyUG9pbnRzOiBwb2x5Z29uUmVtb3ZlQ29sbGluZWFyUG9pbnRzLFxyXG4gICAgcmVtb3ZlRHVwbGljYXRlUG9pbnRzOiBwb2x5Z29uUmVtb3ZlRHVwbGljYXRlUG9pbnRzLFxyXG4gICAgbWFrZUNDVzogcG9seWdvbk1ha2VDQ1dcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypcclxuICAgIFBvbHlLIGxpYnJhcnlcclxuICAgIHVybDogaHR0cDovL3BvbHlrLml2YW5rLm5ldFxyXG4gICAgUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2VuY2UuXHJcblxyXG4gICAgQ29weXJpZ2h0IChjKSAyMDEyIEl2YW4gS3Vja2lyXHJcblxyXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbiAgICBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4gICAgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4gICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuICAgIGNvbmRpdGlvbnM6XHJcblxyXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuICAgIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4gICAgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbiAgICBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuICAgIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuKi9cclxudmFyIFBvbHlLID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUG9seUsoKSB7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICAgIElzIFBvbHlnb24gc2VsZi1pbnRlcnNlY3Rpbmc/XHJcblxyXG4gICAgICAgIE8obl4yKVxyXG4gICAgKi9cclxuICAgIC8qXHJcbiAgICBJc1NpbXBsZShwKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuID0gcC5sZW5ndGg+PjE7XHJcbiAgICAgICAgaWYobjw0KSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB2YXIgYTEgPSBuZXcgdGhpcy5fUCgpLCBhMiA9IG5ldyB0aGlzLl9QKCk7XHJcbiAgICAgICAgdmFyIGIxID0gbmV3IHRoaXMuX1AoKSwgYjIgPSBuZXcgdGhpcy5fUCgpO1xyXG4gICAgICAgIHZhciBjID0gbmV3IHRoaXMuX1AoKTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYTEueCA9IHBbMippICBdO1xyXG4gICAgICAgICAgICBhMS55ID0gcFsyKmkrMV07XHJcbiAgICAgICAgICAgIGlmKGk9PW4tMSkgIHsgYTIueCA9IHBbMCAgICBdOyAgYTIueSA9IHBbMSAgICBdOyB9XHJcbiAgICAgICAgICAgIGVsc2UgICAgICAgIHsgYTIueCA9IHBbMippKzJdOyAgYTIueSA9IHBbMippKzNdOyB9XHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIGo9MDsgajxuOyBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKGktaikgPCAyKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmKGo9PW4tMSAmJiBpPT0wKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmKGk9PW4tMSAmJiBqPT0wKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBiMS54ID0gcFsyKmogIF07XHJcbiAgICAgICAgICAgICAgICBiMS55ID0gcFsyKmorMV07XHJcbiAgICAgICAgICAgICAgICBpZihqPT1uLTEpICB7IGIyLnggPSBwWzAgICAgXTsgIGIyLnkgPSBwWzEgICAgXTsgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSAgICAgICAgeyBiMi54ID0gcFsyKmorMl07ICBiMi55ID0gcFsyKmorM107IH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9HZXRMaW5lSW50ZXJzZWN0aW9uKGExLGEyLGIxLGIyLGMpICE9IG51bGwpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBJc0NvbnZleChwKVxyXG4gICAge1xyXG4gICAgICAgIGlmKHAubGVuZ3RoPDYpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSA0O1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXHJcbiAgICAgICAgICAgIGlmKCF0aGlzLl9jb252ZXgocFtpXSwgcFtpKzFdLCBwW2krMl0sIHBbaSszXSwgcFtpKzRdLCBwW2krNV0pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYoIXRoaXMuX2NvbnZleChwW2wgIF0sIHBbbCsxXSwgcFtsKzJdLCBwW2wrM10sIHBbMF0sIHBbMV0pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYoIXRoaXMuX2NvbnZleChwW2wrMl0sIHBbbCszXSwgcFswICBdLCBwWzEgIF0sIHBbMl0sIHBbM10pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgUG9seUsucHJvdG90eXBlLkdldEFyZWEgPSBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIGlmIChwLmxlbmd0aCA8IDYpXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSAyO1xyXG4gICAgICAgIHZhciBzdW0gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSArPSAyKVxyXG4gICAgICAgICAgICBzdW0gKz0gKHBbaSArIDJdIC0gcFtpXSkgKiAocFtpICsgMV0gKyBwW2kgKyAzXSk7XHJcbiAgICAgICAgc3VtICs9IChwWzBdIC0gcFtsXSkgKiAocFtsICsgMV0gKyBwWzFdKTtcclxuICAgICAgICByZXR1cm4gLXN1bSAqIDAuNTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgR2V0QUFCQihwKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBtaW54ID0gSW5maW5pdHk7XHJcbiAgICAgICAgdmFyIG1pbnkgPSBJbmZpbml0eTtcclxuICAgICAgICB2YXIgbWF4eCA9IC1taW54O1xyXG4gICAgICAgIHZhciBtYXh5ID0gLW1pbnk7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtaW54ID0gTWF0aC5taW4obWlueCwgcFtpICBdKTtcclxuICAgICAgICAgICAgbWF4eCA9IE1hdGgubWF4KG1heHgsIHBbaSAgXSk7XHJcbiAgICAgICAgICAgIG1pbnkgPSBNYXRoLm1pbihtaW55LCBwW2krMV0pO1xyXG4gICAgICAgICAgICBtYXh5ID0gTWF0aC5tYXgobWF4eSwgcFtpKzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHt4Om1pbngsIHk6bWlueSwgd2lkdGg6bWF4eC1taW54LCBoZWlnaHQ6bWF4eS1taW55fTtcclxuICAgIH1cclxuICAgICovXHJcbiAgICBQb2x5Sy5wcm90b3R5cGUuVHJpYW5ndWxhdGUgPSBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIHZhciBuID0gcC5sZW5ndGggPj4gMTtcclxuICAgICAgICBpZiAobiA8IDMpXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB2YXIgdGdzID0gW107XHJcbiAgICAgICAgdmFyIGF2bCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICBhdmwucHVzaChpKTtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIGFsID0gbjtcclxuICAgICAgICB3aGlsZSAoYWwgPiAzKSB7XHJcbiAgICAgICAgICAgIHZhciBpMCA9IGF2bFsoaSArIDApICUgYWxdO1xyXG4gICAgICAgICAgICB2YXIgaTEgPSBhdmxbKGkgKyAxKSAlIGFsXTtcclxuICAgICAgICAgICAgdmFyIGkyID0gYXZsWyhpICsgMikgJSBhbF07XHJcbiAgICAgICAgICAgIHZhciBheCA9IHBbMiAqIGkwXSwgYXkgPSBwWzIgKiBpMCArIDFdO1xyXG4gICAgICAgICAgICB2YXIgYnggPSBwWzIgKiBpMV0sIGJ5ID0gcFsyICogaTEgKyAxXTtcclxuICAgICAgICAgICAgdmFyIGN4ID0gcFsyICogaTJdLCBjeSA9IHBbMiAqIGkyICsgMV07XHJcbiAgICAgICAgICAgIHZhciBlYXJGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY29udmV4KGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKSB7XHJcbiAgICAgICAgICAgICAgICBlYXJGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmkgPSBhdmxbal07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpID09IGkwIHx8IHZpID09IGkxIHx8IHZpID09IGkyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fUG9pbnRJblRyaWFuZ2xlKHBbMiAqIHZpXSwgcFsyICogdmkgKyAxXSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFyRm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlYXJGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGdzLnB1c2goaTApO1xyXG4gICAgICAgICAgICAgICAgdGdzLnB1c2goaTEpO1xyXG4gICAgICAgICAgICAgICAgdGdzLnB1c2goaTIpO1xyXG4gICAgICAgICAgICAgICAgYXZsLnNwbGljZSgoaSArIDEpICUgYWwsIDEpO1xyXG4gICAgICAgICAgICAgICAgYWwtLTtcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkrKyA+IDMgKiBhbClcclxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBubyBjb252ZXggYW5nbGVzIDooXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRncy5wdXNoKGF2bFswXSk7XHJcbiAgICAgICAgdGdzLnB1c2goYXZsWzFdKTtcclxuICAgICAgICB0Z3MucHVzaChhdmxbMl0pO1xyXG4gICAgICAgIHJldHVybiB0Z3M7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIENvbnRhaW5zUG9pbnQocCwgcHgsIHB5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuID0gcC5sZW5ndGg+PjE7XHJcbiAgICAgICAgdmFyIGF4LCBheSwgYnggPSBwWzIqbi0yXS1weCwgYnkgPSBwWzIqbi0xXS1weTtcclxuICAgICAgICB2YXIgZGVwdGggPSAwO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGF4ID0gYng7ICBheSA9IGJ5O1xyXG4gICAgICAgICAgICBieCA9IHBbMippICBdIC0gcHg7XHJcbiAgICAgICAgICAgIGJ5ID0gcFsyKmkrMV0gLSBweTtcclxuICAgICAgICAgICAgaWYoYXk8IDAgJiYgYnk8IDApIGNvbnRpbnVlOyAgICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG9ud1wiXHJcbiAgICAgICAgICAgIGlmKGF5Pj0wICYmIGJ5Pj0wKSBjb250aW51ZTsgICAgLy8gYm90aCBcInVwXCIgb3IgYm90aCBcImRvbndcIlxyXG4gICAgICAgICAgICBpZihheDwgMCAmJiBieDwgMCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgbHggPSBheCArIChieC1heCkqKC1heSkvKGJ5LWF5KTtcclxuICAgICAgICAgICAgaWYobHg+MCkgZGVwdGgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChkZXB0aCAmIDEpID09IDE7XHJcbiAgICB9XHJcblxyXG4gICAgU2xpY2UocCwgYXgsIGF5LCBieCwgYnkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYodGhpcy5Db250YWluc1BvaW50KHAsIGF4LCBheSkgfHwgdGhpcy5Db250YWluc1BvaW50KHAsIGJ4LCBieSkpIHJldHVybiBbcC5zbGljZSgwKV07XHJcblxyXG4gICAgICAgIHZhciBhID0gbmV3IHRoaXMuX1AoYXgsIGF5KTtcclxuICAgICAgICB2YXIgYiA9IG5ldyB0aGlzLl9QKGJ4LCBieSk7XHJcbiAgICAgICAgdmFyIGlzY3MgPSBbXTsgIC8vIGludGVyc2VjdGlvbnNcclxuICAgICAgICB2YXIgcHMgPSBbXTsgICAgLy8gcG9pbnRzXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpIHBzLnB1c2gobmV3IHRoaXMuX1AocFtpXSwgcFtpKzFdKSk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGlzYyA9IG5ldyB0aGlzLl9QKDAsMCk7XHJcbiAgICAgICAgICAgIGlzYyA9IHRoaXMuX0dldExpbmVJbnRlcnNlY3Rpb24oYSwgYiwgcHNbaV0sIHBzWyhpKzEpJXBzLmxlbmd0aF0sIGlzYyk7XHJcblxyXG4gICAgICAgICAgICBpZihpc2MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlzYy5mbGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlzY3MucHVzaChpc2MpO1xyXG4gICAgICAgICAgICAgICAgcHMuc3BsaWNlKGkrMSwwLGlzYyk7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoaXNjcy5sZW5ndGggPT0gMCkgcmV0dXJuIFtwLnNsaWNlKDApXTtcclxuICAgICAgICB2YXIgY29tcCh1LHYpIHtyZXR1cm4gdGhpcy5fUC5kaXN0KGEsdSkgLSB0aGlzLl9QLmRpc3QoYSx2KTsgfVxyXG4gICAgICAgIGlzY3Muc29ydChjb21wKTtcclxuXHJcbiAgICAgICAgdmFyIHBncyA9IFtdO1xyXG4gICAgICAgIHZhciBkaXIgPSAwO1xyXG4gICAgICAgIHdoaWxlKGlzY3MubGVuZ3RoID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaTAgPSBpc2NzWzBdO1xyXG4gICAgICAgICAgICB2YXIgaTEgPSBpc2NzWzFdO1xyXG4gICAgICAgICAgICB2YXIgaW5kMCA9IHBzLmluZGV4T2YoaTApO1xyXG4gICAgICAgICAgICB2YXIgaW5kMSA9IHBzLmluZGV4T2YoaTEpO1xyXG4gICAgICAgICAgICB2YXIgc29sdmVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLl9maXJzdFdpdGhGbGFnKHBzLCBpbmQwKSA9PSBpbmQxKSBzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGkwID0gaXNjc1sxXTtcclxuICAgICAgICAgICAgICAgIGkxID0gaXNjc1swXTtcclxuICAgICAgICAgICAgICAgIGluZDAgPSBwcy5pbmRleE9mKGkwKTtcclxuICAgICAgICAgICAgICAgIGluZDEgPSBwcy5pbmRleE9mKGkxKTtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX2ZpcnN0V2l0aEZsYWcocHMsIGluZDApID09IGluZDEpIHNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc29sdmVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaXItLTtcclxuICAgICAgICAgICAgICAgIHZhciBwZ24gPSB0aGlzLl9nZXRQb2ludHMocHMsIGluZDAsIGluZDEpO1xyXG4gICAgICAgICAgICAgICAgcGdzLnB1c2gocGduKTtcclxuICAgICAgICAgICAgICAgIHBzID0gdGhpcy5fZ2V0UG9pbnRzKHBzLCBpbmQxLCBpbmQwKTtcclxuICAgICAgICAgICAgICAgIGkwLmZsYWcgPSBpMS5mbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpc2NzLnNwbGljZSgwLDIpO1xyXG4gICAgICAgICAgICAgICAgaWYoaXNjcy5sZW5ndGggPT0gMCkgcGdzLnB1c2gocHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgeyBkaXIrKzsgaXNjcy5yZXZlcnNlKCk7IH1cclxuICAgICAgICAgICAgaWYoZGlyPjEpIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cGdzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHBnID0gcGdzW2ldO1xyXG4gICAgICAgICAgICB2YXIgbnBnID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHBnLmxlbmd0aDsgaisrKSBucGcucHVzaChwZ1tqXS54LCBwZ1tqXS55KTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnBnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBSYXljYXN0KHAsIHgsIHksIGR4LCBkeSwgaXNjKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSAyO1xyXG4gICAgICAgIHZhciB0cCA9IHRoaXMuX3RwO1xyXG4gICAgICAgIHZhciBhMSA9IHRwWzBdLCBhMiA9IHRwWzFdLFxyXG4gICAgICAgIGIxID0gdHBbMl0sIGIyID0gdHBbM10sIGMgPSB0cFs0XTtcclxuICAgICAgICBhMS54ID0geDsgYTEueSA9IHk7XHJcbiAgICAgICAgYTIueCA9IHgrZHg7IGEyLnkgPSB5K2R5O1xyXG5cclxuICAgICAgICBpZihpc2M9PW51bGwpIGlzYyA9IHtkaXN0OjAsIGVkZ2U6MCwgbm9ybTp7eDowLCB5OjB9LCByZWZsOnt4OjAsIHk6MH19O1xyXG4gICAgICAgIGlzYy5kaXN0ID0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiMS54ID0gcFtpICBdOyAgYjEueSA9IHBbaSsxXTtcclxuICAgICAgICAgICAgYjIueCA9IHBbaSsyXTsgIGIyLnkgPSBwW2krM107XHJcbiAgICAgICAgICAgIHZhciBuaXNjID0gdGhpcy5fUmF5TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYyk7XHJcbiAgICAgICAgICAgIGlmKG5pc2MpIHRoaXMuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIGkvMiwgaXNjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYjEueCA9IGIyLng7ICBiMS55ID0gYjIueTtcclxuICAgICAgICBiMi54ID0gcFswXTsgIGIyLnkgPSBwWzFdO1xyXG4gICAgICAgIHZhciBuaXNjID0gdGhpcy5fUmF5TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYyk7XHJcbiAgICAgICAgaWYobmlzYykgdGhpcy5fdXBkYXRlSVNDKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgcC5sZW5ndGgvMiwgaXNjKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChpc2MuZGlzdCAhPSBJbmZpbml0eSkgPyBpc2MgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIENsb3Nlc3RFZGdlKHAsIHgsIHksIGlzYylcclxuICAgIHtcclxuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcclxuICAgICAgICB2YXIgdHAgPSB0aGlzLl90cDtcclxuICAgICAgICB2YXIgYTEgPSB0cFswXSxcclxuICAgICAgICBiMSA9IHRwWzJdLCBiMiA9IHRwWzNdLCBjID0gdHBbNF07XHJcbiAgICAgICAgYTEueCA9IHg7IGExLnkgPSB5O1xyXG5cclxuICAgICAgICBpZihpc2M9PW51bGwpIGlzYyA9IHtkaXN0OjAsIGVkZ2U6MCwgcG9pbnQ6e3g6MCwgeTowfSwgbm9ybTp7eDowLCB5OjB9fTtcclxuICAgICAgICBpc2MuZGlzdCA9IEluZmluaXR5O1xyXG5cclxuICAgICAgICBmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYjEueCA9IHBbaSAgXTsgIGIxLnkgPSBwW2krMV07XHJcbiAgICAgICAgICAgIGIyLnggPSBwW2krMl07ICBiMi55ID0gcFtpKzNdO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludExpbmVEaXN0KGExLCBiMSwgYjIsIGk+PjEsIGlzYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGIxLnggPSBiMi54OyAgYjEueSA9IGIyLnk7XHJcbiAgICAgICAgYjIueCA9IHBbMF07ICBiMi55ID0gcFsxXTtcclxuICAgICAgICB0aGlzLl9wb2ludExpbmVEaXN0KGExLCBiMSwgYjIsIGw+PjEsIGlzYyk7XHJcblxyXG4gICAgICAgIHZhciBpZHN0ID0gMS9pc2MuZGlzdDtcclxuICAgICAgICBpc2Mubm9ybS54ID0gKHgtaXNjLnBvaW50LngpKmlkc3Q7XHJcbiAgICAgICAgaXNjLm5vcm0ueSA9ICh5LWlzYy5wb2ludC55KSppZHN0O1xyXG4gICAgICAgIHJldHVybiBpc2M7XHJcbiAgICB9XHJcblxyXG4gICAgX3BvaW50TGluZURpc3QocCwgYSwgYiwgZWRnZSwgaXNjKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4ID0gcC54LCB5ID0gcC55LCB4MSA9IGEueCwgeTEgPSBhLnksIHgyID0gYi54LCB5MiA9IGIueTtcclxuXHJcbiAgICAgICAgdmFyIEEgPSB4IC0geDE7XHJcbiAgICAgICAgdmFyIEIgPSB5IC0geTE7XHJcbiAgICAgICAgdmFyIEMgPSB4MiAtIHgxO1xyXG4gICAgICAgIHZhciBEID0geTIgLSB5MTtcclxuXHJcbiAgICAgICAgdmFyIGRvdCA9IEEgKiBDICsgQiAqIEQ7XHJcbiAgICAgICAgdmFyIGxlbl9zcSA9IEMgKiBDICsgRCAqIEQ7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gZG90IC8gbGVuX3NxO1xyXG5cclxuICAgICAgICB2YXIgeHgsIHl5O1xyXG5cclxuICAgICAgICBpZiAocGFyYW0gPCAwIHx8ICh4MSA9PSB4MiAmJiB5MSA9PSB5MikpIHtcclxuICAgICAgICAgICAgeHggPSB4MTtcclxuICAgICAgICAgICAgeXkgPSB5MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyYW0gPiAxKSB7XHJcbiAgICAgICAgICAgIHh4ID0geDI7XHJcbiAgICAgICAgICAgIHl5ID0geTI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB4eCA9IHgxICsgcGFyYW0gKiBDO1xyXG4gICAgICAgICAgICB5eSA9IHkxICsgcGFyYW0gKiBEO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGR4ID0geCAtIHh4O1xyXG4gICAgICAgIHZhciBkeSA9IHkgLSB5eTtcclxuICAgICAgICB2YXIgZHN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgICAgICBpZihkc3Q8aXNjLmRpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpc2MuZGlzdCA9IGRzdDtcclxuICAgICAgICAgICAgaXNjLmVkZ2UgPSBlZGdlO1xyXG4gICAgICAgICAgICBpc2MucG9pbnQueCA9IHh4O1xyXG4gICAgICAgICAgICBpc2MucG9pbnQueSA9IHl5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfdXBkYXRlSVNDKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgZWRnZSwgaXNjKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBucmwgPSB0aGlzLl9QLmRpc3QoYTEsIGMpO1xyXG4gICAgICAgIGlmKG5ybDxpc2MuZGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpYmwgPSAxL3RoaXMuX1AuZGlzdChiMSwgYjIpO1xyXG4gICAgICAgICAgICB2YXIgbnggPSAtKGIyLnktYjEueSkqaWJsO1xyXG4gICAgICAgICAgICB2YXIgbnkgPSAgKGIyLngtYjEueCkqaWJsO1xyXG4gICAgICAgICAgICB2YXIgZGRvdCA9IDIqKGR4Km54K2R5Km55KTtcclxuICAgICAgICAgICAgaXNjLmRpc3QgPSBucmw7XHJcbiAgICAgICAgICAgIGlzYy5ub3JtLnggPSBueDtcclxuICAgICAgICAgICAgaXNjLm5vcm0ueSA9IG55O1xyXG4gICAgICAgICAgICBpc2MucmVmbC54ID0gLWRkb3QqbngrZHg7XHJcbiAgICAgICAgICAgIGlzYy5yZWZsLnkgPSAtZGRvdCpueStkeTtcclxuICAgICAgICAgICAgaXNjLmVkZ2UgPSBlZGdlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfZ2V0UG9pbnRzKHBzLCBpbmQwLCBpbmQxKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBucHMgPSBbXTtcclxuICAgICAgICBpZihpbmQxPGluZDApIGluZDEgKz0gbjtcclxuICAgICAgICBmb3IodmFyIGk9aW5kMDsgaTw9IGluZDE7IGkrKykgbnBzLnB1c2gocHNbaSVuXSk7XHJcbiAgICAgICAgcmV0dXJuIG5wcztcclxuICAgIH1cclxuXHJcbiAgICBfZmlyc3RXaXRoRmxhZyhwcywgaW5kKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlKHRydWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbmQgPSAoaW5kKzEpJW47XHJcbiAgICAgICAgICAgIGlmKHBzW2luZF0uZmxhZykgcmV0dXJuIGluZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgUG9seUsucHJvdG90eXBlLl9Qb2ludEluVHJpYW5nbGUgPSBmdW5jdGlvbiAocHgsIHB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KSB7XHJcbiAgICAgICAgdmFyIHYweCA9IGN4IC0gYXg7XHJcbiAgICAgICAgdmFyIHYweSA9IGN5IC0gYXk7XHJcbiAgICAgICAgdmFyIHYxeCA9IGJ4IC0gYXg7XHJcbiAgICAgICAgdmFyIHYxeSA9IGJ5IC0gYXk7XHJcbiAgICAgICAgdmFyIHYyeCA9IHB4IC0gYXg7XHJcbiAgICAgICAgdmFyIHYyeSA9IHB5IC0gYXk7XHJcbiAgICAgICAgdmFyIGRvdDAwID0gdjB4ICogdjB4ICsgdjB5ICogdjB5O1xyXG4gICAgICAgIHZhciBkb3QwMSA9IHYweCAqIHYxeCArIHYweSAqIHYxeTtcclxuICAgICAgICB2YXIgZG90MDIgPSB2MHggKiB2MnggKyB2MHkgKiB2Mnk7XHJcbiAgICAgICAgdmFyIGRvdDExID0gdjF4ICogdjF4ICsgdjF5ICogdjF5O1xyXG4gICAgICAgIHZhciBkb3QxMiA9IHYxeCAqIHYyeCArIHYxeSAqIHYyeTtcclxuICAgICAgICB2YXIgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKTtcclxuICAgICAgICB2YXIgdSA9IChkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMikgKiBpbnZEZW5vbTtcclxuICAgICAgICB2YXIgdiA9IChkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMikgKiBpbnZEZW5vbTtcclxuICAgICAgICAvLyBDaGVjayBpZiBwb2ludCBpcyBpbiB0cmlhbmdsZVxyXG4gICAgICAgIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgX1JheUxpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcclxuICAgICAgICB2YXIgZGF5ID0gKGExLnktYTIueSksIGRieSA9IChiMS55LWIyLnkpO1xyXG5cclxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XHJcbiAgICAgICAgaWYgKERlbiA9PSAwKSByZXR1cm4gbnVsbDsgIC8vIHBhcmFsbGVsXHJcblxyXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xyXG4gICAgICAgIHZhciBCID0gKGIxLnggKiBiMi55IC0gYjEueSAqIGIyLngpO1xyXG5cclxuICAgICAgICB2YXIgSSA9IGM7XHJcbiAgICAgICAgdmFyIGlEZW4gPSAxL0RlbjtcclxuICAgICAgICBJLnggPSAoIEEqZGJ4IC0gZGF4KkIgKSAqIGlEZW47XHJcbiAgICAgICAgSS55ID0gKCBBKmRieSAtIGRheSpCICkgKiBpRGVuO1xyXG5cclxuICAgICAgICBpZighdGhpcy5fSW5SZWN0KEksIGIxLCBiMikpIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmKChkYXk+MCAmJiBJLnk+YTEueSkgfHwgKGRheTwwICYmIEkueTxhMS55KSkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYoKGRheD4wICYmIEkueD5hMS54KSB8fCAoZGF4PDAgJiYgSS54PGExLngpKSByZXR1cm4gbnVsbDtcclxuICAgICAgICByZXR1cm4gSTtcclxuICAgIH1cclxuXHJcbiAgICBfR2V0TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYylcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF4ID0gKGExLngtYTIueCksIGRieCA9IChiMS54LWIyLngpO1xyXG4gICAgICAgIHZhciBkYXkgPSAoYTEueS1hMi55KSwgZGJ5ID0gKGIxLnktYjIueSk7XHJcblxyXG4gICAgICAgIHZhciBEZW4gPSBkYXgqZGJ5IC0gZGF5KmRieDtcclxuICAgICAgICBpZiAoRGVuID09IDApIHJldHVybiBudWxsOyAgLy8gcGFyYWxsZWxcclxuXHJcbiAgICAgICAgdmFyIEEgPSAoYTEueCAqIGEyLnkgLSBhMS55ICogYTIueCk7XHJcbiAgICAgICAgdmFyIEIgPSAoYjEueCAqIGIyLnkgLSBiMS55ICogYjIueCk7XHJcblxyXG4gICAgICAgIHZhciBJID0gYztcclxuICAgICAgICBJLnggPSAoIEEqZGJ4IC0gZGF4KkIgKSAvIERlbjtcclxuICAgICAgICBJLnkgPSAoIEEqZGJ5IC0gZGF5KkIgKSAvIERlbjtcclxuXHJcbiAgICAgICAgaWYodGhpcy5fSW5SZWN0KEksIGExLCBhMikgJiYgdGhpcy5fSW5SZWN0KEksIGIxLCBiMikpIHJldHVybiBJO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIF9JblJlY3QoYSwgYiwgYylcclxuICAgIHtcclxuICAgICAgICBpZiAgKGIueCA9PSBjLngpIHJldHVybiAoYS55Pj1NYXRoLm1pbihiLnksIGMueSkgJiYgYS55PD1NYXRoLm1heChiLnksIGMueSkpO1xyXG4gICAgICAgIGlmICAoYi55ID09IGMueSkgcmV0dXJuIChhLng+PU1hdGgubWluKGIueCwgYy54KSAmJiBhLng8PU1hdGgubWF4KGIueCwgYy54KSk7XHJcblxyXG4gICAgICAgIGlmKGEueCA+PSBNYXRoLm1pbihiLngsIGMueCkgJiYgYS54IDw9IE1hdGgubWF4KGIueCwgYy54KVxyXG4gICAgICAgICYmIGEueSA+PSBNYXRoLm1pbihiLnksIGMueSkgJiYgYS55IDw9IE1hdGgubWF4KGIueSwgYy55KSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgUG9seUsucHJvdG90eXBlLl9jb252ZXggPSBmdW5jdGlvbiAoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkge1xyXG4gICAgICAgIHJldHVybiAoYXkgLSBieSkgKiAoY3ggLSBieCkgKyAoYnggLSBheCkgKiAoY3kgLSBieSkgPj0gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUG9seUs7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBQb2x5SygpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuXHJcblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuXHJcbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcclxuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcblxyXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcclxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcclxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxyXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxyXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcclxuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xyXG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cclxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcclxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXHJcbi8qKlxyXG4gKiBUaGUgdmVjMiBvYmplY3QgZnJvbSBnbE1hdHJpeCwgd2l0aCBzb21lIGV4dGVuc2lvbnMgYW5kIHNvbWUgcmVtb3ZlZCBtZXRob2RzLiBTZWUgaHR0cDovL2dsbWF0cml4Lm5ldC5cclxuICogQGNsYXNzIHZlYzJcclxuICovXHJcbnZhciBWZWMyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmVjMigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFrZSBhIGNyb3NzIHByb2R1Y3QgYW5kIG9ubHkgcmV0dXJuIHRoZSB6IGNvbXBvbmVudFxyXG4gICAgICogQG1ldGhvZCBjcm9zc0xlbmd0aFxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBiXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLmNyb3NzTGVuZ3RoID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyb3NzIHByb2R1Y3QgYmV0d2VlbiBhIHZlY3RvciBhbmQgdGhlIFogY29tcG9uZW50IG9mIGEgdmVjdG9yXHJcbiAgICAgKiBAbWV0aG9kIGNyb3NzVlpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSB2ZWNcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gemNvbXBcclxuICAgICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5jcm9zc1ZaID0gZnVuY3Rpb24gKG91dCwgdmVjLCB6Y29tcCkge1xyXG4gICAgICAgIHRoaXMucm90YXRlKG91dCwgdmVjLCAtTWF0aC5QSSAvIDIpOyAvLyBSb3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByaWdodCBoYW5kIHJ1bGVcclxuICAgICAgICB0aGlzLnNjYWxlKG91dCwgb3V0LCB6Y29tcCk7IC8vIFNjYWxlIHdpdGggelxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcm9zcyBwcm9kdWN0IGJldHdlZW4gYSB2ZWN0b3IgYW5kIHRoZSBaIGNvbXBvbmVudCBvZiBhIHZlY3RvclxyXG4gICAgICogQG1ldGhvZCBjcm9zc1pWXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHpjb21wXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gdmVjXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuY3Jvc3NaViA9IGZ1bmN0aW9uIChvdXQsIHpjb21wLCB2ZWMpIHtcclxuICAgICAgICB0aGlzLnJvdGF0ZShvdXQsIHZlYywgTWF0aC5QSSAvIDIpOyAvLyBSb3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByaWdodCBoYW5kIHJ1bGVcclxuICAgICAgICB0aGlzLnNjYWxlKG91dCwgb3V0LCB6Y29tcCk7IC8vIFNjYWxlIHdpdGggelxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGUgYSB2ZWN0b3IgYnkgYW4gYW5nbGVcclxuICAgICAqIEBtZXRob2Qgcm90YXRlXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIGFuZ2xlKSB7XHJcbiAgICAgICAgaWYgKGFuZ2xlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpLCBzID0gTWF0aC5zaW4oYW5nbGUpLCB4ID0gYVswXSwgeSA9IGFbMV07XHJcbiAgICAgICAgICAgIG91dFswXSA9IGMgKiB4IC0gcyAqIHk7XHJcbiAgICAgICAgICAgIG91dFsxXSA9IHMgKiB4ICsgYyAqIHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgICAgICAgICBvdXRbMV0gPSBhWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlIGEgdmVjdG9yIDkwIGRlZ3JlZXMgY2xvY2t3aXNlXHJcbiAgICAgKiBAbWV0aG9kIHJvdGF0ZTkwY3dcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUucm90YXRlOTBjdyA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcclxuICAgICAgICB2YXIgeCA9IGFbMF07XHJcbiAgICAgICAgdmFyIHkgPSBhWzFdO1xyXG4gICAgICAgIG91dFswXSA9IHk7XHJcbiAgICAgICAgb3V0WzFdID0gLXg7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSBhIHBvaW50IHBvc2l0aW9uIHRvIGxvY2FsIGZyYW1lLlxyXG4gICAgICogQG1ldGhvZCB0b0xvY2FsRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFBvaW50XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gZnJhbWVQb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUudG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24gKG91dCwgd29ybGRQb2ludCwgZnJhbWVQb3NpdGlvbiwgZnJhbWVBbmdsZSkge1xyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoLWZyYW1lQW5nbGUpLCBzID0gTWF0aC5zaW4oLWZyYW1lQW5nbGUpLCB4ID0gd29ybGRQb2ludFswXSAtIGZyYW1lUG9zaXRpb25bMF0sIHkgPSB3b3JsZFBvaW50WzFdIC0gZnJhbWVQb3NpdGlvblsxXTtcclxuICAgICAgICBvdXRbMF0gPSBjICogeCAtIHMgKiB5O1xyXG4gICAgICAgIG91dFsxXSA9IHMgKiB4ICsgYyAqIHk7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSBhIHBvaW50IHBvc2l0aW9uIHRvIGdsb2JhbCBmcmFtZS5cclxuICAgICAqIEBtZXRob2QgdG9HbG9iYWxGcmFtZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGxvY2FsUG9pbnRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBmcmFtZVBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZyYW1lQW5nbGVcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUudG9HbG9iYWxGcmFtZSA9IGZ1bmN0aW9uIChvdXQsIGxvY2FsUG9pbnQsIGZyYW1lUG9zaXRpb24sIGZyYW1lQW5nbGUpIHtcclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKGZyYW1lQW5nbGUpLCBzID0gTWF0aC5zaW4oZnJhbWVBbmdsZSksIHggPSBsb2NhbFBvaW50WzBdLCB5ID0gbG9jYWxQb2ludFsxXSwgYWRkWCA9IGZyYW1lUG9zaXRpb25bMF0sIGFkZFkgPSBmcmFtZVBvc2l0aW9uWzFdO1xyXG4gICAgICAgIG91dFswXSA9IGMgKiB4IC0gcyAqIHkgKyBhZGRYO1xyXG4gICAgICAgIG91dFsxXSA9IHMgKiB4ICsgYyAqIHkgKyBhZGRZO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIGEgdmVjdG9yIHRvIGxvY2FsIGZyYW1lLlxyXG4gICAgICogQG1ldGhvZCB2ZWN0b3JUb0xvY2FsRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFZlY3RvclxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUudmVjdG9yVG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24gKG91dCwgd29ybGRWZWN0b3IsIGZyYW1lQW5nbGUpIHtcclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKC1mcmFtZUFuZ2xlKSwgcyA9IE1hdGguc2luKC1mcmFtZUFuZ2xlKSwgeCA9IHdvcmxkVmVjdG9yWzBdLCB5ID0gd29ybGRWZWN0b3JbMV07XHJcbiAgICAgICAgb3V0WzBdID0gYyAqIHggLSBzICogeTtcclxuICAgICAgICBvdXRbMV0gPSBzICogeCArIGMgKiB5O1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLypcclxuICAgICAqIFRyYW5zZm9ybSBhIHZlY3RvciB0byBnbG9iYWwgZnJhbWUuXHJcbiAgICAgKiBAbWV0aG9kIHZlY3RvclRvR2xvYmFsRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBsb2NhbFZlY3RvclxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXHJcbiAgICAgKi9cclxuICAgIC8vdmVjdG9yVG9HbG9iYWxGcmFtZSA9IHZlYzIucm90YXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIGNlbnRyb2lkIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB2ZWN0b3JzIGEsYixjLiBTZWUgaHR0cDovL2Vhc3ljYWxjdWxhdGlvbi5jb20vYW5hbHl0aWNhbC9sZWFybi1jZW50cm9pZC5waHBcclxuICAgICAqIEBtZXRob2QgY2VudHJvaWRcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYlxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGNcclxuICAgICAqIEByZXR1cm4gIHtBcnJheX0gVGhlIFwib3V0XCIgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5jZW50cm9pZCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMpIHtcclxuICAgICAgICB0aGlzLmFkZChvdXQsIGEsIGIpO1xyXG4gICAgICAgIHRoaXMuYWRkKG91dCwgb3V0LCBjKTtcclxuICAgICAgICB0aGlzLnNjYWxlKG91dCwgb3V0LCAxIC8gMyk7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgMkQgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuICAgICAgICBvdXRbMF0gPSAwO1xyXG4gICAgICAgIG91dFsxXSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBjbG9uZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4gICAgICAgIG91dFswXSA9IGFbMF07XHJcbiAgICAgICAgb3V0WzFdID0gYVsxXTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBmcm9tVmFsdWVzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICAgICAgb3V0WzBdID0geDtcclxuICAgICAgICBvdXRbMV0gPSB5O1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGNvcHlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IG91dFxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKG91dCwgYSkge1xyXG4gICAgICAgIG91dFswXSA9IGFbMF07XHJcbiAgICAgICAgb3V0WzFdID0gYVsxXTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIHNldFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvdXRcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG91dCwgeCwgeSkge1xyXG4gICAgICAgIG91dFswXSA9IHg7XHJcbiAgICAgICAgb3V0WzFdID0geTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0d28gdmVjMidzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGFkZFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IG91dFxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XHJcbiAgICAgICAgb3V0WzBdID0gYVswXSArIGJbMF07XHJcbiAgICAgICAgb3V0WzFdID0gYVsxXSArIGJbMV07XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN1YnRyYWN0cyB0d28gdmVjMidzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIHN1YnRyYWN0XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3V0XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xyXG4gICAgICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgbXVsdGlwbHlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvdXRcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XHJcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGJbMF07XHJcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERpdmlkZXMgdHdvIHZlYzInc1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBkaXZpZGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvdXRcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xyXG4gICAgICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBzY2FsZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3V0XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xyXG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBiO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBiO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGRpc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHZhciB4ID0gYlswXSAtIGFbMF0sIHkgPSBiWzFdIC0gYVsxXTtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIHNxdWFyZWREaXN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLCB5ID0gYlsxXSAtIGFbMV07XHJcbiAgICAgICAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGxlbmd0aFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV07XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBzcXVhcmVkTGVuZ3RoXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdO1xyXG4gICAgICAgIHJldHVybiB4ICogeCArIHkgKiB5O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgbmVnYXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IG91dFxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAob3V0LCBhKSB7XHJcbiAgICAgICAgb3V0WzBdID0gLWFbMF07XHJcbiAgICAgICAgb3V0WzFdID0gLWFbMV07XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZSBhIHZlYzJcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2Qgbm9ybWFsaXplXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IG91dFxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAob3V0LCBhKSB7XHJcbiAgICAgICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXTtcclxuICAgICAgICB2YXIgbGVuID0geCAqIHggKyB5ICogeTtcclxuICAgICAgICBpZiAobGVuID4gMCkge1xyXG4gICAgICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xyXG4gICAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XHJcbiAgICAgICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XHJcbiAgICAgICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGRvdFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBzdHJcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnN0ciA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgdGhyb3cgXCJ2ZWMyLnN0ciBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSB0eXBlc2NyaXB0IHZlcnNpb24gb2YgcDIuXCI7XHJcbiAgICAgICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lYXJseSBpbnRlcnBvbGF0ZS9taXggdHdvIHZlY3RvcnMuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGxlcnBcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSBGaXJzdCB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGIgU2Vjb25kIHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgTGVycCBmYWN0b3JcclxuICAgICAqIEByZXR1cm4ge2FycmF5fVxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xyXG4gICAgICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXTtcclxuICAgICAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcclxuICAgICAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVmbGVjdCBhIHZlY3RvciBhbG9uZyBhIG5vcm1hbC5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgcmVmbGVjdFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5vcm1hbFxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5yZWZsZWN0ID0gZnVuY3Rpb24gKG91dCwgdmVjdG9yLCBub3JtYWwpIHtcclxuICAgICAgICB2YXIgZG90ID0gdmVjdG9yWzBdICogbm9ybWFsWzBdICsgdmVjdG9yWzFdICogbm9ybWFsWzFdO1xyXG4gICAgICAgIG91dFswXSA9IHZlY3RvclswXSAtIDIgKiBub3JtYWxbMF0gKiBkb3Q7XHJcbiAgICAgICAgb3V0WzFdID0gdmVjdG9yWzFdIC0gMiAqIG5vcm1hbFsxXSAqIGRvdDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGJldHdlZW4gdHdvIGxpbmUgc2VnbWVudHMuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvblxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAwXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDFcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMlxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAzXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcnNlY3Rpb24sIG90aGVyd2lzZSBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKG91dCwgcDAsIHAxLCBwMiwgcDMpIHtcclxuICAgICAgICB2YXIgdCA9IHZlYzIuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb24ocDAsIHAxLCBwMiwgcDMpO1xyXG4gICAgICAgIGlmICh0IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRbMF0gPSBwMFswXSArICh0ICogKHAxWzBdIC0gcDBbMF0pKTtcclxuICAgICAgICAgICAgb3V0WzFdID0gcDBbMV0gKyAodCAqIChwMVsxXSAtIHAwWzFdKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaW50ZXJzZWN0aW9uIGZyYWN0aW9uIGJldHdlZW4gdHdvIGxpbmUgc2VnbWVudHMuIElmIHN1Y2Nlc3NmdWwsIHRoZSBpbnRlcnNlY3Rpb24gaXMgYXQgcDAgKyB0ICogKHAxIC0gcDApXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbkZyYWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDBcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAyXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDNcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIGlmIHRoZXJlIHdhcyBhbiBpbnRlcnNlY3Rpb24sIG90aGVyd2lzZSAtMS5cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb24gPSBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMpIHtcclxuICAgICAgICB2YXIgczFfeCA9IHAxWzBdIC0gcDBbMF07XHJcbiAgICAgICAgdmFyIHMxX3kgPSBwMVsxXSAtIHAwWzFdO1xyXG4gICAgICAgIHZhciBzMl94ID0gcDNbMF0gLSBwMlswXTtcclxuICAgICAgICB2YXIgczJfeSA9IHAzWzFdIC0gcDJbMV07XHJcbiAgICAgICAgdmFyIHMsIHQ7XHJcbiAgICAgICAgcyA9ICgtczFfeSAqIChwMFswXSAtIHAyWzBdKSArIHMxX3ggKiAocDBbMV0gLSBwMlsxXSkpIC8gKC1zMl94ICogczFfeSArIHMxX3ggKiBzMl95KTtcclxuICAgICAgICB0ID0gKHMyX3ggKiAocDBbMV0gLSBwMlsxXSkgLSBzMl95ICogKHAwWzBdIC0gcDJbMF0pKSAvICgtczJfeCAqIHMxX3kgKyBzMV94ICogczJfeSk7XHJcbiAgICAgICAgaWYgKHMgPj0gMCAmJiBzIDw9IDEgJiYgdCA+PSAwICYmIHQgPD0gMSkgeyAvLyBDb2xsaXNpb24gZGV0ZWN0ZWRcclxuICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTsgLy8gTm8gY29sbGlzaW9uXHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIFZlYzI7XHJcbn0oKSk7XHJcbnZhciB2ZWMyID0gbmV3IFZlYzIoKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gdmVjMjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIGFkZCA9IHZlYzJfMS5kZWZhdWx0LmFkZCwgc3ViID0gdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QsIHZlYzJjcmVhdGUgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGU7XHJcbnZhciBhYWJiXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2NvbGxpc2lvbi9hYWJiXCIpKTtcclxudmFyIHBvbHlfZGVjb21wXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvcG9seS1kZWNvbXBcIikpO1xyXG52YXIgQ29udmV4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYXBlcy9Db252ZXhcIikpO1xyXG52YXIgcmF5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2NvbGxpc2lvbi9yYXlcIikpO1xyXG52YXIgcmF5Y2FzdF9yZXN1bHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vY29sbGlzaW9uL3JheWNhc3QtcmVzdWx0XCIpKTtcclxudmFyIGV2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXZlbnRzL2V2ZW50LWVtaXR0ZXJcIikpO1xyXG4vL2RlY29tcCA9IHJlcXVpcmUoJ3BvbHktZGVjb21wJylcclxudmFyIGludGVncmF0ZV9maE1pbnYgPSB2ZWMyY3JlYXRlKCk7XHJcbnZhciBpbnRlZ3JhdGVfdmVsb2R0ID0gdmVjMmNyZWF0ZSgpO1xyXG52YXIgX3RtcCA9IHZlYzJjcmVhdGUoKTtcclxudmFyIF9pZENvdW50ZXIgPSAwO1xyXG52YXIgQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCb2R5LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJpZ2lkIGJvZHkuIEhhcyBnb3QgYSBjZW50ZXIgb2YgbWFzcywgcG9zaXRpb24sIHZlbG9jaXR5IGFuZCBhIG51bWJlciBvZlxyXG4gICAgICogc2hhcGVzIHRoYXQgYXJlIHVzZWQgZm9yIGNvbGxpc2lvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIEJvZHlcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U2xlZXA9dHJ1ZV1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZT0wXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ3VsYXJEYW1waW5nPTAuMV1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmd1bGFyRm9yY2U9MF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmd1bGFyVmVsb2NpdHk9MF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jY2RJdGVyYXRpb25zPTEwXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNjZFNwZWVkVGhyZXNob2xkPS0xXVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZV1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nPTAuMV1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZml4ZWRSb3RhdGlvbj1mYWxzZV1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZml4ZWRYPWZhbHNlXVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maXhlZFk9ZmFsc2VdXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5mb3JjZV1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ncmF2aXR5U2NhbGU9MV1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXNzPTBdIEEgbnVtYmVyID49IDAuIElmIHplcm8sIHRoZSAudHlwZSB3aWxsIGJlIHNldCB0byBCb2R5LlNUQVRJQy5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnBvc2l0aW9uXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNsZWVwU3BlZWRMaW1pdF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zbGVlcFRpbWVMaW1pdF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50eXBlXSBTZWUge3sjY3Jvc3NMaW5rIFwiQm9keS90eXBlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy52ZWxvY2l0eV1cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBDcmVhdGUgYSB0eXBpY2FsIGR5bmFtaWMgYm9keVxyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoe1xyXG4gICAgICogICAgICAgICBtYXNzOiAxLCAvLyBub24temVybyBtYXNzIHdpbGwgc2V0IHR5cGUgdG8gQm9keS5EWU5BTUlDXHJcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiBbMCwgNV0sXHJcbiAgICAgKiAgICAgICAgIGFuZ2xlOiAwLFxyXG4gICAgICogICAgICAgICB2ZWxvY2l0eTogWzAsIDBdLFxyXG4gICAgICogICAgICAgICBhbmd1bGFyVmVsb2NpdHk6IDBcclxuICAgICAqICAgICB9KTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gQWRkIGEgY2lyY3VsYXIgc2hhcGUgdG8gdGhlIGJvZHlcclxuICAgICAqICAgICB2YXIgY2lyY2xlU2hhcGUgPSBuZXcgQ2lyY2xlKHsgcmFkaXVzOiAwLjUgfSk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShjaXJjbGVTaGFwZSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIEFkZCB0aGUgYm9keSB0byB0aGUgd29ybGRcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIENyZWF0ZSBhIHN0YXRpYyBwbGFuZSBib2R5XHJcbiAgICAgKiAgICAgdmFyIHBsYW5lQm9keSA9IG5ldyBCb2R5KHtcclxuICAgICAqICAgICAgICAgbWFzczogMCwgLy8gemVybyBtYXNzIHdpbGwgc2V0IHR5cGUgdG8gQm9keS5TVEFUSUNcclxuICAgICAqICAgICAgICAgcG9zaXRpb246IFswLCAwXVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHZhciBwbGFuZVNoYXBlID0gbmV3IFBsYW5lKCk7XHJcbiAgICAgKiAgICAgcGxhbmVCb2R5LmFkZFNoYXBlKHBsYW5lU2hhcGUpO1xyXG4gICAgICogICAgIHdvcmxkLmFkZEJvZHkocGxhbmVCb2R5KTtcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBDcmVhdGUgYSBtb3Zpbmcga2luZW1hdGljIGJveCBib2R5XHJcbiAgICAgKiAgICAgdmFyIHBsYXRmb3JtQm9keSA9IG5ldyBCb2R5KHtcclxuICAgICAqICAgICAgICAgdHlwZTogQm9keS5LSU5FTUFUSUMsXHJcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiBbMCwgM10sXHJcbiAgICAgKiAgICAgICAgIHZlbG9jaXR5OiBbMSwgMF1cclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB2YXIgYm94U2hhcGUgPSBuZXcgQm94KHsgd2lkdGg6IDIsIGhlaWdodDogMC41IH0pO1xyXG4gICAgICogICAgIHBsYXRmb3JtQm9keS5hZGRTaGFwZShib3hTaGFwZSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQm9keShwbGF0Zm9ybUJvZHkpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCb2R5KG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGJvZHkgaWRlbnRpZmllci4gUmVhZCBvbmx5IVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBpZFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5pZCA9IC0xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGV4IG9mIHRoZSBib2R5IGluIHRoZSBXb3JsZCAuYm9kaWVzIGFycmF5LiBJcyBzZXQgdG8gLTEgaWYgdGhlIGJvZHkgaXNuJ3QgYWRkZWQgdG8gYSBXb3JsZC5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgaW5kZXhcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmluZGV4ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgd29ybGQgdGhhdCB0aGlzIGJvZHkgaXMgYWRkZWQgdG8gKHJlYWQgb25seSkuIFRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIE5VTEwgaWYgdGhlIGJvZHkgaXMgbm90IGFkZGVkIHRvIGFueSB3b3JsZC5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgd29ybGRcclxuICAgICAgICAgKiBAdHlwZSB7V29ybGR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMud29ybGQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzaGFwZXMgb2YgdGhlIGJvZHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgc2hhcGVzXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNoYXBlcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYXNzIG9mIHRoZSBib2R5LiBJZiB5b3UgY2hhbmdlIHRoaXMgbnVtYmVyLCB5b3Ugc2hvdWxkIGNhbGwge3sjY3Jvc3NMaW5rIFwiQm9keS91cGRhdGVNYXNzUHJvcGVydGllczptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgbWFzc1xyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICBib2R5Lm1hc3MgPSAxO1xyXG4gICAgICAgICAqICAgICBib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubWFzcyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGludmVyc2UgbWFzcyBvZiB0aGUgYm9keS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBpbnZNYXNzXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5pbnZNYXNzID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaW5lcnRpYSBvZiB0aGUgYm9keSBhcm91bmQgdGhlIFogYXhpcy5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgaW5lcnRpYVxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuaW5lcnRpYSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGludmVyc2UgaW5lcnRpYSBvZiB0aGUgYm9keS5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgaW52SW5lcnRpYVxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuaW52SW5lcnRpYSA9IDA7XHJcbiAgICAgICAgX3RoaXMuaW52TWFzc1NvbHZlID0gMDtcclxuICAgICAgICBfdGhpcy5pbnZJbmVydGlhU29sdmUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGZpeCB0aGUgcm90YXRpb24gb2YgdGhlIGJvZHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgZml4ZWRSb3RhdGlvblxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gRml4IHJvdGF0aW9uIGR1cmluZyBydW50aW1lXHJcbiAgICAgICAgICogICAgIGJvZHkuZml4ZWRSb3RhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICogICAgIGJvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5maXhlZFJvdGF0aW9uID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBmaXggdGhlIGJvZHkgbW92ZW1lbnQgYWxvbmcgdGhlIFggYXhpcy4gVGhlIGJvZHkgd2lsbCBzdGlsbCBiZSBhYmxlIHRvIG1vdmUgYWxvbmcgWS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGZpeGVkWFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gRml4IFggbW92ZW1lbnQgb24gYm9keSBjcmVhdGlvblxyXG4gICAgICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHsgbWFzczogMSwgZml4ZWRYOiB0cnVlIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gRml4IFggbW92ZW1lbnQgZHVyaW5nIHJ1bnRpbWVcclxuICAgICAgICAgKiAgICAgYm9keS5maXhlZFggPSB0cnVlO1xyXG4gICAgICAgICAqICAgICBib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZml4ZWRYID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gZml4IHRoZSBib2R5IG1vdmVtZW50IGFsb25nIHRoZSBZIGF4aXMuIFRoZSBib2R5IHdpbGwgc3RpbGwgYmUgYWJsZSB0byBtb3ZlIGFsb25nIFguIFNlZSAuZml4ZWRYXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmaXhlZFlcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5maXhlZFkgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbmd1bGFyIGNvbnN0cmFpbnQgdmVsb2NpdHkgdGhhdCB3YXMgYWRkZWQgdG8gdGhlIGJvZHkgZHVyaW5nIGxhc3Qgc3RlcC5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgd2xhbWJkYVxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX0gLy8gVGhpcyB3YXMgYXJyYXkgYmVmb3JlIHRoZSBwb3J0LCBidXQgaHRlIGFzc2lnbm1lbnQgd2FzIGFsd2F5cyAwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLndsYW1iZGEgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbmdsZSBvZiB0aGUgYm9keSwgaW4gcmFkaWFucy5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYW5nbGVcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgIC8vIFRoZSBhbmdsZSBwcm9wZXJ0eSBpcyBub3Qgbm9ybWFsaXplZCB0byB0aGUgaW50ZXJ2YWwgMCB0byAyKnBpLCBpdCBjYW4gYmUgYW55IHZhbHVlLlxyXG4gICAgICAgICAqICAgICAvLyBJZiB5b3UgbmVlZCBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMipwaSwgdXNlIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gdG8gbm9ybWFsaXplIGl0LlxyXG4gICAgICAgICAqICAgICBmdW5jdGlvbiBub3JtYWxpemVBbmdsZShhbmdsZSl7XHJcbiAgICAgICAgICogICAgICAgICBhbmdsZSA9IGFuZ2xlICUgKDIqTWF0aC5QSSk7XHJcbiAgICAgICAgICogICAgICAgICBpZihhbmdsZSA8IDApe1xyXG4gICAgICAgICAqICAgICAgICAgICAgIGFuZ2xlICs9ICgyKk1hdGguUEkpO1xyXG4gICAgICAgICAqICAgICAgICAgfVxyXG4gICAgICAgICAqICAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuYW5nbGUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBwcmV2aW91cyBhbmdsZSBvZiB0aGUgYm9keS5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgcHJldmlvdXNBbmdsZVxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMucHJldmlvdXNBbmdsZSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGludGVycG9sYXRlZCBhbmdsZSBvZiB0aGUgYm9keS4gVXNlIHRoaXMgZm9yIHJlbmRlcmluZy5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgaW50ZXJwb2xhdGVkQW5nbGVcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmludGVycG9sYXRlZEFuZ2xlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgYm9keSwgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyVmVsb2NpdHlcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFuZ3VsYXIgZm9yY2UgYWN0aW5nIG9uIHRoZSBib2R5LiBTZWUge3sjY3Jvc3NMaW5rIFwiQm9keS9mb3JjZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYW5ndWxhckZvcmNlXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5hbmd1bGFyRm9yY2UgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbmd1bGFyIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyRGFtcGluZ1xyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMC4xXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuYW5ndWxhckRhbXBpbmcgPSAwLjE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHR5cGUgb2YgbW90aW9uIHRoaXMgYm9keSBoYXMuIFNob3VsZCBiZSBvbmUgb2Y6IHt7I2Nyb3NzTGluayBcIkJvZHkvU1RBVElDOnByb3BlcnR5XCJ9fUJvZHkuU1RBVElDe3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkJvZHkvRFlOQU1JQzpwcm9wZXJ0eVwifX1Cb2R5LkRZTkFNSUN7ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiQm9keS9LSU5FTUFUSUM6cHJvcGVydHlcIn19Qm9keS5LSU5FTUFUSUN7ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICogU3RhdGljIGJvZGllcyBkbyBub3QgbW92ZSwgYW5kIHRoZXkgZG8gbm90IHJlc3BvbmQgdG8gZm9yY2VzIG9yIGNvbGxpc2lvbi5cclxuICAgICAgICAgKiAqIER5bmFtaWMgYm9kaWVzIGJvZHkgY2FuIG1vdmUgYW5kIHJlc3BvbmQgdG8gY29sbGlzaW9ucyBhbmQgZm9yY2VzLlxyXG4gICAgICAgICAqICogS2luZW1hdGljIGJvZGllcyBvbmx5IG1vdmVzIGFjY29yZGluZyB0byBpdHMgLnZlbG9jaXR5LCBhbmQgZG9lcyBub3QgcmVzcG9uZCB0byBjb2xsaXNpb25zIG9yIGZvcmNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHR5cGVcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gQm9kaWVzIGFyZSBzdGF0aWMgYnkgZGVmYXVsdC4gU3RhdGljIGJvZGllcyB3aWxsIG5ldmVyIG1vdmUuXHJcbiAgICAgICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoKTtcclxuICAgICAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS50eXBlID09IEJvZHkuU1RBVElDKTsgLy8gdHJ1ZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gQnkgc2V0dGluZyB0aGUgbWFzcyBvZiBhIGJvZHkgdG8gYSBub256ZXJvIG51bWJlciwgdGhlIGJvZHlcclxuICAgICAgICAgKiAgICAgLy8gd2lsbCBiZWNvbWUgZHluYW1pYyBhbmQgd2lsbCBtb3ZlIGFuZCBpbnRlcmFjdCB3aXRoIG90aGVyIGJvZGllcy5cclxuICAgICAgICAgKiAgICAgdmFyIGR5bmFtaWNCb2R5ID0gbmV3IEJvZHkoe1xyXG4gICAgICAgICAqICAgICAgICAgbWFzcyA6IDFcclxuICAgICAgICAgKiAgICAgfSk7XHJcbiAgICAgICAgICogICAgIGNvbnNvbGUubG9nKGR5bmFtaWNCb2R5LnR5cGUgPT0gQm9keS5EWU5BTUlDKTsgLy8gdHJ1ZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gS2luZW1hdGljIGJvZGllcyB3aWxsIG9ubHkgbW92ZSBpZiB5b3UgY2hhbmdlIHRoZWlyIHZlbG9jaXR5LlxyXG4gICAgICAgICAqICAgICB2YXIga2luZW1hdGljQm9keSA9IG5ldyBCb2R5KHtcclxuICAgICAgICAgKiAgICAgICAgIHR5cGU6IEJvZHkuS0lORU1BVElDIC8vIFR5cGUgY2FuIGJlIHNldCB2aWEgdGhlIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy50eXBlID0gQm9keS5TVEFUSUM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQm91bmRpbmcgY2lyY2xlIHJhZGl1cy4gVXBkYXRlIHdpdGgge3sjY3Jvc3NMaW5rIFwiQm9keS91cGRhdGVCb3VuZGluZ1JhZGl1czptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IGJvdW5kaW5nUmFkaXVzXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIGlmIHRoZSBBQUJCIG5lZWRzIHVwZGF0ZS4gVXBkYXRlIGl0IHdpdGgge3sjY3Jvc3NMaW5rIFwiQm9keS91cGRhdGVBQUJCOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYWFiYk5lZWRzVXBkYXRlXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQHNlZSB1cGRhdGVBQUJCXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAvLyBGb3JjZSB1cGRhdGUgdGhlIEFBQkJcclxuICAgICAgICAgKiAgICAgYm9keS5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAqICAgICBib2R5LnVwZGF0ZUFBQkIoKTtcclxuICAgICAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5hYWJiTmVlZHNVcGRhdGUpOyAvLyBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIGJvZHkgd2lsbCBhdXRvbWF0aWNhbGx5IGZhbGwgdG8gc2xlZXAuIE5vdGUgdGhhdCB5b3UgbmVlZCB0byBlbmFibGUgc2xlZXBpbmcgaW4gdGhlIHt7I2Nyb3NzTGluayBcIldvcmxkXCJ9fXt7L2Nyb3NzTGlua319IGJlZm9yZSBhbnl0aGluZyB3aWxsIGhhcHBlbi5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYWxsb3dTbGVlcFxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5hbGxvd1NsZWVwID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy53YW50c1RvU2xlZXAgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPbmUgb2Yge3sjY3Jvc3NMaW5rIFwiQm9keS9BV0FLRTpwcm9wZXJ0eVwifX1Cb2R5LkFXQUtFe3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkJvZHkvU0xFRVBZOnByb3BlcnR5XCJ9fUJvZHkuU0xFRVBZe3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvU0xFRVBJTkc6cHJvcGVydHlcIn19Qm9keS5TTEVFUElOR3t7L2Nyb3NzTGlua319LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlIGJvZHkgaXMgaW5pdGlhbGx5IEJvZHkuQVdBS0UuIElmIGl0cyB2ZWxvY2l0eSBub3JtIGlzIGJlbG93IC5zbGVlcFNwZWVkTGltaXQsIHRoZSBzbGVlcFN0YXRlIHdpbGwgYmVjb21lIEJvZHkuU0xFRVBZLiBJZiB0aGUgYm9keSBjb250aW51ZXMgdG8gYmUgQm9keS5TTEVFUFkgZm9yIC5zbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCB3aWxsIGZhbGwgYXNsZWVwIChCb2R5LlNMRUVQWSkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgc2xlZXBTdGF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgQm9keS5BV0FLRVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNsZWVwU3RhdGUgPSBCb2R5LkFXQUtFO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBzcGVlZCAodGhlIG5vcm0gb2YgdGhlIHZlbG9jaXR5KSBpcyBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGJvZHkgaXMgY29uc2lkZXJlZCBzbGVlcHkuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNsZWVwU3BlZWRMaW1pdFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMC4yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuc2xlZXBTcGVlZExpbWl0ID0gMC4yO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVweSBmb3IgdGhpcyBzbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCBpcyBjb25zaWRlcmVkIHNsZWVwaW5nLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzbGVlcFRpbWVMaW1pdFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNsZWVwVGltZUxpbWl0ID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHcmF2aXR5IHNjYWxpbmcgZmFjdG9yLiBJZiB5b3Ugd2FudCB0aGUgYm9keSB0byBpZ25vcmUgZ3Jhdml0eSwgc2V0IHRoaXMgdG8gemVyby4gSWYgeW91IHdhbnQgdG8gcmV2ZXJzZSBncmF2aXR5LCBzZXQgaXQgdG8gLTEuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGdyYXZpdHlTY2FsZVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5ncmF2aXR5U2NhbGUgPSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC4gVGhhdCBtZWFucyB0aGF0IHRoaXMgYm9keSB3aWxsIG1vdmUgdGhyb3VnaCBvdGhlciBib2RpZXMsIGJ1dCBpdCB3aWxsIHN0aWxsIHRyaWdnZXIgY29udGFjdCBldmVudHMsIGV0Yy5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbGxpc2lvblJlc3BvbnNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhvdyBsb25nIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVwaW5nLlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZGxlVGltZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmlkbGVUaW1lID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGFzdCB0aW1lIHdoZW4gdGhlIGJvZHkgd2VudCB0byBTTEVFUFkgc3RhdGUuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpbWVMYXN0U2xlZXB5XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy50aW1lTGFzdFNsZWVweSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIGJvZHkgc3BlZWQgZXhjZWVkcyB0aGlzIHRocmVzaG9sZCwgQ0NEIChjb250aW51b3VzIGNvbGxpc2lvbiBkZXRlY3Rpb24pIHdpbGwgYmUgZW5hYmxlZC4gU2V0IGl0IHRvIGEgbmVnYXRpdmUgbnVtYmVyIHRvIGRpc2FibGUgQ0NEIGNvbXBsZXRlbHkgZm9yIHRoaXMgYm9keS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY2NkU3BlZWRUaHJlc2hvbGRcclxuICAgICAgICAgKiBAZGVmYXVsdCAtMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNjZFNwZWVkVGhyZXNob2xkID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiBzZWFyY2hpbmcgZm9yIHRoZSB0aW1lIG9mIGltcGFjdCBkdXJpbmcgQ0NELiBBIGxhcmdlciBudW1iZXIgd2lsbCBhc3N1cmUgdGhhdCB0aGVyZSdzIGEgc21hbGwgcGVuZXRyYXRpb24gb24gQ0NEIGNvbGxpc2lvbiwgYnV0IGEgc21hbGwgbnVtYmVyIHdpbGwgZ2l2ZSBtb3JlIHBlcmZvcm1hbmNlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjY2RJdGVyYXRpb25zXHJcbiAgICAgICAgICogQGRlZmF1bHQgMTBcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5jY2RJdGVyYXRpb25zID0gMTA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGlzbGFuZElkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuaXNsYW5kSWQgPSAtMTtcclxuICAgICAgICBfdGhpcy5jb25jYXZlUGF0aCA9IFtdO1xyXG4gICAgICAgIC8vIFNob3VsZCBiZSBwcml2YXRlLCBidXQgdXNlZCBieSB3b3JsZC5cclxuICAgICAgICBfdGhpcy5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLl9zaGFwZUFBQkIgPSBuZXcgYWFiYl8xLmRlZmF1bHQoKTtcclxuICAgICAgICBfdGhpcy5pZCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKytfaWRDb3VudGVyO1xyXG4gICAgICAgIF90aGlzLm1hc3MgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFzcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgICAgICBfdGhpcy5maXhlZFJvdGF0aW9uID0gKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZpeGVkUm90YXRpb24pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmZpeGVkWCA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5maXhlZFgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmZpeGVkWSA9IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5maXhlZFkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLm1hc3NNdWx0aXBsaWVyID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIF90aGlzLnBvc2l0aW9uID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wb3NpdGlvbikgPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLnBvc2l0aW9uKSA6IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICBfdGhpcy5pbnRlcnBvbGF0ZWRQb3NpdGlvbiA9IHZlYzJfMS5kZWZhdWx0LmNsb25lKF90aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICBfdGhpcy5wcmV2aW91c1Bvc2l0aW9uID0gdmVjMl8xLmRlZmF1bHQuY2xvbmUoX3RoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIF90aGlzLnZlbG9jaXR5ID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52ZWxvY2l0eSkgPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLnZlbG9jaXR5KSA6IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICBfdGhpcy52bGFtYmRhID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIF90aGlzLmFuZ2xlID0gKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFuZ2xlKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAwO1xyXG4gICAgICAgIF90aGlzLnByZXZpb3VzQW5nbGUgPSBfdGhpcy5hbmdsZTtcclxuICAgICAgICBfdGhpcy5pbnRlcnBvbGF0ZWRBbmdsZSA9IF90aGlzLmFuZ2xlO1xyXG4gICAgICAgIF90aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IChfZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmd1bGFyVmVsb2NpdHkpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IDA7XHJcbiAgICAgICAgX3RoaXMuZm9yY2UgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZvcmNlKSA/IHZlYzJfMS5kZWZhdWx0LmNsb25lKG9wdGlvbnMuZm9yY2UpIDogdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIF90aGlzLmFuZ3VsYXJGb3JjZSA9IChfaCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmd1bGFyRm9yY2UpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IDA7XHJcbiAgICAgICAgX3RoaXMuZGFtcGluZyA9IChfaiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYW1waW5nKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiAwLjE7XHJcbiAgICAgICAgX3RoaXMuYW5ndWxhckRhbXBpbmcgPSAoX2sgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYW5ndWxhckRhbXBpbmcpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IDAuMTtcclxuICAgICAgICBfdGhpcy5zbGVlcFRpbWVMaW1pdCA9IChfbCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zbGVlcFRpbWVMaW1pdCkgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogMTtcclxuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50eXBlKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hc3MpKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnR5cGUgPSBCb2R5LlNUQVRJQztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF90aGlzLnR5cGUgPSBCb2R5LkRZTkFNSUM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aGlzLmFhYmIgPSBuZXcgYWFiYl8xLmRlZmF1bHQoKTtcclxuICAgICAgICBfdGhpcy5hbGxvd1NsZWVwID0gKF9tID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFsbG93U2xlZXApICE9PSBudWxsICYmIF9tICE9PSB2b2lkIDAgPyBfbSA6IHRydWU7XHJcbiAgICAgICAgX3RoaXMuc2xlZXBTcGVlZExpbWl0ID0gKF9vID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCkgIT09IG51bGwgJiYgX28gIT09IHZvaWQgMCA/IF9vIDogMC4yO1xyXG4gICAgICAgIF90aGlzLmdyYXZpdHlTY2FsZSA9IChfcCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ncmF2aXR5U2NhbGUpICE9PSBudWxsICYmIF9wICE9PSB2b2lkIDAgPyBfcCA6IDE7XHJcbiAgICAgICAgX3RoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSAoX3EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29sbGlzaW9uUmVzcG9uc2UpICE9PSBudWxsICYmIF9xICE9PSB2b2lkIDAgPyBfcSA6IHRydWU7XHJcbiAgICAgICAgX3RoaXMuY2NkU3BlZWRUaHJlc2hvbGQgPSAoX3IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2NkU3BlZWRUaHJlc2hvbGQpICE9PSBudWxsICYmIF9yICE9PSB2b2lkIDAgPyBfciA6IC0xO1xyXG4gICAgICAgIF90aGlzLmNjZEl0ZXJhdGlvbnMgPSAoX3MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2NkSXRlcmF0aW9ucykgIT09IG51bGwgJiYgX3MgIT09IHZvaWQgMCA/IF9zIDogMTA7XHJcbiAgICAgICAgX3RoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXNcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUudXBkYXRlU29sdmVNYXNzUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnZNYXNzU29sdmUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IHRoaXMuaW52TWFzcztcclxuICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSB0aGlzLmludkluZXJ0aWE7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB0b3RhbCBkZW5zaXR5IG9mIHRoZSBib2R5XHJcbiAgICAgKiBAbWV0aG9kIHNldERlbnNpdHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZW5zaXR5XHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnNldERlbnNpdHkgPSBmdW5jdGlvbiAoZGVuc2l0eSkge1xyXG4gICAgICAgIHZhciB0b3RhbEFyZWEgPSB0aGlzLmdldEFyZWEoKTtcclxuICAgICAgICB0aGlzLm1hc3MgPSB0b3RhbEFyZWEgKiBkZW5zaXR5O1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdG90YWwgYXJlYSBvZiBhbGwgc2hhcGVzIGluIHRoZSBib2R5XHJcbiAgICAgKiBAbWV0aG9kIGdldEFyZWFcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdG90YWxBcmVhID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRvdGFsQXJlYSArPSB0aGlzLnNoYXBlc1tpXS5hcmVhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG90YWxBcmVhO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBBQUJCIGZyb20gdGhlIGJvZHkuIFRoZSBBQUJCIGlzIHVwZGF0ZWQgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICogQG1ldGhvZCBnZXRBQUJCXHJcbiAgICAgKiBAcmV0dXJuIHtBQUJCfSBUaGUgQUFCQiBpbnN0YW5jZSBmcm9tIHRoZSBib2R5LlxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmFhYmJOZWVkc1VwZGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWFiYjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIEFBQkIgb2YgdGhlIEJvZHksIGFuZCBzZXQgLmFhYmJOZWVkc1VwZGF0ZSA9IGZhbHNlLlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVBQUJCXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnVwZGF0ZUFBQkIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLCBOID0gc2hhcGVzLmxlbmd0aCwgb2Zmc2V0ID0gX3RtcCwgYm9keUFuZ2xlID0gdGhpcy5hbmdsZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXSwgYW5nbGUgPSBzaGFwZS5hbmdsZSArIGJvZHlBbmdsZTtcclxuICAgICAgICAgICAgLy8gR2V0IHNoYXBlIHdvcmxkIG9mZnNldFxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKG9mZnNldCwgc2hhcGUucG9zaXRpb24sIHRoaXMucG9zaXRpb24sIGJvZHlBbmdsZSk7XHJcbiAgICAgICAgICAgIC8vIEdldCBzaGFwZSBBQUJCXHJcbiAgICAgICAgICAgIHNoYXBlLmNvbXB1dGVBQUJCKHRoaXMuX3NoYXBlQUFCQiwgb2Zmc2V0LCBhbmdsZSk7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFhYmIuY29weSh0aGlzLl9zaGFwZUFBQkIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hYWJiLmV4dGVuZCh0aGlzLl9zaGFwZUFBQkIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgYm9keSAodGhpcy5ib3VuZGluZ1JhZGl1cykuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgc2hhcGUgZGltZW5zaW9ucyBvciBwb3NpdGlvbnMgYXJlIGNoYW5nZWQuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcywgTiA9IHNoYXBlcy5sZW5ndGgsIHJhZGl1cyA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sIG9mZnNldCA9IHZlYzJfMS5kZWZhdWx0Lmxlbmd0aChzaGFwZS5wb3NpdGlvbiksIHIgPSBzaGFwZS5ib3VuZGluZ1JhZGl1cztcclxuICAgICAgICAgICAgaWYgKG9mZnNldCArIHIgPiByYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IG9mZnNldCArIHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHJhZGl1cztcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNoYXBlIHRvIHRoZSBib2R5LiBZb3UgY2FuIHBhc3MgYSBsb2NhbCB0cmFuc2Zvcm0gd2hlbiBhZGRpbmcgYSBzaGFwZSxcclxuICAgICAqIHNvIHRoYXQgdGhlIHNoYXBlIGdldHMgYW4gb2Zmc2V0IGFuZCBhbmdsZSByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAqIFdpbGwgYXV0b21hdGljYWxseSB1cGRhdGUgdGhlIG1hc3MgcHJvcGVydGllcyBhbmQgYm91bmRpbmcgcmFkaXVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgYWRkU2hhcGVcclxuICAgICAqIEBwYXJhbSAge1NoYXBlfSAgICAgICAgICAgICAgc2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBbb2Zmc2V0XSBMb2NhbCBib2R5IG9mZnNldCBvZiB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgICAgIFthbmdsZV0gIExvY2FsIGJvZHkgYW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCksXHJcbiAgICAgKiAgICAgICAgIHNoYXBlID0gbmV3IENpcmNsZSh7IHJhZGl1czogMSB9KTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gQWRkIHRoZSBzaGFwZSB0byB0aGUgYm9keSwgcG9zaXRpb25lZCBpbiB0aGUgY2VudGVyXHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIEFkZCBhbm90aGVyIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIDEgdW5pdCBsZW5ndGggZnJvbSB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcyBhbG9uZyB0aGUgbG9jYWwgeC1heGlzLlxyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUsWzEsMF0pO1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBBZGQgYW5vdGhlciBzaGFwZSB0byB0aGUgYm9keSwgcG9zaXRpb25lZCAxIHVuaXQgbGVuZ3RoIGZyb20gdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MgYWxvbmcgdGhlIGxvY2FsIHktYXhpcywgYW5kIHJvdGF0ZWQgOTAgZGVncmVlcyBDQ1cuXHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSxbMCwxXSxNYXRoLlBJLzIpO1xyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZSwgb2Zmc2V0LCBhbmdsZSkge1xyXG4gICAgICAgIGlmIChhbmdsZSA9PT0gdm9pZCAwKSB7IGFuZ2xlID0gMDsgfVxyXG4gICAgICAgIGlmIChzaGFwZS5ib2R5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBzaGFwZSBjYW4gb25seSBiZSBhZGRlZCB0byBvbmUgYm9keS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdvcmxkID0gdGhpcy53b3JsZDtcclxuICAgICAgICBpZiAod29ybGQgJiYgd29ybGQuc3RlcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHNoYXBlIGNhbm5vdCBiZSBhZGRlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2hhcGUuYm9keSA9IHRoaXM7XHJcbiAgICAgICAgLy8gQ29weSB0aGUgb2Zmc2V0IHZlY3RvclxyXG4gICAgICAgIGlmIChvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShzaGFwZS5wb3NpdGlvbiwgb2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChzaGFwZS5wb3NpdGlvbiwgMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNoYXBlLmFuZ2xlID0gYW5nbGUgfHwgMDtcclxuICAgICAgICB0aGlzLnNoYXBlcy5wdXNoKHNoYXBlKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xyXG4gICAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIHNoYXBlLlxyXG4gICAgICogQG1ldGhvZCByZW1vdmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzaGFwZSB3YXMgZm91bmQgYW5kIHJlbW92ZWQsIGVsc2UgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnJlbW92ZVNoYXBlID0gZnVuY3Rpb24gKHNoYXBlKSB7XHJcbiAgICAgICAgdmFyIHdvcmxkID0gdGhpcy53b3JsZDtcclxuICAgICAgICBpZiAod29ybGQgJiYgd29ybGQuc3RlcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHNoYXBlIGNhbm5vdCBiZSByZW1vdmVkIGR1cmluZyBzdGVwLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5zaGFwZXMuaW5kZXhPZihzaGFwZSk7XHJcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFwZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2hhcGUuYm9keSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyAuaW5lcnRpYSwgLmludk1hc3MsIC5pbnZJbmVydGlhIGZvciB0aGlzIEJvZHkuIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBjaGFuZ2luZyB0aGUgc3RydWN0dXJlIG9yIG1hc3Mgb2YgdGhlIEJvZHkuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVNYXNzUHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgYm9keS5tYXNzICs9IDE7XHJcbiAgICAgKiAgICAgYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS51cGRhdGVNYXNzUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy50eXBlID09PSBCb2R5LlNUQVRJQyB8fCB0aGlzLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIG1ha2luZyBpdCBpbmZpbml0eS5cclxuICAgICAgICAgICAgdGhpcy5tYXNzID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIHRoaXMuaW52TWFzcyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYSA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICB0aGlzLmludkluZXJ0aWEgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLCBOID0gc2hhcGVzLmxlbmd0aCwgSSA9IDA7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5maXhlZFJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXSwgcjIgPSB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkTGVuZ3RoKHNoYXBlLnBvc2l0aW9uKSwgSWNtID0gc2hhcGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIEkgKz0gSWNtICsgcjI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZXJ0aWEgPSB0aGlzLm1hc3MgKiBJO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhID0gSSA+IDAgPyAxIC8gSSA6IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZXJ0aWEgPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSW52ZXJzZSBtYXNzIHByb3BlcnRpZXMgYXJlIGVhc3lcclxuICAgICAgICAgICAgdGhpcy5pbnZNYXNzID0gMSAvIHRoaXMubWFzcztcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHRoaXMubWFzc011bHRpcGxpZXIsIHRoaXMuZml4ZWRYID8gMCA6IDEsIHRoaXMuZml4ZWRZID8gMCA6IDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IGZvcmNlIHRvIGEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzIG9mIHRoZSBib2R5LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQXBwbHlpbmcgZm9yY2UgdGhpcyB3YXkgd2lsbCBhZGQgdG8gQm9keS5mb3JjZSBhbmQgQm9keS5hbmd1bGFyRm9yY2UuXHJcbiAgICAgKiBAbWV0aG9kIGFwcGx5Rm9yY2VcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBmb3JjZSBUaGUgZm9yY2UgdmVjdG9yIHRvIGFkZCwgb3JpZW50ZWQgaW4gd29ybGQgc3BhY2UuXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gW3JlbGF0aXZlUG9pbnRdIEEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGJvZHkgaW4gd29ybGQgc3BhY2UuIElmIG5vdCBnaXZlbiwgaXQgaXMgc2V0IHRvIHplcm8gYW5kIGFsbCBvZiB0aGUgZm9yY2Ugd2lsbCBiZSBleGVydGVkIG9uIHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAgICAgKiAgICAgdmFyIHJlbGF0aXZlUG9pbnQgPSBbMSwgMF07IC8vIFdpbGwgYXBwbHkgdGhlIGZvcmNlIGF0IFtib2R5LnBvc2l0aW9uWzBdICsgMSwgYm9keS5wb3NpdGlvblsxXV1cclxuICAgICAqICAgICB2YXIgZm9yY2UgPSBbMCwgMV07IC8vIHVwXHJcbiAgICAgKiAgICAgYm9keS5hcHBseUZvcmNlKGZvcmNlLCByZWxhdGl2ZVBvaW50KTtcclxuICAgICAqICAgICBjb25zb2xlLmxvZyhib2R5LmZvcmNlKTsgLy8gWzAsIDFdXHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5hbmd1bGFyRm9yY2UpOyAvLyAxXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UsIHJlbGF0aXZlUG9pbnQpIHtcclxuICAgICAgICAvLyBBZGQgbGluZWFyIGZvcmNlXHJcbiAgICAgICAgYWRkKHRoaXMuZm9yY2UsIHRoaXMuZm9yY2UsIGZvcmNlKTtcclxuICAgICAgICBpZiAocmVsYXRpdmVQb2ludCkge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgZm9yY2VcclxuICAgICAgICAgICAgdmFyIHJvdEZvcmNlID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmVsYXRpdmVQb2ludCwgZm9yY2UpO1xyXG4gICAgICAgICAgICAvLyBBZGQgcm90YXRpb25hbCBmb3JjZVxyXG4gICAgICAgICAgICB0aGlzLmFuZ3VsYXJGb3JjZSArPSByb3RGb3JjZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBmb3JjZSB0byBhIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyBvZiB0aGUgYm9keS4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuIEFwcGx5aW5nIGZvcmNlIHRoaXMgd2F5IHdpbGwgYWRkIHRvIEJvZHkuZm9yY2UgYW5kIEJvZHkuYW5ndWxhckZvcmNlLlxyXG4gICAgICogQG1ldGhvZCBhcHBseUZvcmNlTG9jYWxcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBsb2NhbEZvcmNlIFRoZSBmb3JjZSB2ZWN0b3IgdG8gYWRkLCBvcmllbnRlZCBpbiBsb2NhbCBib2R5IHNwYWNlLlxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IFtsb2NhbFBvaW50XSBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBib2R5IGluIGxvY2FsIGJvZHkgc3BhY2UuIElmIG5vdCBnaXZlbiwgaXQgaXMgc2V0IHRvIHplcm8gYW5kIGFsbCBvZiB0aGUgZm9yY2Ugd2lsbCBiZSBleGVydGVkIG9uIHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAgICAgKiAgICAgdmFyIGxvY2FsUG9pbnQgPSBbMSwgMF07IC8vIHg9MSBsb2NhbGx5IGluIHRoZSBib2R5XHJcbiAgICAgKiAgICAgdmFyIGxvY2FsRm9yY2UgPSBbMCwgMV07IC8vIHVwLCBsb2NhbGx5IGluIHRoZSBib2R5XHJcbiAgICAgKiAgICAgYm9keS5hcHBseUZvcmNlTG9jYWwobG9jYWxGb3JjZSwgbG9jYWxQb2ludCk7XHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5mb3JjZSk7IC8vIFswLCAxXVxyXG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkuYW5ndWxhckZvcmNlKTsgLy8gMVxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlTG9jYWwgPSBmdW5jdGlvbiAobG9jYWxGb3JjZSwgbG9jYWxQb2ludCkge1xyXG4gICAgICAgIC8vIFRoZXNlIDMgbGluZXMgd2VyZSBvcmlnaW5hbGx5IG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi4gTm90IHN1cmUgd2h5LlxyXG4gICAgICAgIHZhciBCb2R5X2FwcGx5Rm9yY2VfZm9yY2VXb3JsZCA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICB2YXIgQm9keV9hcHBseUZvcmNlX3BvaW50V29ybGQgPSB2ZWMyY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIEJvZHlfYXBwbHlGb3JjZV9wb2ludExvY2FsID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIGxvY2FsUG9pbnQgPSBsb2NhbFBvaW50IHx8IEJvZHlfYXBwbHlGb3JjZV9wb2ludExvY2FsO1xyXG4gICAgICAgIHZhciB3b3JsZEZvcmNlID0gQm9keV9hcHBseUZvcmNlX2ZvcmNlV29ybGQ7XHJcbiAgICAgICAgdmFyIHdvcmxkUG9pbnQgPSBCb2R5X2FwcGx5Rm9yY2VfcG9pbnRXb3JsZDtcclxuICAgICAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZSh3b3JsZEZvcmNlLCBsb2NhbEZvcmNlKTtcclxuICAgICAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZSh3b3JsZFBvaW50LCBsb2NhbFBvaW50KTtcclxuICAgICAgICB0aGlzLmFwcGx5Rm9yY2Uod29ybGRGb3JjZSwgd29ybGRQb2ludCk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBpbXB1bHNlIHRvIGEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGJvZHkuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgYSBwb2ludCBvbiB0aGUgQm9keSBzdXJmYWNlLiBBbiBpbXB1bHNlIGlzIGEgZm9yY2UgYWRkZWQgdG8gYSBib2R5IGR1cmluZyBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIChpbXB1bHNlID0gZm9yY2UgKiB0aW1lKS4gSW1wdWxzZXMgd2lsbCBiZSBhZGRlZCB0byBCb2R5LnZlbG9jaXR5IGFuZCBCb2R5LmFuZ3VsYXJWZWxvY2l0eS5cclxuICAgICAqIEBtZXRob2QgYXBwbHlJbXB1bHNlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gaW1wdWxzZVZlY3RvciBUaGUgaW1wdWxzZSB2ZWN0b3IgdG8gYWRkLCBvcmllbnRlZCBpbiB3b3JsZCBzcGFjZS5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBbcmVsYXRpdmVQb2ludF0gQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSBpbiB3b3JsZCBzcGFjZS4gSWYgbm90IGdpdmVuLCBpdCBpcyBzZXQgdG8gemVybyBhbmQgYWxsIG9mIHRoZSBpbXB1bHNlIHdpbGwgYmUgZXhlcnRlZCBvbiB0aGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xyXG4gICAgICogICAgIHZhciByZWxhdGl2ZVBvaW50ID0gWzAsIDBdOyAvLyBjZW50ZXIgb2YgdGhlIGJvZHlcclxuICAgICAqICAgICB2YXIgaW1wdWxzZVZlY3RvciA9IFswLCAxXTsgLy8gd29ybGQgdXBcclxuICAgICAqICAgICBib2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlVmVjdG9yLCByZWxhdGl2ZVBvaW50KTtcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuYXBwbHlJbXB1bHNlID0gZnVuY3Rpb24gKGltcHVsc2VWZWN0b3IsIHJlbGF0aXZlUG9pbnQpIHtcclxuICAgICAgICB2YXIgQm9keV9hcHBseUltcHVsc2VfdmVsbyA9IHZlYzJjcmVhdGUoKTsgLy8gV2FzIG9yaWdpbmFsbHkgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLiBcclxuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb21wdXRlIHByb2R1Y2VkIGNlbnRyYWwgaW1wdWxzZSB2ZWxvY2l0eVxyXG4gICAgICAgIHZhciB2ZWxvID0gQm9keV9hcHBseUltcHVsc2VfdmVsbztcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZSh2ZWxvLCBpbXB1bHNlVmVjdG9yLCB0aGlzLmludk1hc3MpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0Lm11bHRpcGx5KHZlbG8sIHRoaXMubWFzc011bHRpcGxpZXIsIHZlbG8pO1xyXG4gICAgICAgIC8vIEFkZCBsaW5lYXIgaW1wdWxzZVxyXG4gICAgICAgIGFkZCh0aGlzLnZlbG9jaXR5LCB2ZWxvLCB0aGlzLnZlbG9jaXR5KTtcclxuICAgICAgICBpZiAocmVsYXRpdmVQb2ludCkge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgaW1wdWxzZSB2ZWxvY2l0eVxyXG4gICAgICAgICAgICB2YXIgcm90VmVsbyA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHJlbGF0aXZlUG9pbnQsIGltcHVsc2VWZWN0b3IpO1xyXG4gICAgICAgICAgICByb3RWZWxvICo9IHRoaXMuaW52SW5lcnRpYTtcclxuICAgICAgICAgICAgLy8gQWRkIHJvdGF0aW9uYWwgSW1wdWxzZVxyXG4gICAgICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSArPSByb3RWZWxvO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IGltcHVsc2UgdG8gYSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keS4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuIEFuIGltcHVsc2UgaXMgYSBmb3JjZSBhZGRlZCB0byBhIGJvZHkgZHVyaW5nIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgKGltcHVsc2UgPSBmb3JjZSAqIHRpbWUpLiBJbXB1bHNlcyB3aWxsIGJlIGFkZGVkIHRvIEJvZHkudmVsb2NpdHkgYW5kIEJvZHkuYW5ndWxhclZlbG9jaXR5LlxyXG4gICAgICogQG1ldGhvZCBhcHBseUltcHVsc2VMb2NhbFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGxvY2FsSW1wdWxzZSBUaGUgaW1wdWxzZSB2ZWN0b3IgdG8gYWRkLCBvcmllbnRlZCBpbiBsb2NhbCBib2R5IHNwYWNlLlxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IFtsb2NhbFBvaW50XSBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBib2R5IGluIGxvY2FsIGJvZHkgc3BhY2UuIElmIG5vdCBnaXZlbiwgaXQgaXMgc2V0IHRvIHplcm8gYW5kIGFsbCBvZiB0aGUgaW1wdWxzZSB3aWxsIGJlIGV4ZXJ0ZWQgb24gdGhlIGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHsgbWFzczogMSB9KTtcclxuICAgICAqICAgICB2YXIgbG9jYWxQb2ludCA9IFsxLCAwXTsgLy8geD0xLCBsb2NhbGx5IGluIHRoZSBib2R5XHJcbiAgICAgKiAgICAgdmFyIGxvY2FsSW1wdWxzZSA9IFswLCAxXTsgLy8gdXAsIGxvY2FsbHkgaW4gdGhlIGJvZHlcclxuICAgICAqICAgICBib2R5LmFwcGx5SW1wdWxzZUxvY2FsKGxvY2FsSW1wdWxzZSwgbG9jYWxQb2ludCk7XHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS52ZWxvY2l0eSk7IC8vIFsxLCAwXVxyXG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkuYW5ndWxhclZlbG9jaXR5KTsgLy8gMVxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5hcHBseUltcHVsc2VMb2NhbCA9IGZ1bmN0aW9uIChsb2NhbEltcHVsc2UsIGxvY2FsUG9pbnQpIHtcclxuICAgICAgICAvLyBPcmlnaW5hbGx5IG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cclxuICAgICAgICB2YXIgQm9keV9hcHBseUltcHVsc2VfaW1wdWxzZVdvcmxkID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludFdvcmxkID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludExvY2FsID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIGxvY2FsUG9pbnQgPSBsb2NhbFBvaW50IHx8IEJvZHlfYXBwbHlJbXB1bHNlX3BvaW50TG9jYWw7XHJcbiAgICAgICAgdmFyIHdvcmxkSW1wdWxzZSA9IEJvZHlfYXBwbHlJbXB1bHNlX2ltcHVsc2VXb3JsZDtcclxuICAgICAgICB2YXIgd29ybGRQb2ludCA9IEJvZHlfYXBwbHlJbXB1bHNlX3BvaW50V29ybGQ7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUod29ybGRJbXB1bHNlLCBsb2NhbEltcHVsc2UpO1xyXG4gICAgICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKHdvcmxkUG9pbnQsIGxvY2FsUG9pbnQpO1xyXG4gICAgICAgIHRoaXMuYXBwbHlJbXB1bHNlKHdvcmxkSW1wdWxzZSwgd29ybGRQb2ludCk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gYSB3b3JsZCBwb2ludCB0byBsb2NhbCBib2R5IGZyYW1lLlxyXG4gICAgICogQG1ldGhvZCB0b0xvY2FsRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHBvaW50IHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFBvaW50ICAgVGhlIGlucHV0IHdvcmxkIHBvaW50XHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uIChvdXQsIHdvcmxkUG9pbnQpIHtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUob3V0LCB3b3JsZFBvaW50LCB0aGlzLnBvc2l0aW9uLCB0aGlzLmFuZ2xlKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSBhIGxvY2FsIHBvaW50IHRvIHdvcmxkIGZyYW1lLlxyXG4gICAgICogQG1ldGhvZCB0b1dvcmxkRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHBvaW50IHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBsb2NhbFBvaW50ICAgVGhlIGlucHV0IGxvY2FsIHBvaW50XHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uIChvdXQsIGxvY2FsUG9pbnQpIHtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKG91dCwgbG9jYWxQb2ludCwgdGhpcy5wb3NpdGlvbiwgdGhpcy5hbmdsZSk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gYSB3b3JsZCB2ZWN0b3IgdG8gbG9jYWwgYm9keSBmcmFtZS5cclxuICAgICAqIEBtZXRob2QgdmVjdG9yVG9Mb2NhbEZyYW1lXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0ICAgICAgICAgIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpblxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHdvcmxkVmVjdG9yICBUaGUgaW5wdXQgd29ybGQgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnZlY3RvclRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uIChvdXQsIHdvcmxkVmVjdG9yKSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudmVjdG9yVG9Mb2NhbEZyYW1lKG91dCwgd29ybGRWZWN0b3IsIHRoaXMuYW5nbGUpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIGEgbG9jYWwgdmVjdG9yIHRvIHdvcmxkIGZyYW1lLlxyXG4gICAgICogQG1ldGhvZCB2ZWN0b3JUb1dvcmxkRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxWZWN0b3IgIFRoZSBpbnB1dCBsb2NhbCB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUudmVjdG9yVG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24gKG91dCwgbG9jYWxWZWN0b3IpIHtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUob3V0LCBsb2NhbFZlY3RvciwgdGhpcy5hbmdsZSk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIHBvbHlnb24gc2hhcGUgcGF0aCwgYW5kIGFzc2VtYmxlcyBjb252ZXggc2hhcGVzIGZyb20gdGhhdCBhbmQgcHV0cyB0aGVtIGF0IHByb3BlciBvZmZzZXQgcG9pbnRzLlxyXG4gICAgICogQG1ldGhvZCBmcm9tUG9seWdvblxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiAyZCB2ZWN0b3JzLCBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dIHRoYXQgcmVzZW1ibGVzIGEgY29uY2F2ZSBvciBjb252ZXggcG9seWdvbi4gVGhlIHNoYXBlIG11c3QgYmUgc2ltcGxlIGFuZCB3aXRob3V0IGhvbGVzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcHRpbWFsRGVjb21wPWZhbHNlXSAgIFNldCB0byB0cnVlIGlmIHlvdSBuZWVkIG9wdGltYWwgZGVjb21wb3NpdGlvbi4gV2FybmluZzogdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1vcmUgdGhhbiAxMCB2ZXJ0aWNlcy5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFNpbXBsZUNoZWNrPWZhbHNlXSBTZXQgdG8gdHJ1ZSBpZiB5b3UgYWxyZWFkeSBrbm93IHRoYXQgdGhlIHBhdGggaXMgbm90IGludGVyc2VjdGluZyBpdHNlbGYuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzPTBdIFNldCB0byBhIG51bWJlciAoYW5nbGUgdGhyZXNob2xkIHZhbHVlKSB0byByZW1vdmUgY29sbGluZWFyIHBvaW50cywgb3IgMCB0byBrZWVwIGFsbCBwb2ludHMuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MsIGVsc2UgZmFsc2UuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoKTtcclxuICAgICAqICAgICB2YXIgcGF0aCA9IFtcclxuICAgICAqICAgICAgICAgWy0xLCAxXSxcclxuICAgICAqICAgICAgICAgWy0xLCAwXSxcclxuICAgICAqICAgICAgICAgWzEsIDBdLFxyXG4gICAgICogICAgICAgICBbMSwgMV0sXHJcbiAgICAgKiAgICAgICAgIFswLjUsIDAuNV1cclxuICAgICAqICAgICBdO1xyXG4gICAgICogICAgIGJvZHkuZnJvbVBvbHlnb24ocGF0aCk7XHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5zaGFwZXMpOyAvLyBbQ29udmV4LCBDb252ZXgsIC4uLl1cclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuZnJvbVBvbHlnb24gPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgc2hhcGVzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuc2hhcGVzLmxlbmd0aDsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVTaGFwZSh0aGlzLnNoYXBlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvcHkgdGhlIHBhdGhcclxuICAgICAgICB2YXIgcCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwW2ldID0gdmVjMl8xLmRlZmF1bHQuY2xvbmUocGF0aFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1ha2UgaXQgY291bnRlci1jbG9ja3dpc2VcclxuICAgICAgICBwb2x5X2RlY29tcF8xLmRlZmF1bHQubWFrZUNDVyhwKTtcclxuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHMpICE9IDApIHtcclxuICAgICAgICAgICAgcG9seV9kZWNvbXBfMS5kZWZhdWx0LnJlbW92ZUNvbGxpbmVhclBvaW50cyhwLCAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGxpbmUgc2VnbWVudCBpbnRlcnNlY3RzIHRoZSBwYXRoIGl0c2VsZlxyXG4gICAgICAgIGlmICghKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwU2ltcGxlQ2hlY2spKSB7XHJcbiAgICAgICAgICAgIGlmICghcG9seV9kZWNvbXBfMS5kZWZhdWx0LmlzU2ltcGxlKHApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2F2ZSB0aGlzIHBhdGggZm9yIGxhdGVyXHJcbiAgICAgICAgdGhpcy5jb25jYXZlUGF0aCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbmNhdmVQYXRoW2ldID0gdmVjMl8xLmRlZmF1bHQuY2xvbmUocFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNsb3cgb3IgZmFzdCBkZWNvbXA/XHJcbiAgICAgICAgdmFyIGNvbnZleGVzO1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3B0aW1hbERlY29tcCkge1xyXG4gICAgICAgICAgICBjb252ZXhlcyA9IChfYiA9IHBvbHlfZGVjb21wXzEuZGVmYXVsdC5kZWNvbXAocCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udmV4ZXMgPSAoX2MgPSBwb2x5X2RlY29tcF8xLmRlZmF1bHQucXVpY2tEZWNvbXAocCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY20gPSB2ZWMyY3JlYXRlKCk7XHJcbiAgICAgICAgLy8gQWRkIGNvbnZleGVzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGNvbnZleGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBjb252ZXhcclxuICAgICAgICAgICAgdmFyIGMgPSBuZXcgQ29udmV4XzEuZGVmYXVsdCh1bmRlZmluZWQsIGNvbnZleGVzW2ldKTtcclxuICAgICAgICAgICAgLy8gTW92ZSBhbGwgdmVydGljZXMgc28gaXRzIGNlbnRlciBvZiBtYXNzIGlzIGluIHRoZSBsb2NhbCBjZW50ZXIgb2YgdGhlIGNvbnZleFxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiAhPT0gYy52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBjLnZlcnRpY2VzW2pdO1xyXG4gICAgICAgICAgICAgICAgc3ViKHYsIHYsIGMuY2VudGVyT2ZNYXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KGNtLCBjLmNlbnRlck9mTWFzcyk7XHJcbiAgICAgICAgICAgIGMgPSBuZXcgQ29udmV4XzEuZGVmYXVsdCh1bmRlZmluZWQsIGMudmVydGljZXMpO1xyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHNoYXBlXHJcbiAgICAgICAgICAgIHRoaXMuYWRkU2hhcGUoYywgY20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkanVzdENlbnRlck9mTWFzcygpO1xyXG4gICAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSBzaGFwZSBvZmZzZXRzIHNvIHRoZWlyIGNlbnRlciBvZiBtYXNzIGJlY29tZXMgdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgKiBAbWV0aG9kIGFkanVzdENlbnRlck9mTWFzc1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHsgcG9zaXRpb246IFswLCAwXSB9KTtcclxuICAgICAqICAgICB2YXIgc2hhcGUgPSBuZXcgQ2lyY2xlKHsgcmFkaXVzOiAxIH0pO1xyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUsIFsxLCAwXSwgMCk7XHJcbiAgICAgKiAgICAgYm9keS5hZGp1c3RDZW50ZXJPZk1hc3MoKTtcclxuICAgICAqICAgICBjb25zb2xlLmxvZyhib2R5LnBvc2l0aW9uKTsgLy8gWzEsIDBdXHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coc2hhcGUucG9zaXRpb24pOyAvLyBbMCwgMF1cclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuYWRqdXN0Q2VudGVyT2ZNYXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMiA9IHZlYzJjcmVhdGUoKSwgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDMgPSB2ZWMyY3JlYXRlKCksIGFkanVzdENlbnRlck9mTWFzc190bXA0ID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBvZmZzZXRfdGltZXNfYXJlYSA9IGFkanVzdENlbnRlck9mTWFzc190bXAyLCBzdW0gPSBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMywgY20gPSBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wNCwgdG90YWxBcmVhID0gMDtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQoc3VtLCAwLCAwKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gdGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnNoYXBlc1tpXTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUob2Zmc2V0X3RpbWVzX2FyZWEsIHMucG9zaXRpb24sIHMuYXJlYSk7XHJcbiAgICAgICAgICAgIGFkZChzdW0sIHN1bSwgb2Zmc2V0X3RpbWVzX2FyZWEpO1xyXG4gICAgICAgICAgICB0b3RhbEFyZWEgKz0gcy5hcmVhO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShjbSwgc3VtLCAxIC8gdG90YWxBcmVhKTtcclxuICAgICAgICAvLyBOb3cgbW92ZSBhbGwgc2hhcGVzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zaGFwZXNbaV07XHJcbiAgICAgICAgICAgIHN1YihzLnBvc2l0aW9uLCBzLnBvc2l0aW9uLCBjbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1vdmUgdGhlIGJvZHkgcG9zaXRpb24gdG9vXHJcbiAgICAgICAgYWRkKHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb24sIGNtKTtcclxuICAgICAgICAvLyBBbmQgY29uY2F2ZSBwYXRoXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuY29uY2F2ZVBhdGggJiYgaSA8IHRoaXMuY29uY2F2ZVBhdGgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc3ViKHRoaXMuY29uY2F2ZVBhdGhbaV0sIHRoaXMuY29uY2F2ZVBhdGhbaV0sIGNtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGZvcmNlIG9uIHRoZSBib2R5IHRvIHplcm8uXHJcbiAgICAgKiBAbWV0aG9kIHNldFplcm9Gb3JjZVxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5zZXRaZXJvRm9yY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGYgPSB0aGlzLmZvcmNlO1xyXG4gICAgICAgIGZbMF0gPSBmWzFdID0gdGhpcy5hbmd1bGFyRm9yY2UgPSAwO1xyXG4gICAgfTtcclxuICAgIEJvZHkucHJvdG90eXBlLnJlc2V0Q29uc3RyYWludFZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiID0gdGhpcywgdmxhbWJkYSA9IGIudmxhbWJkYTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodmxhbWJkYSwgMCwgMCk7XHJcbiAgICAgICAgYi53bGFtYmRhID0gMDtcclxuICAgIH07XHJcbiAgICBCb2R5LnByb3RvdHlwZS5hZGRDb25zdHJhaW50VmVsb2NpdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGIgPSB0aGlzLCB2ID0gYi52ZWxvY2l0eTtcclxuICAgICAgICBhZGQodiwgdiwgYi52bGFtYmRhKTtcclxuICAgICAgICBiLmFuZ3VsYXJWZWxvY2l0eSArPSBiLndsYW1iZGE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBkYW1waW5nLCBzZWUgPGEgaHJlZj1cImh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9idWxsZXQvaXNzdWVzL2RldGFpbD9pZD03NFwiPnRoaXM8L2E+IGZvciBkZXRhaWxzLlxyXG4gICAgICogQG1ldGhvZCBhcHBseURhbXBpbmdcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gZHQgQ3VycmVudCB0aW1lIHN0ZXBcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuYXBwbHlEYW1waW5nID0gZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gQm9keS5EWU5BTUlDKSB7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy52ZWxvY2l0eTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUodiwgdiwgTWF0aC5wb3coMSAtIHRoaXMuZGFtcGluZywgZHQpKTtcclxuICAgICAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKj0gTWF0aC5wb3coMSAtIHRoaXMuYW5ndWxhckRhbXBpbmcsIGR0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXYWtlIHRoZSBib2R5IHVwLiBOb3JtYWxseSB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRoaXMsIGFzIHRoZSBib2R5IGlzIGF1dG9tYXRpY2FsbHkgYXdva2VuIGF0IGV2ZW50cyBzdWNoIGFzIGNvbGxpc2lvbnMuXHJcbiAgICAgKiBTZXRzIHRoZSBzbGVlcFN0YXRlIHRvIHt7I2Nyb3NzTGluayBcIkJvZHkvQVdBS0U6cHJvcGVydHlcIn19Qm9keS5BV0FLRXt7L2Nyb3NzTGlua319IGFuZCBlbWl0cyB0aGUgd2FrZVVwIGV2ZW50IGlmIHRoZSBib2R5IHdhc24ndCBhd2FrZSBiZWZvcmUuXHJcbiAgICAgKiBAbWV0aG9kIHdha2VVcFxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS53YWtlVXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNsZWVwU3RhdGU7XHJcbiAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcclxuICAgICAgICB0aGlzLmlkbGVUaW1lID0gMDtcclxuICAgICAgICBpZiAocyAhPT0gQm9keS5BV0FLRSkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCB3YWtlVXBFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRm9yY2UgYm9keSBzbGVlcFxyXG4gICAgICogQG1ldGhvZCBzbGVlcFxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQSU5HO1xyXG4gICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gdGhpcy5hbmd1bGFyRm9yY2UgPSAwO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh0aGlzLnZlbG9jaXR5LCAwLCAwKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodGhpcy5mb3JjZSwgMCwgMCk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgc2xlZXBFdmVudCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgZXZlcnkgdGltZXN0ZXAgdG8gdXBkYXRlIGludGVybmFsIHNsZWVwIHRpbWVyIGFuZCBjaGFuZ2Ugc2xlZXAgc3RhdGUgaWYgbmVlZGVkLlxyXG4gICAgICogQG1ldGhvZCBzbGVlcFRpY2tcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSB3b3JsZCB0aW1lIGluIHNlY29uZHNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udFNsZWVwXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHRcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuc2xlZXBUaWNrID0gZnVuY3Rpb24gKHRpbWUsIGRvbnRTbGVlcCwgZHQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWxsb3dTbGVlcCB8fCB0aGlzLnR5cGUgPT09IEJvZHkuU0xFRVBJTkcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndhbnRzVG9TbGVlcCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBzcGVlZFNxdWFyZWQgPSB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkTGVuZ3RoKHRoaXMudmVsb2NpdHkpICsgTWF0aC5wb3codGhpcy5hbmd1bGFyVmVsb2NpdHksIDIpLCBzcGVlZExpbWl0U3F1YXJlZCA9IE1hdGgucG93KHRoaXMuc2xlZXBTcGVlZExpbWl0LCAyKTtcclxuICAgICAgICAvLyBBZGQgdG8gaWRsZSB0aW1lXHJcbiAgICAgICAgaWYgKHNwZWVkU3F1YXJlZCA+PSBzcGVlZExpbWl0U3F1YXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWUgKz0gZHQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgIT09IEJvZHkuU0xFRVBZKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQWTtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsIHNsZWVweUV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pZGxlVGltZSA+IHRoaXMuc2xlZXBUaW1lTGltaXQpIHtcclxuICAgICAgICAgICAgaWYgKCFkb250U2xlZXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2xlZXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FudHNUb1NsZWVwID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBib2R5IGlzIG92ZXJsYXBwaW5nIGFub3RoZXIgYm9keS4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG9ubHkgd29ya3MgaWYgdGhlIGJvZHkgd2FzIGFkZGVkIHRvIGEgV29ybGQgYW5kIGlmIGF0IGxlYXN0IG9uZSBzdGVwIHdhcyB0YWtlbi5cclxuICAgICAqIEBtZXRob2Qgb3ZlcmxhcHNcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgICBpZiAoIXRoaXMud29ybGQpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZC5vdmVybGFwS2VlcGVyLmJvZGllc0FyZU92ZXJsYXBwaW5nKHRoaXMsIGJvZHkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTW92ZSB0aGUgYm9keSBmb3J3YXJkIGluIHRpbWUgZ2l2ZW4gaXRzIGN1cnJlbnQgdmVsb2NpdHkuXHJcbiAgICAgKiBAbWV0aG9kIGludGVncmF0ZVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBkdFxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5pbnRlZ3JhdGUgPSBmdW5jdGlvbiAoZHQpIHtcclxuICAgICAgICB2YXIgbWludiA9IHRoaXMuaW52TWFzcywgZiA9IHRoaXMuZm9yY2UsIHBvcyA9IHRoaXMucG9zaXRpb24sIHZlbG8gPSB0aGlzLnZlbG9jaXR5O1xyXG4gICAgICAgIC8vIFNhdmUgb2xkIHBvc2l0aW9uXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh0aGlzLnByZXZpb3VzUG9zaXRpb24sIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNBbmdsZSA9IHRoaXMuYW5nbGU7XHJcbiAgICAgICAgLy8gVmVsb2NpdHkgdXBkYXRlXHJcbiAgICAgICAgaWYgKCF0aGlzLmZpeGVkUm90YXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKz0gdGhpcy5hbmd1bGFyRm9yY2UgKiB0aGlzLmludkluZXJ0aWEgKiBkdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUoaW50ZWdyYXRlX2ZoTWludiwgZiwgZHQgKiBtaW52KTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5tdWx0aXBseShpbnRlZ3JhdGVfZmhNaW52LCB0aGlzLm1hc3NNdWx0aXBsaWVyLCBpbnRlZ3JhdGVfZmhNaW52KTtcclxuICAgICAgICBhZGQodmVsbywgaW50ZWdyYXRlX2ZoTWludiwgdmVsbyk7XHJcbiAgICAgICAgLy8gQ0NEXHJcbiAgICAgICAgaWYgKCF0aGlzLmludGVncmF0ZVRvVGltZU9mSW1wYWN0KGR0KSkge1xyXG4gICAgICAgICAgICAvLyBSZWd1bGFyIHBvc2l0aW9uIHVwZGF0ZVxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShpbnRlZ3JhdGVfdmVsb2R0LCB2ZWxvLCBkdCk7XHJcbiAgICAgICAgICAgIGFkZChwb3MsIHBvcywgaW50ZWdyYXRlX3ZlbG9kdCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5maXhlZFJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlICs9IHRoaXMuYW5ndWxhclZlbG9jaXR5ICogZHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIEJvZHkucHJvdG90eXBlLmludGVncmF0ZVRvVGltZU9mSW1wYWN0ID0gZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICghdGhpcy53b3JsZClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgcmF5Y2FzdF9yZXN1bHRfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgdmFyIHJheSA9IG5ldyByYXlfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgbW9kZTogcmF5XzEuZGVmYXVsdC5DTE9TRVNULFxyXG4gICAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICB2YXIgZW5kID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBzdGFydFRvRW5kID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciByZW1lbWJlclBvc2l0aW9uID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmNjZFNwZWVkVGhyZXNob2xkIDwgMCB8fCB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkTGVuZ3RoKHRoaXMudmVsb2NpdHkpIDwgTWF0aC5wb3codGhpcy5jY2RTcGVlZFRocmVzaG9sZCwgMikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZ25vcmUgYWxsIHRoZSBpZ25vcmVkIGJvZHkgcGFpcnNcclxuICAgICAgICAvLyBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBkb25lIHNvbWV3aGVyZSBlbHNlIGZvciBvcHRpbWl6YXRpb25cclxuICAgICAgICB2YXIgaWdub3JlQm9kaWVzID0gW107XHJcbiAgICAgICAgdmFyIGRpc2FibGVkUGFpcnMgPSB0aGlzLndvcmxkLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzYWJsZWRQYWlycy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICB2YXIgYm9keUEgPSBkaXNhYmxlZFBhaXJzW2ldO1xyXG4gICAgICAgICAgICB2YXIgYm9keUIgPSBkaXNhYmxlZFBhaXJzW2kgKyAxXTtcclxuICAgICAgICAgICAgaWYgKGJvZHlBID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZ25vcmVCb2RpZXMucHVzaChib2R5Qik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYm9keUIgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGlnbm9yZUJvZGllcy5wdXNoKGJvZHlBKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUoZGlyZWN0aW9uLCB0aGlzLnZlbG9jaXR5KTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShlbmQsIHRoaXMudmVsb2NpdHksIGR0KTtcclxuICAgICAgICBhZGQoZW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHN1YihzdGFydFRvRW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHZhciBzdGFydFRvRW5kQW5nbGUgPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xyXG4gICAgICAgIHZhciBsZW4gPSB2ZWMyXzEuZGVmYXVsdC5sZW5ndGgoc3RhcnRUb0VuZCk7XHJcbiAgICAgICAgdmFyIHRpbWVPZkltcGFjdCA9IDE7XHJcbiAgICAgICAgdmFyIGhpdEJvZHkgPSBudWxsO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkocmF5LmZyb20sIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkocmF5LnRvLCBlbmQpO1xyXG4gICAgICAgIHJheS51cGRhdGUoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGVzW2ldO1xyXG4gICAgICAgICAgICByZXN1bHQucmVzZXQoKTtcclxuICAgICAgICAgICAgcmF5LmNvbGxpc2lvbkdyb3VwID0gc2hhcGUuY29sbGlzaW9uR3JvdXA7XHJcbiAgICAgICAgICAgIHJheS5jb2xsaXNpb25NYXNrID0gc2hhcGUuY29sbGlzaW9uTWFzaztcclxuICAgICAgICAgICAgdGhpcy53b3JsZC5yYXljYXN0KHJlc3VsdCwgcmF5KTtcclxuICAgICAgICAgICAgaGl0Qm9keSA9IChfYSA9IHJlc3VsdC5ib2R5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIWhpdEJvZHkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKGhpdEJvZHkgPT09IHRoaXMgfHwgaWdub3JlQm9kaWVzLmluZGV4T2YoaGl0Qm9keSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBoaXRCb2R5ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGl0Qm9keSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFoaXRCb2R5IHx8ICF0aW1lT2ZJbXBhY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuZ2V0SGl0UG9pbnQoZW5kLCByYXkpO1xyXG4gICAgICAgIHN1YihzdGFydFRvRW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHRpbWVPZkltcGFjdCA9IHZlYzJfMS5kZWZhdWx0LmRpc3RhbmNlKGVuZCwgdGhpcy5wb3NpdGlvbikgLyBsZW47IC8vIGd1ZXNzXHJcbiAgICAgICAgdmFyIHJlbWVtYmVyQW5nbGUgPSB0aGlzLmFuZ2xlO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkocmVtZW1iZXJQb3NpdGlvbiwgdGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgLy8gR290IGEgc3RhcnQgYW5kIGVuZCBwb2ludC4gQXBwcm94aW1hdGUgdGltZSBvZiBpbXBhY3QgdXNpbmcgYmluYXJ5IHNlYXJjaFxyXG4gICAgICAgIHZhciBpdGVyID0gMDtcclxuICAgICAgICB2YXIgdG1pbiA9IDA7XHJcbiAgICAgICAgdmFyIHRtaWQgPSB0aW1lT2ZJbXBhY3Q7XHJcbiAgICAgICAgdmFyIHRtYXggPSAxO1xyXG4gICAgICAgIHdoaWxlICh0bWF4ID49IHRtaW4gJiYgaXRlciA8IHRoaXMuY2NkSXRlcmF0aW9ucykge1xyXG4gICAgICAgICAgICBpdGVyKys7XHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbWlkcG9pbnRcclxuICAgICAgICAgICAgdG1pZCA9ICh0bWF4ICsgdG1pbikgLyAyO1xyXG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSBib2R5IHRvIHRoYXQgcG9pbnRcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUoaW50ZWdyYXRlX3ZlbG9kdCwgc3RhcnRUb0VuZCwgdG1pZCk7XHJcbiAgICAgICAgICAgIGFkZCh0aGlzLnBvc2l0aW9uLCByZW1lbWJlclBvc2l0aW9uLCBpbnRlZ3JhdGVfdmVsb2R0KTtcclxuICAgICAgICAgICAgdGhpcy5hbmdsZSA9IHJlbWVtYmVyQW5nbGUgKyBzdGFydFRvRW5kQW5nbGUgKiB0bWlkO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcclxuICAgICAgICAgICAgLy8gY2hlY2sgb3ZlcmxhcFxyXG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSB0aGlzLmFhYmIub3ZlcmxhcHMoaGl0Qm9keS5hYWJiKSAmJiB0aGlzLndvcmxkLm5hcnJvd3BoYXNlLmJvZGllc092ZXJsYXAodGhpcywgaGl0Qm9keSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChvdmVybGFwcykge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlIG1heCB0byBzZWFyY2ggbG93ZXIgaW50ZXJ2YWxcclxuICAgICAgICAgICAgICAgIHRtYXggPSB0bWlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlIG1pbiB0byBzZWFyY2ggdXBwZXIgaW50ZXJ2YWxcclxuICAgICAgICAgICAgICAgIHRtaW4gPSB0bWlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpbWVPZkltcGFjdCA9IHRtYXg7IC8vIE5lZWQgdG8gZ3VhcmFudGVlIG92ZXJsYXAgdG8gcmVzb2x2ZSBjb2xsaXNpb25zXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh0aGlzLnBvc2l0aW9uLCByZW1lbWJlclBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLmFuZ2xlID0gcmVtZW1iZXJBbmdsZTtcclxuICAgICAgICAvLyBtb3ZlIHRvIFRPSVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKGludGVncmF0ZV92ZWxvZHQsIHN0YXJ0VG9FbmQsIHRpbWVPZkltcGFjdCk7XHJcbiAgICAgICAgYWRkKHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb24sIGludGVncmF0ZV92ZWxvZHQpO1xyXG4gICAgICAgIGlmICghdGhpcy5maXhlZFJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5nbGUgKz0gc3RhcnRUb0VuZEFuZ2xlICogdGltZU9mSW1wYWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCB2ZWxvY2l0eSBvZiBhIHBvaW50IGluIHRoZSBib2R5LlxyXG4gICAgICogQG1ldGhvZCBnZXRWZWxvY2l0eUF0UG9pbnRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSByZXN1bHQgQSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpblxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHJlbGF0aXZlUG9pbnQgQSB3b3JsZCBvcmllbnRlZCB2ZWN0b3IsIGluZGljYXRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludCB0byBnZXQgdGhlIHZlbG9jaXR5IGZyb21cclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgcmVzdWx0IHZlY3RvclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHtcclxuICAgICAqICAgICAgICAgbWFzczogMSxcclxuICAgICAqICAgICAgICAgdmVsb2NpdHk6IFsxLCAwXSxcclxuICAgICAqICAgICAgICAgYW5ndWxhclZlbG9jaXR5OiAxXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICogICAgIHZhciBwb2ludCA9IFsxLCAwXTtcclxuICAgICAqICAgICBib2R5LmdldFZlbG9jaXR5QXRQb2ludChyZXN1bHQsIHBvaW50KTtcclxuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpOyAvLyBbMSwgMV1cclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuZ2V0VmVsb2NpdHlBdFBvaW50ID0gZnVuY3Rpb24gKHJlc3VsdCwgcmVsYXRpdmVQb2ludCkge1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNyb3NzVloocmVzdWx0LCByZWxhdGl2ZVBvaW50LCB0aGlzLmFuZ3VsYXJWZWxvY2l0eSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QocmVzdWx0LCB0aGlzLnZlbG9jaXR5LCByZXN1bHQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEeW5hbWljIGJvZHkuXHJcbiAgICAgKiBAcHJvcGVydHkgRFlOQU1JQ1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgQm9keS5EWU5BTUlDID0gMTtcclxuICAgIC8qKlxyXG4gICAgICogU3RhdGljIGJvZHkuXHJcbiAgICAgKiBAcHJvcGVydHkgU1RBVElDXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBCb2R5LlNUQVRJQyA9IDI7XHJcbiAgICAvKipcclxuICAgICAqIEtpbmVtYXRpYyBib2R5LlxyXG4gICAgICogQHByb3BlcnR5IEtJTkVNQVRJQ1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgQm9keS5LSU5FTUFUSUMgPSA0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgQVdBS0VcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIEJvZHkuQVdBS0UgPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgU0xFRVBZXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBCb2R5LlNMRUVQWSA9IDE7XHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSBTTEVFUElOR1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgQm9keS5TTEVFUElORyA9IDI7XHJcbiAgICByZXR1cm4gQm9keTtcclxufShldmVudF9lbWl0dGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCb2R5O1xyXG4vKipcclxuICogQGV2ZW50IHNsZWVweVxyXG4gKi9cclxudmFyIHNsZWVweUV2ZW50ID0ge1xyXG4gICAgdHlwZTogXCJzbGVlcHlcIlxyXG59O1xyXG4vKipcclxuICogQGV2ZW50IHNsZWVwXHJcbiAqL1xyXG52YXIgc2xlZXBFdmVudCA9IHtcclxuICAgIHR5cGU6IFwic2xlZXBcIlxyXG59O1xyXG4vKipcclxuICogQGV2ZW50IHdha2V1cFxyXG4gKi9cclxudmFyIHdha2VVcEV2ZW50ID0ge1xyXG4gICAgdHlwZTogXCJ3YWtldXBcIlxyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgc3ByaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc3ByaW5nXCIpKTtcclxudmFyIGFwcGx5Rm9yY2VfciA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBhcHBseUZvcmNlX3JfdW5pdCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBhcHBseUZvcmNlX3UgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgYXBwbHlGb3JjZV9mID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGFwcGx5Rm9yY2VfcmkgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgYXBwbHlGb3JjZV9yaiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBhcHBseUZvcmNlX3RtcCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgTGluZWFyU3ByaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExpbmVhclNwcmluZywgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQSBzcHJpbmcsIGNvbm5lY3RpbmcgdHdvIGJvZGllcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgU3ByaW5nIGV4cGxpY2l0bHkgYWRkcyBmb3JjZSBhbmQgYW5ndWxhckZvcmNlIHRvIHRoZSBib2RpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIExpbmVhclNwcmluZ1xyXG4gICAgICogQGV4dGVuZHMgU3ByaW5nXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXN0TGVuZ3RoXSAgIEEgbnVtYmVyID4gMC4gRGVmYXVsdCBpcyB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB3b3JsZCBhbmNob3IgcG9pbnRzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdICBTcHJpbmcgY29uc3RhbnQgKHNlZSBIb29rZXMgTGF3KS4gQSBudW1iZXIgPj0gMC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nPTFdICAgICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy4gT3ZlcnJpZGVzIHRoZSBvcHRpb24gXCJsb2NhbEFuY2hvckFcIiBpZiBnaXZlbi5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckJdXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuIERlZmF1bHRzIHRvIHRoZSBib2R5IGNlbnRlci5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgc3ByaW5nID0gbmV3IExpbmVhclNwcmluZyhib2R5QSwgYm9keUIsIHtcclxuICAgICAqICAgICAgICAgc3RpZmZuZXNzOiAxMDAsXHJcbiAgICAgKiAgICAgICAgIGRhbXBpbmc6IDEsXHJcbiAgICAgKiAgICAgICAgIGxvY2FsQW5jaG9yQTogWzAsMF0sIC8vIGNlbnRlciBvZiBib2R5QVxyXG4gICAgICogICAgICAgICBsb2NhbEFuY2hvckI6IFswLDBdIC8vIGNlbnRlciBvZiBib2R5QlxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZFNwcmluZyhzcHJpbmcpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBMaW5lYXJTcHJpbmcoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sb2NhbEFuY2hvckEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBfdGhpcy5sb2NhbEFuY2hvckIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQW5jaG9yQSkge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KF90aGlzLmxvY2FsQW5jaG9yQSwgb3B0aW9ucy5sb2NhbEFuY2hvckEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQW5jaG9yQikge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KF90aGlzLmxvY2FsQW5jaG9yQiwgb3B0aW9ucy5sb2NhbEFuY2hvckIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmxkQW5jaG9yQSkge1xyXG4gICAgICAgICAgICBfdGhpcy5zZXRXb3JsZEFuY2hvckEob3B0aW9ucy53b3JsZEFuY2hvckEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmxkQW5jaG9yQikge1xyXG4gICAgICAgICAgICBfdGhpcy5zZXRXb3JsZEFuY2hvckIob3B0aW9ucy53b3JsZEFuY2hvckIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd29ybGRBbmNob3JBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIHdvcmxkQW5jaG9yQiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIF90aGlzLmdldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpO1xyXG4gICAgICAgIF90aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xyXG4gICAgICAgIHZhciB3b3JsZERpc3RhbmNlID0gdmVjMl8xLmRlZmF1bHQuZGlzdGFuY2Uod29ybGRBbmNob3JBLCB3b3JsZEFuY2hvckIpO1xyXG4gICAgICAgIF90aGlzLnJlc3RMZW5ndGggPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVzdExlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd29ybGREaXN0YW5jZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQSwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29ybGRBbmNob3JBXHJcbiAgICAgKi9cclxuICAgIExpbmVhclNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24gKHdvcmxkQW5jaG9yQSkge1xyXG4gICAgICAgIHRoaXMuYm9keUEudG9Mb2NhbEZyYW1lKHRoaXMubG9jYWxBbmNob3JBLCB3b3JsZEFuY2hvckEpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCB1c2luZyB3b3JsZCBjb29yZGluYXRlcy5cclxuICAgICAqIEBtZXRob2Qgc2V0V29ybGRBbmNob3JCXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JsZEFuY2hvckJcclxuICAgICAqL1xyXG4gICAgTGluZWFyU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbiAod29ybGRBbmNob3JCKSB7XHJcbiAgICAgICAgdGhpcy5ib2R5Qi50b0xvY2FsRnJhbWUodGhpcy5sb2NhbEFuY2hvckIsIHdvcmxkQW5jaG9yQik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQG1ldGhvZCBnZXRXb3JsZEFuY2hvckFcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIExpbmVhclNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMuYm9keUEudG9Xb3JsZEZyYW1lKHJlc3VsdCwgdGhpcy5sb2NhbEFuY2hvckEpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cclxuICAgICAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JCXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBMaW5lYXJTcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICB0aGlzLmJvZHlCLnRvV29ybGRGcmFtZShyZXN1bHQsIHRoaXMubG9jYWxBbmNob3JCKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCBhcHBseUZvcmNlXHJcbiAgICAgKi9cclxuICAgIExpbmVhclNwcmluZy5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLCBkID0gdGhpcy5kYW1waW5nLCBsID0gdGhpcy5yZXN0TGVuZ3RoLCBib2R5QSA9IHRoaXMuYm9keUEsIGJvZHlCID0gdGhpcy5ib2R5QiwgciA9IGFwcGx5Rm9yY2Vfciwgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQsIHUgPSBhcHBseUZvcmNlX3UsIGYgPSBhcHBseUZvcmNlX2YsIHRtcCA9IGFwcGx5Rm9yY2VfdG1wO1xyXG4gICAgICAgIHZhciB3b3JsZEFuY2hvckEgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSwgd29ybGRBbmNob3JCID0gYXBwbHlGb3JjZV93b3JsZEFuY2hvckIsIHJpID0gYXBwbHlGb3JjZV9yaSwgcmogPSBhcHBseUZvcmNlX3JqO1xyXG4gICAgICAgIC8vIEdldCB3b3JsZCBhbmNob3JzXHJcbiAgICAgICAgdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcclxuICAgICAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xyXG4gICAgICAgIC8vIEdldCBvZmZzZXQgcG9pbnRzXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QocmksIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHJqLCB3b3JsZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcclxuICAgICAgICAvLyBDb21wdXRlIGRpc3RhbmNlIHZlY3RvciBiZXR3ZWVuIHdvcmxkIGFuY2hvciBwb2ludHNcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyLCB3b3JsZEFuY2hvckIsIHdvcmxkQW5jaG9yQSk7XHJcbiAgICAgICAgdmFyIHJsZW4gPSB2ZWMyXzEuZGVmYXVsdC5sZW5ndGgocik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKHJfdW5pdCwgcik7XHJcbiAgICAgICAgLy8gQ29tcHV0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBvZiB0aGUgYW5jaG9yIHBvaW50cywgdVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHUsIGJvZHlCLnZlbG9jaXR5LCBib2R5QS52ZWxvY2l0eSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY3Jvc3NaVih0bXAsIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSwgcmopO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZCh1LCB1LCB0bXApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNyb3NzWlYodG1wLCBib2R5QS5hbmd1bGFyVmVsb2NpdHksIHJpKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdCh1LCB1LCB0bXApO1xyXG4gICAgICAgIC8vIEYgPSAtIGsgKiAoIHggLSBMICkgLSBEICogKCB1IClcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShmLCByX3VuaXQsIC1rICogKHJsZW4gLSBsKSAtIGQgKiB2ZWMyXzEuZGVmYXVsdC5kb3QodSwgcl91bml0KSk7XHJcbiAgICAgICAgLy8gQWRkIGZvcmNlcyB0byBib2RpZXNcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChib2R5QS5mb3JjZSwgYm9keUEuZm9yY2UsIGYpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChib2R5Qi5mb3JjZSwgYm9keUIuZm9yY2UsIGYpO1xyXG4gICAgICAgIC8vIEFuZ3VsYXIgZm9yY2VcclxuICAgICAgICB2YXIgcmlfeF9mID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmksIGYpO1xyXG4gICAgICAgIHZhciByal94X2YgPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyaiwgZik7XHJcbiAgICAgICAgYm9keUEuYW5ndWxhckZvcmNlIC09IHJpX3hfZjtcclxuICAgICAgICBib2R5Qi5hbmd1bGFyRm9yY2UgKz0gcmpfeF9mO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMaW5lYXJTcHJpbmc7XHJcbn0oc3ByaW5nXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMaW5lYXJTcHJpbmc7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBzcHJpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zcHJpbmdcIikpO1xyXG52YXIgUm90YXRpb25hbFNwcmluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSb3RhdGlvbmFsU3ByaW5nLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJvdGF0aW9uYWwgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMgcm90YXRpb24uIFRoaXMgc3ByaW5nIGV4cGxpY2l0bHkgYWRkcyBhbmd1bGFyRm9yY2UgKHRvcnF1ZSkgdG8gdGhlIGJvZGllcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgc3ByaW5nIGNhbiBiZSBjb21iaW5lZCB3aXRoIGEge3sjY3Jvc3NMaW5rIFwiUmV2b2x1dGVDb25zdHJhaW50XCJ9fXt7L2Nyb3NzTGlua319IHRvIG1ha2UsIGZvciBleGFtcGxlLCBhIG1vdXNlIHRyYXAuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIFJvdGF0aW9uYWxTcHJpbmdcclxuICAgICAqIEBleHRlbmRzIFNwcmluZ1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzdEFuZ2xlXSBUaGUgcmVsYXRpdmUgYW5nbGUgb2YgYm9kaWVzIGF0IHdoaWNoIHRoZSBzcHJpbmcgaXMgYXQgcmVzdC4gSWYgbm90IGdpdmVuLCBpdCdzIHNldCB0byB0aGUgY3VycmVudCByZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHRoZSBib2RpZXMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzPTEwMF0gU3ByaW5nIGNvbnN0YW50IChzZWUgSG9va2VzIExhdykuIEEgbnVtYmVyID49IDAuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZz0xXSBBIG51bWJlciA+PSAwLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIHNwcmluZyA9IG5ldyBSb3RhdGlvbmFsU3ByaW5nKGJvZHlBLCBib2R5Qiwge1xyXG4gICAgICogICAgICAgICBzdGlmZm5lc3M6IDEwMCxcclxuICAgICAqICAgICAgICAgZGFtcGluZzogMVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZFNwcmluZyhzcHJpbmcpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSb3RhdGlvbmFsU3ByaW5nKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzdCBhbmdsZSBvZiB0aGUgc3ByaW5nLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSByZXN0QW5nbGVcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnJlc3RBbmdsZSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXN0QW5nbGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxyXG4gICAgICogQG1ldGhvZCBhcHBseUZvcmNlXHJcbiAgICAgKi9cclxuICAgIFJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcywgZCA9IHRoaXMuZGFtcGluZywgbCA9IHRoaXMucmVzdEFuZ2xlLCBib2R5QSA9IHRoaXMuYm9keUEsIGJvZHlCID0gdGhpcy5ib2R5QiwgeCA9IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGUsIHUgPSBib2R5Qi5hbmd1bGFyVmVsb2NpdHkgLSBib2R5QS5hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgdmFyIHRvcnF1ZSA9IC1rICogKHggLSBsKSAtIGQgKiB1O1xyXG4gICAgICAgIGJvZHlBLmFuZ3VsYXJGb3JjZSAtPSB0b3JxdWU7XHJcbiAgICAgICAgYm9keUIuYW5ndWxhckZvcmNlICs9IHRvcnF1ZTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gUm90YXRpb25hbFNwcmluZztcclxufShzcHJpbmdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJvdGF0aW9uYWxTcHJpbmc7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTcHJpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIHt7I2Nyb3NzTGluayBcIkxpbmVhclNwcmluZ1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiUm90YXRpb25hbFNwcmluZ1wifX17ey9jcm9zc0xpbmt9fS4gTm90IHN1cHBvc2VkIHRvIGJlIHVzZWQgZGlyZWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIFNwcmluZ1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzPTEwMF0gIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gICAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuIERlZmF1bHRzIHRvIHRoZSBib2R5IGNlbnRlci5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBPdmVycmlkZXMgdGhlIG9wdGlvbiBcImxvY2FsQW5jaG9yQVwiIGlmIGdpdmVuLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU3ByaW5nKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RpZmZuZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxMDA7XHJcbiAgICAgICAgdGhpcy5kYW1waW5nID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhbXBpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XHJcbiAgICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuICAgIH1cclxuICAgIHJldHVybiBTcHJpbmc7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNwcmluZztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIGJvZHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9ib2R5XCIpKTtcclxudmFyIGNvbnN0cmFpbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vY29uc3RyYWludHMvY29uc3RyYWludFwiKSk7XHJcbnZhciBmcmljdGlvbl9lcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvZnJpY3Rpb24tZXF1YXRpb25cIikpO1xyXG52YXIgd29ybGRWZWxvY2l0eSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgcmVsYXRpdmVQb2ludCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgdG1wVmVjID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBUb3BEb3duVmVoaWNsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIFRvcERvd25WZWhpY2xlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGNsYXNzIHdpbGwgYmUgbW92ZWQgb3V0IG9mIHRoZSBjb3JlIGxpYnJhcnkgaW4gZnV0dXJlIHZlcnNpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gY2hhc3Npc0JvZHkgQSBkeW5hbWljIGJvZHksIGFscmVhZHkgYWRkZWQgdG8gdGhlIHdvcmxkLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIENyZWF0ZSBhIGR5bmFtaWMgYm9keSBmb3IgdGhlIGNoYXNzaXNcclxuICAgICAqICAgICB2YXIgY2hhc3Npc0JvZHkgPSBuZXcgQm9keSh7XHJcbiAgICAgKiAgICAgICAgIG1hc3M6IDFcclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB2YXIgYm94U2hhcGUgPSBuZXcgQm94KHsgd2lkdGg6IDAuNSwgaGVpZ2h0OiAxIH0pO1xyXG4gICAgICogICAgIGNoYXNzaXNCb2R5LmFkZFNoYXBlKGJveFNoYXBlKTtcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KGNoYXNzaXNCb2R5KTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gQ3JlYXRlIHRoZSB2ZWhpY2xlXHJcbiAgICAgKiAgICAgdmFyIHZlaGljbGUgPSBuZXcgVG9wRG93blZlaGljbGUoY2hhc3Npc0JvZHkpO1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBBZGQgb25lIGZyb250IHdoZWVsIGFuZCBvbmUgYmFjayB3aGVlbCAtIHdlIGRvbid0IGFjdHVhbGx5IG5lZWQgZm91ciA6KVxyXG4gICAgICogICAgIHZhciBmcm9udFdoZWVsID0gdmVoaWNsZS5hZGRXaGVlbCh7XHJcbiAgICAgKiAgICAgICAgIGxvY2FsUG9zaXRpb246IFswLCAwLjVdIC8vIGZyb250XHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgZnJvbnRXaGVlbC5zZXRTaWRlRnJpY3Rpb24oNCk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIEJhY2sgd2hlZWxcclxuICAgICAqICAgICB2YXIgYmFja1doZWVsID0gdmVoaWNsZS5hZGRXaGVlbCh7XHJcbiAgICAgKiAgICAgICAgIGxvY2FsUG9zaXRpb246IFswLCAtMC41XSAvLyBiYWNrXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgYmFja1doZWVsLnNldFNpZGVGcmljdGlvbigzKTsgLy8gTGVzcyBzaWRlIGZyaWN0aW9uIG9uIGJhY2sgd2hlZWwgbWFrZXMgaXQgZWFzaWVyIHRvIGRyaWZ0XHJcbiAgICAgKiAgICAgdmVoaWNsZS5hZGRUb1dvcmxkKHdvcmxkKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gU3RlZXIgdmFsdWUgemVybyBtZWFucyBzdHJhaWdodCBmb3J3YXJkLiBQb3NpdGl2ZSBpcyBsZWZ0IGFuZCBuZWdhdGl2ZSByaWdodC5cclxuICAgICAqICAgICBmcm9udFdoZWVsLnN0ZWVyVmFsdWUgPSBNYXRoLlBJIC8gMTY7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIEVuZ2luZSBmb3JjZSBmb3J3YXJkXHJcbiAgICAgKiAgICAgYmFja1doZWVsLmVuZ2luZUZvcmNlID0gMTA7XHJcbiAgICAgKiAgICAgYmFja1doZWVsLnNldEJyYWtlRm9yY2UoMCk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFRvcERvd25WZWhpY2xlKGNoYXNzaXNCb2R5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBBIGR1bW15IGJvZHkgdG8gY29uc3RyYWluIHRoZSBjaGFzc2lzIHRvXHJcbiAgICAgICAgdGhpcy5ncm91bmRCb2R5ID0gbmV3IGJvZHlfMS5kZWZhdWx0KHsgbWFzczogMCB9KTtcclxuICAgICAgICB0aGlzLndoZWVscyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2hhc3Npc0JvZHkgPSBjaGFzc2lzQm9keTtcclxuICAgICAgICB0aGlzLnByZVN0ZXBDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBhZGRUb1dvcmxkXHJcbiAgICAgKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxyXG4gICAgICovXHJcbiAgICBUb3BEb3duVmVoaWNsZS5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uICh3b3JsZCkge1xyXG4gICAgICAgIHRoaXMud29ybGQgPSB3b3JsZDtcclxuICAgICAgICB3b3JsZC5hZGRCb2R5KHRoaXMuZ3JvdW5kQm9keSk7XHJcbiAgICAgICAgd29ybGQub24oXCJwcmVTdGVwXCIsIHRoaXMucHJlU3RlcENhbGxiYWNrLCB0aGlzKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2hlZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB3aGVlbCA9IHRoaXMud2hlZWxzW2ldO1xyXG4gICAgICAgICAgICB3b3JsZC5hZGRDb25zdHJhaW50KHdoZWVsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUZyb21Xb3JsZFxyXG4gICAgICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICAgICAqL1xyXG4gICAgVG9wRG93blZlaGljbGUucHJvdG90eXBlLnJlbW92ZUZyb21Xb3JsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgd29ybGQgPSB0aGlzLndvcmxkO1xyXG4gICAgICAgIGlmICh3b3JsZCkge1xyXG4gICAgICAgICAgICB3b3JsZC5yZW1vdmVCb2R5KHRoaXMuZ3JvdW5kQm9keSk7XHJcbiAgICAgICAgICAgIHdvcmxkLm9mZigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndoZWVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbHNbaV07XHJcbiAgICAgICAgICAgICAgICB3b3JsZC5yZW1vdmVDb25zdHJhaW50KHdoZWVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLndvcmxkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgYWRkV2hlZWxcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbd2hlZWxPcHRpb25zXVxyXG4gICAgICogQHJldHVybiB7V2hlZWxDb25zdHJhaW50fVxyXG4gICAgICovXHJcbiAgICBUb3BEb3duVmVoaWNsZS5wcm90b3R5cGUuYWRkV2hlZWwgPSBmdW5jdGlvbiAod2hlZWxPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHdoZWVsID0gbmV3IFdoZWVsQ29uc3RyYWludCh0aGlzLCB3aGVlbE9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMud2hlZWxzLnB1c2god2hlZWwpO1xyXG4gICAgICAgIHJldHVybiB3aGVlbDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIFRvcERvd25WZWhpY2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndoZWVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLndoZWVsc1tpXS51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIFRvcERvd25WZWhpY2xlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUb3BEb3duVmVoaWNsZTtcclxudmFyIFdoZWVsQ29uc3RyYWludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhXaGVlbENvbnN0cmFpbnQsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBXaGVlbENvbnN0cmFpbnRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMge0NvbnN0cmFpbnR9XHJcbiAgICAgKiBAcGFyYW0ge1ZlaGljbGV9IHZlaGljbGVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsRm9yd2FyZFZlY3Rvcl0gVGhlIGxvY2FsIHdoZWVsIGZvcndhcmQgdmVjdG9yIGluIGxvY2FsIGJvZHkgc3BhY2UuIERlZmF1bHQgaXMgemVyby5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsUG9zaXRpb25dIFRoZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgd2hlZW4gaW4gdGhlIGNoYXNzaXMgYm9keS4gRGVmYXVsdCBpcyB6ZXJvIC0gdGhlIGNlbnRlciBvZiB0aGUgYm9keS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnNpZGVGcmljdGlvbj01XSBUaGUgbWF4IGZyaWN0aW9uIGZvcmNlIGluIHRoZSBzaWRld2F5cyBkaXJlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFdoZWVsQ29uc3RyYWludCh2ZWhpY2xlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IFxyXG4gICAgICAgIC8vIFRPRE86IEkgaGF2ZSBubyBpZGVhIHdoYXQga2luZCBvZiBjb25zdHJhaW50IHRoaXMgaXMgc3VwcG9zZWQgdG8gYmUuIEl0IHNlZW1zIHRoaXMgd2FzIHVuZGVmaW5lZCBpbiB0aGUgb3JpZ2luYWwgY29kZS5cclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2ZWhpY2xlLmNoYXNzaXNCb2R5LCB2ZWhpY2xlLmdyb3VuZEJvZHksIDApIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc3RlZXJWYWx1ZSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZ2luZUZvcmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZW5naW5lRm9yY2UgPSAwO1xyXG4gICAgICAgIF90aGlzLnZlaGljbGUgPSB2ZWhpY2xlO1xyXG4gICAgICAgIF90aGlzLmZvcndhcmRFcXVhdGlvbiA9IG5ldyBmcmljdGlvbl9lcXVhdGlvbl8xLmRlZmF1bHQodmVoaWNsZS5jaGFzc2lzQm9keSwgdmVoaWNsZS5ncm91bmRCb2R5KTtcclxuICAgICAgICBfdGhpcy5zaWRlRXF1YXRpb24gPSBuZXcgZnJpY3Rpb25fZXF1YXRpb25fMS5kZWZhdWx0KHZlaGljbGUuY2hhc3Npc0JvZHksIHZlaGljbGUuZ3JvdW5kQm9keSk7XHJcbiAgICAgICAgX3RoaXMuc2V0U2lkZUZyaWN0aW9uKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWRlRnJpY3Rpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDUpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGxvY2FsRm9yd2FyZFZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxvY2FsRm9yd2FyZFZlY3RvciA9IHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoMCwgMSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbEZvcndhcmRWZWN0b3IpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShfdGhpcy5sb2NhbEZvcndhcmRWZWN0b3IsIG9wdGlvbnMubG9jYWxGb3J3YXJkVmVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gbG9jYWxQb3NpdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxvY2FsUG9zaXRpb24gPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShfdGhpcy5sb2NhbFBvc2l0aW9uLCBvcHRpb25zLmxvY2FsUG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMucHVzaChfdGhpcy5mb3J3YXJkRXF1YXRpb24pO1xyXG4gICAgICAgIF90aGlzLmVxdWF0aW9ucy5wdXNoKF90aGlzLnNpZGVFcXVhdGlvbik7XHJcbiAgICAgICAgX3RoaXMuc2V0QnJha2VGb3JjZSgwKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2Qgc2V0QnJha2VGb3JjZVxyXG4gICAgICovXHJcbiAgICBXaGVlbENvbnN0cmFpbnQucHJvdG90eXBlLnNldEJyYWtlRm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcclxuICAgICAgICB0aGlzLmZvcndhcmRFcXVhdGlvbi5zZXRTbGlwRm9yY2UoZm9yY2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBzZXRTaWRlRnJpY3Rpb25cclxuICAgICAqL1xyXG4gICAgV2hlZWxDb25zdHJhaW50LnByb3RvdHlwZS5zZXRTaWRlRnJpY3Rpb24gPSBmdW5jdGlvbiAoZm9yY2UpIHtcclxuICAgICAgICB0aGlzLnNpZGVFcXVhdGlvbi5zZXRTbGlwRm9yY2UoZm9yY2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBnZXRTcGVlZFxyXG4gICAgICovXHJcbiAgICBXaGVlbENvbnN0cmFpbnQucHJvdG90eXBlLmdldFNwZWVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBib2R5ID0gdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5O1xyXG4gICAgICAgIGJvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHJlbGF0aXZlUG9pbnQsIHRoaXMubG9jYWxGb3J3YXJkVmVjdG9yKTtcclxuICAgICAgICBib2R5LmdldFZlbG9jaXR5QXRQb2ludCh3b3JsZFZlbG9jaXR5LCByZWxhdGl2ZVBvaW50KTtcclxuICAgICAgICByZXR1cm4gdmVjMl8xLmRlZmF1bHQuZG90KHdvcmxkVmVsb2NpdHksIHJlbGF0aXZlUG9pbnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgV2hlZWxDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnZlaGljbGUuY2hhc3Npc0JvZHk7XHJcbiAgICAgICAgdmFyIGZvcndhcmRFcXVhdGlvbiA9IHRoaXMuZm9yd2FyZEVxdWF0aW9uO1xyXG4gICAgICAgIHZhciBzaWRlRXF1YXRpb24gPSB0aGlzLnNpZGVFcXVhdGlvbjtcclxuICAgICAgICB2YXIgc3RlZXJWYWx1ZSA9IHRoaXMuc3RlZXJWYWx1ZTtcclxuICAgICAgICAvLyBEaXJlY3Rpb25hbFxyXG4gICAgICAgIGJvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKGZvcndhcmRFcXVhdGlvbi50LCB0aGlzLmxvY2FsRm9yd2FyZFZlY3Rvcik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHNpZGVFcXVhdGlvbi50LCB0aGlzLmxvY2FsRm9yd2FyZFZlY3RvciwgTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgIGJvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHNpZGVFcXVhdGlvbi50LCBzaWRlRXF1YXRpb24udCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKGZvcndhcmRFcXVhdGlvbi50LCBmb3J3YXJkRXF1YXRpb24udCwgc3RlZXJWYWx1ZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHNpZGVFcXVhdGlvbi50LCBzaWRlRXF1YXRpb24udCwgc3RlZXJWYWx1ZSk7XHJcbiAgICAgICAgLy8gQXR0YWNobWVudCBwb2ludFxyXG4gICAgICAgIGJvZHkudG9Xb3JsZEZyYW1lKGZvcndhcmRFcXVhdGlvbi5jb250YWN0UG9pbnRCLCB0aGlzLmxvY2FsUG9zaXRpb24pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkoc2lkZUVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIGZvcndhcmRFcXVhdGlvbi5jb250YWN0UG9pbnRCKTtcclxuICAgICAgICBib2R5LnZlY3RvclRvV29ybGRGcmFtZShmb3J3YXJkRXF1YXRpb24uY29udGFjdFBvaW50QSwgdGhpcy5sb2NhbFBvc2l0aW9uKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHNpZGVFcXVhdGlvbi5jb250YWN0UG9pbnRBLCBmb3J3YXJkRXF1YXRpb24uY29udGFjdFBvaW50QSk7XHJcbiAgICAgICAgLy8gQWRkIGVuZ2luZSBmb3JjZVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZSh0bXBWZWMsIGZvcndhcmRFcXVhdGlvbi50KTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZSh0bXBWZWMsIHRtcFZlYywgdGhpcy5lbmdpbmVGb3JjZSk7XHJcbiAgICAgICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LmFwcGx5Rm9yY2UodG1wVmVjLCBmb3J3YXJkRXF1YXRpb24uY29udGFjdFBvaW50QSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFdoZWVsQ29uc3RyYWludDtcclxufShjb25zdHJhaW50XzEuZGVmYXVsdCkpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXHJcbi8vICwgICBTaGFwZSA9IHJlcXVpcmUoJy4vU2hhcGUnKVxyXG4vLyAsICAgc2hhbGxvd0Nsb25lID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKS5zaGFsbG93Q2xvbmVcclxuLy8gLCAgIENvbnZleCA9IHJlcXVpcmUoJy4vQ29udmV4Jyk7XHJcbnZhciBDb252ZXhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Db252ZXhcIikpO1xyXG52YXIgc2hhcGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZVwiKSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBCb3ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQm94LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCb3ggc2hhcGUgY2xhc3MuXHJcbiAgICAgKiBAY2xhc3MgQm94XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9MV0gVG90YWwgd2lkdGggb2YgdGhlIGJveFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD0xXSBUb3RhbCBoZWlnaHQgb2YgdGhlIGJveFxyXG4gICAgICogQGV4dGVuZHMgQ29udmV4XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xyXG4gICAgICogICAgIHZhciBib3hTaGFwZSA9IG5ldyBCb3goe1xyXG4gICAgICogICAgICAgICB3aWR0aDogMixcclxuICAgICAqICAgICAgICAgaGVpZ2h0OiAxXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShib3hTaGFwZSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJveChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcclxuICAgICAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XHJcbiAgICAgICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcclxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNoYXBlXzEuZGVmYXVsdC5CT1gsIFtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygtaHcsIC1oaCksXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoaHcsIC1oaCksXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoaHcsIGhoKSxcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygtaHcsIGhoKVxyXG4gICAgICAgIF0sIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIF90aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIG1vbWVudCBvZiBpbmVydGlhXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQm94LnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB3ID0gdGhpcy53aWR0aCwgaCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiAoaCAqIGggKyB3ICogdykgLyAxMjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgcmFkaXVzXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXHJcbiAgICAgKi9cclxuICAgIEJveC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHcgPSB0aGlzLndpZHRoLCBoID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IE1hdGguc3FydCh3ICogdyArIGggKiBoKSAvIDI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdSYWRpdXM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgQm94LnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uIChvdXQsIHBvc2l0aW9uLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBjID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKSwgcyA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSksIHcgPSB0aGlzLndpZHRoLCBoID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9ICh3ICogcyArIGggKiBjKSAqIDAuNTtcclxuICAgICAgICB2YXIgd2lkdGggPSAoaCAqIHMgKyB3ICogYykgKiAwLjU7XHJcbiAgICAgICAgdmFyIGwgPSBvdXQubG93ZXJCb3VuZDtcclxuICAgICAgICB2YXIgdSA9IG91dC51cHBlckJvdW5kO1xyXG4gICAgICAgIHZhciBweCA9IHBvc2l0aW9uWzBdO1xyXG4gICAgICAgIHZhciBweSA9IHBvc2l0aW9uWzFdO1xyXG4gICAgICAgIGxbMF0gPSBweCAtIHdpZHRoO1xyXG4gICAgICAgIGxbMV0gPSBweSAtIGhlaWdodDtcclxuICAgICAgICB1WzBdID0gcHggKyB3aWR0aDtcclxuICAgICAgICB1WzFdID0gcHkgKyBoZWlnaHQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgQm94LnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXJlYSA9IHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcmVhO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIEJveC5wcm90b3R5cGUucG9pbnRUZXN0ID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnMobG9jYWxQb2ludFswXSkgPD0gdGhpcy53aWR0aCAqIDAuNSAmJiBNYXRoLmFicyhsb2NhbFBvaW50WzFdKSA8PSB0aGlzLmhlaWdodCAqIDAuNTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gQm94O1xyXG59KENvbnZleF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQm94O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyB2YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcclxuLy8gLCAgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcclxuLy8gLCAgICBzaGFsbG93Q2xvbmUgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpLnNoYWxsb3dDbG9uZTtcclxudmFyIFNoYXBlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vU2hhcGVcIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIENpcmNsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDaXJjbGUsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENpcmNsZSBzaGFwZSBjbGFzcy5cclxuICAgICAqIEBjbGFzcyBDaXJjbGVcclxuICAgICAqIEBleHRlbmRzIFNoYXBlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7b3B0aW9uc30gW29wdGlvbnNdIChOb3RlIHRoYXQgdGhpcyBvcHRpb25zIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gY29uc3RydWN0b3IuKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJhZGl1cz0xXSBUaGUgcmFkaXVzIG9mIHRoaXMgY2lyY2xlXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHsgbWFzczogMSB9KTtcclxuICAgICAqICAgICB2YXIgY2lyY2xlU2hhcGUgPSBuZXcgQ2lyY2xlKHtcclxuICAgICAqICAgICAgICAgcmFkaXVzOiAxXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShjaXJjbGVTaGFwZSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENpcmNsZShvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFNoYXBlXzEuZGVmYXVsdC5DSVJDTEUsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSByYWRpdXNcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnJhZGl1cyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yYWRpdXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByID0gdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgcmV0dXJuIHIgKiByIC8gMjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQ2lyY2xlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdSYWRpdXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUFyZWFcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQ2lyY2xlLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXJlYSA9IE1hdGguUEkgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFyZWE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uIChvdXQsIHBvc2l0aW9uIC8qLCBhbmdsZTogZjMyKi8pIHtcclxuICAgICAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChvdXQudXBwZXJCb3VuZCwgciwgcik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KG91dC5sb3dlckJvdW5kLCAtciwgLXIpO1xyXG4gICAgICAgIGlmIChwb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQob3V0Lmxvd2VyQm91bmQsIG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChvdXQudXBwZXJCb3VuZCwgb3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHJheWNhc3RcclxuICAgICAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxyXG4gICAgICogQHBhcmFtICB7UmF5fSByYXlcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxyXG4gICAgICovXHJcbiAgICBDaXJjbGUucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbiAocmVzdWx0LCByYXksIHBvc2l0aW9uIC8qLCBhbmdsZTogZjMyKi8pIHtcclxuICAgICAgICB2YXIgZnJvbSA9IHJheS5mcm9tLCB0byA9IHJheS50bywgciA9IHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHZhciBhID0gTWF0aC5wb3codG9bMF0gLSBmcm9tWzBdLCAyKSArIE1hdGgucG93KHRvWzFdIC0gZnJvbVsxXSwgMik7XHJcbiAgICAgICAgdmFyIGIgPSAyICogKCh0b1swXSAtIGZyb21bMF0pICogKGZyb21bMF0gLSBwb3NpdGlvblswXSkgKyAodG9bMV0gLSBmcm9tWzFdKSAqIChmcm9tWzFdIC0gcG9zaXRpb25bMV0pKTtcclxuICAgICAgICB2YXIgYyA9IE1hdGgucG93KGZyb21bMF0gLSBwb3NpdGlvblswXSwgMikgKyBNYXRoLnBvdyhmcm9tWzFdIC0gcG9zaXRpb25bMV0sIDIpIC0gTWF0aC5wb3cociwgMik7XHJcbiAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XHJcbiAgICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50ID0gUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludDtcclxuICAgICAgICB2YXIgbm9ybWFsID0gUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWw7XHJcbiAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xyXG4gICAgICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkZWx0YSA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGRlbHRhLCBub3JtYWwsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBzcXJ0RGVsdGEgPSBNYXRoLnNxcnQoZGVsdGEpO1xyXG4gICAgICAgICAgICB2YXIgaW52MmEgPSAxIC8gKDIgKiBhKTtcclxuICAgICAgICAgICAgdmFyIGQxID0gKC1iIC0gc3FydERlbHRhKSAqIGludjJhO1xyXG4gICAgICAgICAgICB2YXIgZDIgPSAoLWIgKyBzcXJ0RGVsdGEpICogaW52MmE7XHJcbiAgICAgICAgICAgIGlmIChkMSA+PSAwICYmIGQxIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkMSk7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGQxLCBub3JtYWwsIC0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2hvdWxkU3RvcChyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkMiA+PSAwICYmIGQyIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkMik7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGQyLCBub3JtYWwsIC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDaXJjbGUucHJvdG90eXBlLnBvaW50VGVzdCA9IGZ1bmN0aW9uIChsb2NhbFBvaW50KSB7XHJcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHJldHVybiB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkTGVuZ3RoKGxvY2FsUG9pbnQpIDw9IHJhZGl1cyAqIHJhZGl1cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2lyY2xlO1xyXG59KFNoYXBlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDaXJjbGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1NoYXBlXCIpKTtcclxudmFyIHBvbHlrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvcG9seWtcIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgZG90ID0gdmVjMl8xLmRlZmF1bHQuZG90O1xyXG52YXIgdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZF90aW1lc19tYXNzID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHVwZGF0ZUNlbnRlck9mTWFzc19hID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHVwZGF0ZUNlbnRlck9mTWFzc19iID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHVwZGF0ZUNlbnRlck9mTWFzc19jID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciB0bXBWZWMxID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBpbnRlcnNlY3RDb252ZXhfcmF5U3RhcnQgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdENvbnZleF9yYXlFbmQgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdENvbnZleF9ub3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHBpY19yMCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgcGljX3IxID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciB0bXBWZWMyID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciB3b3JsZEF4aXMgPSB0bXBWZWMyO1xyXG52YXIgQ29udmV4ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbnZleCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmV4IHNoYXBlIGNsYXNzLlxyXG4gICAgICogQGNsYXNzIENvbnZleFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBTaGFwZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAoTm90ZSB0aGF0IHRoaXMgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IGNvbnN0cnVjdG9yLilcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnZlcnRpY2VzXSBBbiBhcnJheSBvZiB2ZXJ0aWNlcyB0aGF0IHNwYW4gdGhpcyBzaGFwZS4gVmVydGljZXMgYXJlIGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIChDQ1cpIGRpcmVjdGlvbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAgICAgKiAgICAgdmFyIHZlcnRpY2VzID0gW1stMSwtMV0sIFsxLC0xXSwgWzEsMV0sIFstMSwxXV07XHJcbiAgICAgKiAgICAgdmFyIGNvbnZleFNoYXBlID0gbmV3IENvbnZleCh7XHJcbiAgICAgKiAgICAgICAgIHZlcnRpY2VzOiB2ZXJ0aWNlc1xyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoY29udmV4U2hhcGUpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb252ZXgodHlwZSwgdmVydGljZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlICE9PSBudWxsICYmIHR5cGUgIT09IHZvaWQgMCA/IHR5cGUgOiBTaGFwZV8xLmRlZmF1bHQuQ09OVkVYLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8vIENvcHkgdGhlIHZlcnRzXHJcbiAgICAgICAgX3RoaXMudmVydGljZXMgPSBbXTtcclxuICAgICAgICB2YXIgbmV3VmVydGljZXMgPSB2ZXJ0aWNlcyAhPT0gbnVsbCAmJiB2ZXJ0aWNlcyAhPT0gdm9pZCAwID8gdmVydGljZXMgOiBbXTtcclxuICAgICAgICBfdGhpcy52ZXJ0aWNlcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLm5vcm1hbHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1ZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnZlcnRpY2VzLnB1c2godmVjMl8xLmRlZmF1bHQuY2xvbmUobmV3VmVydGljZXNbaV0pKTtcclxuICAgICAgICAgICAgX3RoaXMubm9ybWFscy5wdXNoKHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMudXBkYXRlTm9ybWFscygpO1xyXG4gICAgICAgIF90aGlzLmNlbnRlck9mTWFzcyA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIF90aGlzLnRyaWFuZ2xlcyA9IFtdO1xyXG4gICAgICAgIGlmIChfdGhpcy52ZXJ0aWNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlVHJpYW5nbGVzKCk7XHJcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUNlbnRlck9mTWFzcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYm91bmRpbmcgcmFkaXVzIG9mIHRoZSBjb252ZXhcclxuICAgICAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmJvdW5kaW5nUmFkaXVzID0gMDtcclxuICAgICAgICBfdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xyXG4gICAgICAgIF90aGlzLnVwZGF0ZUFyZWEoKTtcclxuICAgICAgICBpZiAoX3RoaXMuYXJlYSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4IHZlcnRpY2VzIG11c3QgYmUgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugd2luZGluZy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIENvbnZleC5wcm90b3R5cGUudXBkYXRlTm9ybWFscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgICAgIHZhciBub3JtYWxzID0gdGhpcy5ub3JtYWxzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHdvcmxkUG9pbnQwID0gdmVydGljZXNbaV07XHJcbiAgICAgICAgICAgIHZhciB3b3JsZFBvaW50MSA9IHZlcnRpY2VzWyhpICsgMSkgJSB2ZXJ0aWNlcy5sZW5ndGhdO1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gbm9ybWFsc1tpXTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qobm9ybWFsLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xyXG4gICAgICAgICAgICAvLyBHZXQgbm9ybWFsIC0ganVzdCByb3RhdGUgOTAgZGVncmVlcyBzaW5jZSB2ZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gQ0NXXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZTkwY3cobm9ybWFsLCBub3JtYWwpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFByb2plY3QgYSBDb252ZXggb250byBhIHdvcmxkLW9yaWVudGVkIGF4aXNcclxuICAgICAqIEBtZXRob2QgcHJvamVjdE9udG9BeGlzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxBeGlzXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XHJcbiAgICAgKi9cclxuICAgIENvbnZleC5wcm90b3R5cGUucHJvamVjdE9udG9Mb2NhbEF4aXMgPSBmdW5jdGlvbiAobG9jYWxBeGlzLCByZXN1bHQpIHtcclxuICAgICAgICB2YXIgbWF4ID0gLUluZmluaXR5LCBtaW4gPSBJbmZpbml0eSwgdiwgdmFsdWUsIGxvY2FsQXhpcyA9IHRtcFZlYzE7XHJcbiAgICAgICAgLy8gR2V0IHByb2plY3RlZCBwb3NpdGlvbiBvZiBhbGwgdmVydGljZXNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdiA9IHRoaXMudmVydGljZXNbaV07XHJcbiAgICAgICAgICAgIHZhbHVlID0gZG90KHYsIGxvY2FsQXhpcyk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWluID4gbWF4KSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gbWluO1xyXG4gICAgICAgICAgICBtaW4gPSBtYXg7XHJcbiAgICAgICAgICAgIG1heCA9IHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChyZXN1bHQsIG1pbiwgbWF4KTtcclxuICAgIH07XHJcbiAgICBDb252ZXgucHJvdG90eXBlLkNvbnZleHByb2plY3RPbnRvV29ybGRBeGlzID0gZnVuY3Rpb24gKGxvY2FsQXhpcywgc2hhcGVPZmZzZXQsIHNoYXBlQW5nbGUsIHJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMucHJvamVjdE9udG9Mb2NhbEF4aXMobG9jYWxBeGlzLCByZXN1bHQpO1xyXG4gICAgICAgIC8vIFByb2plY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5IG9udG8gdGhlIGF4aXMgLSBuZWVkIHRvIGFkZCB0aGlzIHRvIHRoZSByZXN1bHRcclxuICAgICAgICBpZiAoc2hhcGVBbmdsZSAhPT0gMCkge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUod29ybGRBeGlzLCBsb2NhbEF4aXMsIHNoYXBlQW5nbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd29ybGRBeGlzID0gbG9jYWxBeGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gZG90KHNoYXBlT2Zmc2V0LCB3b3JsZEF4aXMpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChyZXN1bHQsIHJlc3VsdFswXSArIG9mZnNldCwgcmVzdWx0WzFdICsgb2Zmc2V0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgLnRyaWFuZ2xlcyBwcm9wZXJ0eVxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVUcmlhbmdsZXNcclxuICAgICAqL1xyXG4gICAgQ29udmV4LnByb3RvdHlwZS51cGRhdGVUcmlhbmdsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50cmlhbmdsZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyBSZXdyaXRlIG9uIHBvbHlrIG5vdGF0aW9uLCBhcnJheSBvZiBudW1iZXJzXHJcbiAgICAgICAgdmFyIHBvbHlrVmVydHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICBwb2x5a1ZlcnRzLnB1c2godlswXSk7XHJcbiAgICAgICAgICAgIHBvbHlrVmVydHMucHVzaCh2WzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVHJpYW5ndWxhdGVcclxuICAgICAgICB2YXIgdHJpYW5nbGVzID0gcG9seWtfMS5kZWZhdWx0LlRyaWFuZ3VsYXRlKHBvbHlrVmVydHMpO1xyXG4gICAgICAgIC8vIExvb3Agb3ZlciBhbGwgdHJpYW5nbGVzLCBhZGQgdGhlaXIgaW5lcnRpYSBjb250cmlidXRpb25zIHRvIElcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgICAgICB2YXIgaWQxID0gdHJpYW5nbGVzW2ldLCBpZDIgPSB0cmlhbmdsZXNbaSArIDFdLCBpZDMgPSB0cmlhbmdsZXNbaSArIDJdO1xyXG4gICAgICAgICAgICAvLyBBZGQgdG8gdHJpYW5nbGVzXHJcbiAgICAgICAgICAgIHZhciBUID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcclxuICAgICAgICAgICAgVFswXSA9IGlkMTtcclxuICAgICAgICAgICAgVFsxXSA9IGlkMjtcclxuICAgICAgICAgICAgVFsyXSA9IGlkMztcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZXMucHVzaChUKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIC5jZW50ZXJPZk1hc3MgcHJvcGVydHkuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUNlbnRlck9mTWFzc1xyXG4gICAgICovXHJcbiAgICBDb252ZXgucHJvdG90eXBlLnVwZGF0ZUNlbnRlck9mTWFzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdHJpYW5nbGVzID0gdGhpcy50cmlhbmdsZXMsIHZlcnRzID0gdGhpcy52ZXJ0aWNlcywgY20gPSB0aGlzLmNlbnRlck9mTWFzcywgY2VudHJvaWQgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWQsIGEgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYSwgYiA9IHVwZGF0ZUNlbnRlck9mTWFzc19iLCBjID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2MsIGNlbnRyb2lkX3RpbWVzX21hc3MgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWRfdGltZXNfbWFzcztcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQoY20sIDAsIDApO1xyXG4gICAgICAgIHZhciB0b3RhbEFyZWEgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSB0cmlhbmdsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHQgPSB0cmlhbmdsZXNbaV0sIGEgPSB2ZXJ0c1t0WzBdXSwgYiA9IHZlcnRzW3RbMV1dLCBjID0gdmVydHNbdFsyXV07XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNlbnRyb2lkKGNlbnRyb2lkLCBhLCBiLCBjKTtcclxuICAgICAgICAgICAgLy8gR2V0IG1hc3MgZm9yIHRoZSB0cmlhbmdsZSAoZGVuc2l0eT0xIGluIHRoaXMgY2FzZSlcclxuICAgICAgICAgICAgLy8gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzgwMTk4L2FyZWEtb2YtdHJpYW5nbGUtdmlhLXZlY3RvcnNcclxuICAgICAgICAgICAgdmFyIG0gPSBDb252ZXgudHJpYW5nbGVBcmVhKGEsIGIsIGMpO1xyXG4gICAgICAgICAgICB0b3RhbEFyZWEgKz0gbTtcclxuICAgICAgICAgICAgLy8gQWRkIHRvIGNlbnRlciBvZiBtYXNzXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKGNlbnRyb2lkX3RpbWVzX21hc3MsIGNlbnRyb2lkLCBtKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKGNtLCBjbSwgY2VudHJvaWRfdGltZXNfbWFzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKGNtLCBjbSwgMSAvIHRvdGFsQXJlYSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBtb21lbnQgb2YgaW5lcnRpYSBvZiB0aGUgQ29udmV4LlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvdG9waWMvMzQyODIyLW1vbWVudC1vZi1pbmVydGlhLW9mLWEtcG9seWdvbi0yZC9cclxuICAgICAqL1xyXG4gICAgQ29udmV4LnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZW5vbSA9IDAuMCwgbnVtZXIgPSAwLjAsIE4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBqID0gTiAtIDEsIGkgPSAwOyBpIDwgTjsgaiA9IGksIGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcDAgPSB0aGlzLnZlcnRpY2VzW2pdO1xyXG4gICAgICAgICAgICB2YXIgcDEgPSB0aGlzLnZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICB2YXIgYSA9IE1hdGguYWJzKHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHAwLCBwMSkpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IGRvdChwMSwgcDEpICsgZG90KHAxLCBwMCkgKyBkb3QocDAsIHAwKTtcclxuICAgICAgICAgICAgZGVub20gKz0gYSAqIGI7XHJcbiAgICAgICAgICAgIG51bWVyICs9IGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoMS4wIC8gNi4wKSAqIChkZW5vbSAvIG51bWVyKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIC5ib3VuZGluZ1JhZGl1cyBwcm9wZXJ0eVxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xyXG4gICAgICovXHJcbiAgICBDb252ZXgucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXMsIHIyID0gMDtcclxuICAgICAgICBpZiAoIXZlcnRzKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gdmVydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGwyID0gdmVjMl8xLmRlZmF1bHQuc3F1YXJlZExlbmd0aCh2ZXJ0c1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChsMiA+IHIyKSB7XHJcbiAgICAgICAgICAgICAgICByMiA9IGwyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBNYXRoLnNxcnQocjIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nUmFkaXVzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBhcmVhIG9mIHRoZSB0cmlhbmdsZSBzcGFubmVkIGJ5IHRoZSB0aHJlZSBwb2ludHMgYSwgYiwgYy4gVGhlIGFyZWEgaXMgcG9zaXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIsIG90aGVyd2lzZSBuZWdhdGl2ZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgdHJpYW5nbGVBcmVhXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICBDb252ZXgudHJpYW5nbGVBcmVhID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSkgLSAoKGNbMF0gLSBhWzBdKSAqIChiWzFdIC0gYVsxXSkpKSAqIDAuNTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgLmFyZWFcclxuICAgICAqIEBtZXRob2QgdXBkYXRlQXJlYVxyXG4gICAgICovXHJcbiAgICBDb252ZXgucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnZlcnRpY2VzKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRyaWFuZ2xlcygpO1xyXG4gICAgICAgIHRoaXMuYXJlYSA9IDA7XHJcbiAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IHRoaXMudHJpYW5nbGVzLCB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHRyaWFuZ2xlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdCA9IHRyaWFuZ2xlc1tpXSwgYSA9IHZlcnRzW3RbMF1dLCBiID0gdmVydHNbdFsxXV0sIGMgPSB2ZXJ0c1t0WzJdXTtcclxuICAgICAgICAgICAgLy8gR2V0IG1hc3MgZm9yIHRoZSB0cmlhbmdsZSAoZGVuc2l0eT0xIGluIHRoaXMgY2FzZSlcclxuICAgICAgICAgICAgdmFyIG0gPSBDb252ZXgudHJpYW5nbGVBcmVhKGEsIGIsIGMpO1xyXG4gICAgICAgICAgICB0aGlzLmFyZWEgKz0gbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJlYTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY29tcHV0ZUFBQkJcclxuICAgICAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXHJcbiAgICAgKiBAdG9kbzogYXBwcm94aW1hdGUgd2l0aCBhIGxvY2FsIEFBQkI/XHJcbiAgICAgKi9cclxuICAgIENvbnZleC5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAob3V0LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICBvdXQuc2V0RnJvbVBvaW50cyh0aGlzLnZlcnRpY2VzLCBwb3NpdGlvbiwgYW5nbGUsIDApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCByYXljYXN0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcclxuICAgICAqIEBwYXJhbSAge1JheX0gcmF5XHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgQ29udmV4LnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24gKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgcmF5U3RhcnQgPSBpbnRlcnNlY3RDb252ZXhfcmF5U3RhcnQ7XHJcbiAgICAgICAgdmFyIHJheUVuZCA9IGludGVyc2VjdENvbnZleF9yYXlFbmQ7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IGludGVyc2VjdENvbnZleF9ub3JtYWw7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgICAgICAvLyBUcmFuc2Zvcm0gdG8gbG9jYWwgc2hhcGUgc3BhY2VcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUocmF5U3RhcnQsIHJheS5mcm9tLCBwb3NpdGlvbiwgYW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvTG9jYWxGcmFtZShyYXlFbmQsIHJheS50bywgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICB2YXIgbiA9IHZlcnRpY2VzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4gJiYgIXJlc3VsdC5zaG91bGRTdG9wKHJheSk7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcTEgPSB2ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgdmFyIHEyID0gdmVydGljZXNbKGkgKyAxKSAlIG5dO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB2ZWMyXzEuZGVmYXVsdC5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihyYXlTdGFydCwgcmF5RW5kLCBxMSwgcTIpO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qobm9ybWFsLCBxMiwgcTEpO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKG5vcm1hbCwgbm9ybWFsLCAtTWF0aC5QSSAvIDIgKyBhbmdsZSk7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGRlbHRhLCBub3JtYWwsIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbnZleC5wcm90b3R5cGUucG9pbnRUZXN0ID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHtcclxuICAgICAgICB2YXIgcjAgPSBwaWNfcjAsIHIxID0gcGljX3IxLCB2ZXJ0cyA9IHRoaXMudmVydGljZXMsIGxhc3RDcm9zcyA9IG51bGwsIG51bVZlcnRzID0gdmVydHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVmVydHMgKyAxOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYwID0gdmVydHNbaSAlIG51bVZlcnRzXSwgdjEgPSB2ZXJ0c1soaSArIDEpICUgbnVtVmVydHNdO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyMCwgdjAsIGxvY2FsUG9pbnQpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyMSwgdjEsIGxvY2FsUG9pbnQpO1xyXG4gICAgICAgICAgICB2YXIgY3Jvc3MgPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyMCwgcjEpO1xyXG4gICAgICAgICAgICBpZiAobGFzdENyb3NzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0Q3Jvc3MgPSBjcm9zcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB3ZSBnb3QgYSBkaWZmZXJlbnQgc2lnbiBvZiB0aGUgZGlzdGFuY2UgdmVjdG9yLCB0aGUgcG9pbnQgaXMgb3V0IG9mIHRoZSBwb2x5Z29uXHJcbiAgICAgICAgICAgIGlmIChjcm9zcyAqIGxhc3RDcm9zcyA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0Q3Jvc3MgPSBjcm9zcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbnZleDtcclxufShTaGFwZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29udmV4O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgU2hhcGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIHNoYXBlcy4gTm90IHRvIGJlIHVzZWQgZGlyZWN0bHkuXHJcbiAgICAgKiBAY2xhc3MgU2hhcGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmFuZ2xlPTBdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uR3JvdXA9MV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25NYXNrPTFdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaWRdIE9wdGlvbmFsIC0gc3BlY2lmeSBhbiBJRCBmb3IgdGhpcyBzaGFwZS4gUG9zc2libHkgdXNlZnVsIGZvciByZXBsYWNpbmcgc2hhcGVzLiBDYXJlZnVsIHRvIGF2b2lkIGR1cGxpY2F0ZXMhXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlPXRydWVdXHJcbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsfSBbb3B0aW9ucy5tYXRlcmlhbD1udWxsXVxyXG4gICAgICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMucG9zaXRpb25dXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbnNvcj1mYWxzZV1cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy50eXBlPTBdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNoYXBlKHR5cGUsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCb2R5LWxvY2FsIHBvc2l0aW9uIG9mIHRoZSBzaGFwZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBwb3NpdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCb2R5LWxvY2FsIGFuZ2xlIG9mIHRoZSBzaGFwZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYW5nbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFuZ2xlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgc2hhcGUuIE9uZSBvZjpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIDx1bD5cclxuICAgICAgICAgKiA8bGk+PGEgaHJlZj1cIlNoYXBlLmh0bWwjcHJvcGVydHlfQ0lSQ0xFXCI+U2hhcGUuQ0lSQ0xFPC9hPjwvbGk+XHJcbiAgICAgICAgICogPGxpPjxhIGhyZWY9XCJTaGFwZS5odG1sI3Byb3BlcnR5X1BBUlRJQ0xFXCI+U2hhcGUuUEFSVElDTEU8L2E+PC9saT5cclxuICAgICAgICAgKiA8bGk+PGEgaHJlZj1cIlNoYXBlLmh0bWwjcHJvcGVydHlfUExBTkVcIj5TaGFwZS5QTEFORTwvYT48L2xpPlxyXG4gICAgICAgICAqIDxsaT48YSBocmVmPVwiU2hhcGUuaHRtbCNwcm9wZXJ0eV9DT05WRVhcIj5TaGFwZS5DT05WRVg8L2E+PC9saT5cclxuICAgICAgICAgKiA8bGk+PGEgaHJlZj1cIlNoYXBlLmh0bWwjcHJvcGVydHlfTElORVwiPlNoYXBlLkxJTkU8L2E+PC9saT5cclxuICAgICAgICAgKiA8bGk+PGEgaHJlZj1cIlNoYXBlLmh0bWwjcHJvcGVydHlfQk9YXCI+U2hhcGUuQk9YPC9hPjwvbGk+XHJcbiAgICAgICAgICogPGxpPjxhIGhyZWY9XCJTaGFwZS5odG1sI3Byb3BlcnR5X0NBUFNVTEVcIj5TaGFwZS5DQVBTVUxFPC9hPjwvbGk+XHJcbiAgICAgICAgICogPGxpPjxhIGhyZWY9XCJTaGFwZS5odG1sI3Byb3BlcnR5X0hFSUdIVEZJRUxEXCI+U2hhcGUuSEVJR0hURklFTEQ8L2E+PC9saT5cclxuICAgICAgICAgKiA8L3VsPlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHR5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNoYXBlIG9iamVjdCBpZGVudGlmaWVyLiBSZWFkIG9ubHkuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAcHJvcGVydHkgaWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlkID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCb3VuZGluZyBjaXJjbGUgcmFkaXVzIG9mIHRoaXMgc2hhcGVcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxpc2lvbiBncm91cCB0aGF0IHRoaXMgc2hhcGUgYmVsb25ncyB0byAoYml0IG1hc2spLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cuYXVyZWxpZW5yaWJvbi5jb20vYmxvZy8yMDExLzA3L2JveDJkLXR1dG9yaWFsLWNvbGxpc2lvbi1maWx0ZXJpbmcvXCI+dGhpcyB0dXRvcmlhbDwvYT4uXHJcbiAgICAgICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkdyb3VwXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAvLyBTZXR1cCBiaXRzIGZvciBlYWNoIGF2YWlsYWJsZSBncm91cFxyXG4gICAgICAgICAqICAgICB2YXIgUExBWUVSID0gTWF0aC5wb3coMiwwKSxcclxuICAgICAgICAgKiAgICAgICAgIEVORU1ZID0gIE1hdGgucG93KDIsMSksXHJcbiAgICAgICAgICogICAgICAgICBHUk9VTkQgPSBNYXRoLnBvdygyLDIpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gUHV0IHNoYXBlcyBpbnRvIHRoZWlyIGdyb3Vwc1xyXG4gICAgICAgICAqICAgICBwbGF5ZXIxU2hhcGUuY29sbGlzaW9uR3JvdXAgPSBQTEFZRVI7XHJcbiAgICAgICAgICogICAgIHBsYXllcjJTaGFwZS5jb2xsaXNpb25Hcm91cCA9IFBMQVlFUjtcclxuICAgICAgICAgKiAgICAgZW5lbXlTaGFwZSAgLmNvbGxpc2lvbkdyb3VwID0gRU5FTVk7XHJcbiAgICAgICAgICogICAgIGdyb3VuZFNoYXBlIC5jb2xsaXNpb25Hcm91cCA9IEdST1VORDtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBBc3NpZ24gZ3JvdXBzIHRoYXQgZWFjaCBzaGFwZSBjb2xsaWRlIHdpdGguXHJcbiAgICAgICAgICogICAgIC8vIE5vdGUgdGhhdCB0aGUgcGxheWVycyBjYW4gY29sbGlkZSB3aXRoIGdyb3VuZCBhbmQgZW5lbWllcywgYnV0IG5vdCB3aXRoIG90aGVyIHBsYXllcnMuXHJcbiAgICAgICAgICogICAgIHBsYXllcjFTaGFwZS5jb2xsaXNpb25NYXNrID0gRU5FTVkgfCBHUk9VTkQ7XHJcbiAgICAgICAgICogICAgIHBsYXllcjJTaGFwZS5jb2xsaXNpb25NYXNrID0gRU5FTVkgfCBHUk9VTkQ7XHJcbiAgICAgICAgICogICAgIGVuZW15U2hhcGUgIC5jb2xsaXNpb25NYXNrID0gUExBWUVSIHwgR1JPVU5EO1xyXG4gICAgICAgICAqICAgICBncm91bmRTaGFwZSAuY29sbGlzaW9uTWFzayA9IFBMQVlFUiB8IEVORU1ZO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gSG93IGNvbGxpc2lvbiBjaGVjayBpcyBkb25lXHJcbiAgICAgICAgICogICAgIGlmKHNoYXBlQS5jb2xsaXNpb25Hcm91cCAmIHNoYXBlQi5jb2xsaXNpb25NYXNrKSE9MCAmJiAoc2hhcGVCLmNvbGxpc2lvbkdyb3VwICYgc2hhcGVBLmNvbGxpc2lvbk1hc2spIT0wKXtcclxuICAgICAgICAgKiAgICAgICAgIC8vIFRoZSBzaGFwZXMgd2lsbCBjb2xsaWRlXHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbGxpc2lvbkdyb3VwID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcmVhIG9mIHRoaXMgc2hhcGUuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGFyZWFcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYXJlYSA9IDA7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHRoaXMucG9zaXRpb24sIG9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFuZ2xlID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFuZ2xlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5pZCA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKytTaGFwZS5pZENvdW50ZXI7XHJcbiAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb2xsaXNpb25Hcm91cCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMTtcclxuICAgICAgICB0aGlzLmNvbGxpc2lvblJlc3BvbnNlID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29sbGlzaW9uTWFzayA9IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb2xsaXNpb25NYXNrKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAxO1xyXG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF0ZXJpYWw7XHJcbiAgICAgICAgdGhpcy5zZW5zb3IgPSAoX2YgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2Vuc29yKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVBcmVhKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyBzaGFwZS5cclxuICAgICAqIEBtZXRob2QgcG9pbnRUZXN0XHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBsb2NhbFBvaW50XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBTaGFwZS5wcm90b3R5cGUucG9pbnRUZXN0ID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHsgcmV0dXJuIGZhbHNlOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gYSB3b3JsZCBwb2ludCB0byBsb2NhbCBzaGFwZSBzcGFjZSAoYXNzdW1lZCB0aGUgc2hhcGUgaXMgdHJhbnNmb3JtZWQgYnkgYm90aCBpdHNlbGYgYW5kIHRoZSBib2R5KS5cclxuICAgICAqIEBtZXRob2Qgd29ybGRQb2ludFRvTG9jYWxcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IG91dFxyXG4gICAgICogQHBhcmFtIHthcnJheX0gd29ybGRQb2ludFxyXG4gICAgICovXHJcbiAgICBTaGFwZS5wcm90b3R5cGUud29ybGRQb2ludFRvTG9jYWwgPSBmdW5jdGlvbiAob3V0LCB3b3JsZFBvaW50KSB7XHJcbiAgICAgICAgdmFyIHNoYXBlV29ybGRQb3NpdGlvbiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5ib2R5O1xyXG4gICAgICAgIGlmICghYm9keSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShzaGFwZVdvcmxkUG9zaXRpb24sIHRoaXMucG9zaXRpb24sIGJvZHkuYW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChzaGFwZVdvcmxkUG9zaXRpb24sIHNoYXBlV29ybGRQb3NpdGlvbiwgYm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9Mb2NhbEZyYW1lKG91dCwgd29ybGRQb2ludCwgc2hhcGVXb3JsZFBvc2l0aW9uLCBib2R5LmFuZ2xlICsgdGhpcy5hbmdsZSk7XHJcbiAgICB9O1xyXG4gICAgU2hhcGUuaWRDb3VudGVyID0gMDtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IENJUkNMRVxyXG4gICAgICovXHJcbiAgICBTaGFwZS5DSVJDTEUgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gUEFSVElDTEVcclxuICAgICAqL1xyXG4gICAgU2hhcGUuUEFSVElDTEUgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gUExBTkVcclxuICAgICAqL1xyXG4gICAgU2hhcGUuUExBTkUgPSA0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQ09OVkVYXHJcbiAgICAgKi9cclxuICAgIFNoYXBlLkNPTlZFWCA9IDg7XHJcbiAgICAvKipcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBMSU5FXHJcbiAgICAgKi9cclxuICAgIFNoYXBlLkxJTkUgPSAxNjtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IEJPWFxyXG4gICAgICovXHJcbiAgICBTaGFwZS5CT1ggPSAzMjtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IENBUFNVTEVcclxuICAgICAqL1xyXG4gICAgU2hhcGUuQ0FQU1VMRSA9IDY0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gSEVJR0hURklFTERcclxuICAgICAqL1xyXG4gICAgU2hhcGUuSEVJR0hURklFTEQgPSAxMjg7XHJcbiAgICByZXR1cm4gU2hhcGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNoYXBlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyB2YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcclxuLy8gLCAgIHNoYWxsb3dDbG9uZSA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJykuc2hhbGxvd0Nsb25lXHJcbi8vICwgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJyk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciB1dGlsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy91dGlsc1wiKSk7XHJcbnZhciBzaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlXCIpKTtcclxudmFyIHNoYWxsb3dDbG9uZSA9IHV0aWxzXzEuZGVmYXVsdC5zaGFsbG93Q2xvbmU7XHJcbmZ1bmN0aW9uIGJveEkodywgaCkge1xyXG4gICAgcmV0dXJuIHcgKiBoICogKE1hdGgucG93KHcsIDIpICsgTWF0aC5wb3coaCwgMikpIC8gMTI7XHJcbn1cclxuZnVuY3Rpb24gc2VtaUEocikge1xyXG4gICAgcmV0dXJuIE1hdGguUEkgKiBNYXRoLnBvdyhyLCAyKSAvIDI7XHJcbn1cclxuLy8gaHR0cDovL3d3dy5lZnVuZGEuY29tL21hdGgvYXJlYXMvQ2lyY2xlSGFsZi5jZm1cclxuZnVuY3Rpb24gc2VtaUkocikge1xyXG4gICAgcmV0dXJuICgoTWF0aC5QSSAvIDQpIC0gKDggLyAoOSAqIE1hdGguUEkpKSkgKiBNYXRoLnBvdyhyLCA0KTtcclxufVxyXG5mdW5jdGlvbiBzZW1pQyhyKSB7XHJcbiAgICByZXR1cm4gKDQgKiByKSAvICgzICogTWF0aC5QSSk7XHJcbn1cclxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2Vjb25kX21vbWVudF9vZl9hcmVhI1BhcmFsbGVsX2F4aXNfdGhlb3JlbVxyXG5mdW5jdGlvbiBjYXBzdWxlQShsLCByKSB7XHJcbiAgICByZXR1cm4gbCAqIDIgKiByICsgTWF0aC5QSSAqIE1hdGgucG93KHIsIDIpO1xyXG59XHJcbmZ1bmN0aW9uIGNhcHN1bGVJKGwsIHIpIHtcclxuICAgIHZhciBkID0gbCAvIDIgKyBzZW1pQyhyKTtcclxuICAgIHJldHVybiBib3hJKGwsIDIgKiByKSArIDIgKiAoc2VtaUkocikgKyBzZW1pQShyKSAqIE1hdGgucG93KGQsIDIpKTtcclxufVxyXG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV9oaXRQb2ludFdvcmxkID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBpbnRlcnNlY3RDYXBzdWxlX25vcm1hbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV9sMCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV9sMSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV91bml0X3kgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDAsIDEpO1xyXG52YXIgQ2Fwc3VsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDYXBzdWxlLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYXBzdWxlIHNoYXBlLlxyXG4gICAgICogQGNsYXNzIENhcHN1bGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMgU2hhcGVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVuZ3RoPTFdIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBlbmQgcG9pbnRzLCBleHRlbmRzIGFsb25nIHRoZSBYIGF4aXMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmFkaXVzPTFdIFJhZGl1cyBvZiB0aGUgY2Fwc3VsZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAgICAgKiAgICAgdmFyIGNhcHN1bGVTaGFwZSA9IG5ldyBDYXBzdWxlKHtcclxuICAgICAqICAgICAgICAgbGVuZ3RoOiAxLFxyXG4gICAgICogICAgICAgICByYWRpdXM6IDJcclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICBib2R5LmFkZFNoYXBlKGNhcHN1bGVTaGFwZSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENhcHN1bGUob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2hhcGVfMS5kZWZhdWx0LkNBUFNVTEUsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGVuZ3RoID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcclxuICAgICAgICBfdGhpcy5yYWRpdXMgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmFkaXVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgbWFzcyBtb21lbnQgb2YgaW5lcnRpYSBvZiB0aGUgQ2Fwc3VsZS5cclxuICAgICAqIEBtZXRob2QgY29ucHV0ZU1vbWVudE9mSW5lcnRpYVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICogQHRvZG9cclxuICAgICAqL1xyXG4gICAgQ2Fwc3VsZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBodHRwOi8vd3d3LmVmdW5kYS5jb20vbWF0aC9hcmVhcy9yZWN0YW5nbGUuY2ZtXHJcbiAgICAgICAgdmFyIHIgPSB0aGlzLnJhZGl1cywgbCA9IHRoaXMubGVuZ3RoLCBhcmVhID0gY2Fwc3VsZUEobCwgcik7XHJcbiAgICAgICAgcmV0dXJuIChhcmVhID4gMCkgPyBjYXBzdWxlSShsLCByKSAvIGFyZWEgOiAwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xyXG4gICAgICovXHJcbiAgICBDYXBzdWxlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5yYWRpdXMgKyB0aGlzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdSYWRpdXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUFyZWFcclxuICAgICAqL1xyXG4gICAgQ2Fwc3VsZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFyZWEgPSBNYXRoLlBJICogdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyArIHRoaXMucmFkaXVzICogMiAqIHRoaXMubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFyZWE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgQ2Fwc3VsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAob3V0LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgciA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLnJhZGl1cztcclxuICAgICAgICAvLyBDb21wdXRlIGNlbnRlciBwb3NpdGlvbiBvZiBvbmUgb2YgdGhlIHRoZSBjaXJjbGVzLCB3b3JsZCBvcmllbnRlZCwgYnV0IHdpdGggbG9jYWwgb2Zmc2V0XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHIsIHRoaXMubGVuZ3RoIC8gMiwgMCk7XHJcbiAgICAgICAgaWYgKGFuZ2xlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShyLCByLCBhbmdsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldCBib3VuZHNcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQob3V0LnVwcGVyQm91bmQsIE1hdGgubWF4KHJbMF0gKyByYWRpdXMsIC1yWzBdICsgcmFkaXVzKSwgTWF0aC5tYXgoclsxXSArIHJhZGl1cywgLXJbMV0gKyByYWRpdXMpKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQob3V0Lmxvd2VyQm91bmQsIE1hdGgubWluKHJbMF0gLSByYWRpdXMsIC1yWzBdIC0gcmFkaXVzKSwgTWF0aC5taW4oclsxXSAtIHJhZGl1cywgLXJbMV0gLSByYWRpdXMpKTtcclxuICAgICAgICAvLyBBZGQgb2Zmc2V0XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKG91dC5sb3dlckJvdW5kLCBvdXQubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChvdXQudXBwZXJCb3VuZCwgb3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgcmF5Y2FzdFxyXG4gICAgICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIENhcHN1bGUucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbiAocmVzdWx0LCByYXksIHBvc2l0aW9uLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBmcm9tID0gcmF5LmZyb207XHJcbiAgICAgICAgdmFyIHRvID0gcmF5LnRvO1xyXG4gICAgICAgIHZhciBoaXRQb2ludFdvcmxkID0gaW50ZXJzZWN0Q2Fwc3VsZV9oaXRQb2ludFdvcmxkO1xyXG4gICAgICAgIHZhciBub3JtYWwgPSBpbnRlcnNlY3RDYXBzdWxlX25vcm1hbDtcclxuICAgICAgICB2YXIgbDAgPSBpbnRlcnNlY3RDYXBzdWxlX2wwO1xyXG4gICAgICAgIHZhciBsMSA9IGludGVyc2VjdENhcHN1bGVfbDE7XHJcbiAgICAgICAgLy8gVGhlIHNpZGVzXHJcbiAgICAgICAgdmFyIGhhbGZMZW4gPSB0aGlzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gZ2V0IHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGxpbmVcclxuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnJhZGl1cyAqIChpICogMiAtIDEpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQobDAsIC1oYWxmTGVuLCB5KTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGwxLCBoYWxmTGVuLCB5KTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZShsMCwgbDAsIHBvc2l0aW9uLCBhbmdsZSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUobDEsIGwxLCBwb3NpdGlvbiwgYW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB2ZWMyXzEuZGVmYXVsdC5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihmcm9tLCB0bywgbDAsIGwxKTtcclxuICAgICAgICAgICAgaWYgKGRlbHRhID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShub3JtYWwsIGludGVyc2VjdENhcHN1bGVfdW5pdF95LCBhbmdsZSk7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShub3JtYWwsIG5vcm1hbCwgKGkgKiAyIC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGRlbHRhLCBub3JtYWwsIC0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2hvdWxkU3RvcChyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENpcmNsZXNcclxuICAgICAgICB2YXIgZGlhZ29uYWxMZW5ndGhTcXVhcmVkID0gTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpICsgTWF0aC5wb3coaGFsZkxlbiwgMik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGwwLCBoYWxmTGVuICogKGkgKiAyIC0gMSksIDApO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKGwwLCBsMCwgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICAgICAgdmFyIGEgPSBNYXRoLnBvdyh0b1swXSAtIGZyb21bMF0sIDIpICsgTWF0aC5wb3codG9bMV0gLSBmcm9tWzFdLCAyKTtcclxuICAgICAgICAgICAgdmFyIGIgPSAyICogKCh0b1swXSAtIGZyb21bMF0pICogKGZyb21bMF0gLSBsMFswXSkgKyAodG9bMV0gLSBmcm9tWzFdKSAqIChmcm9tWzFdIC0gbDBbMV0pKTtcclxuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLnBvdyhmcm9tWzBdIC0gbDBbMF0sIDIpICsgTWF0aC5wb3coZnJvbVsxXSAtIGwwWzFdLCAyKSAtIE1hdGgucG93KHRoaXMucmFkaXVzLCAyKTtcclxuICAgICAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSA8IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGEgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBpbnRlcnNlY3Rpb24gcG9pbnRcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmxlcnAoaGl0UG9pbnRXb3JsZCwgZnJvbSwgdG8sIGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIGlmICh2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkRGlzdGFuY2UoaGl0UG9pbnRXb3JsZCwgcG9zaXRpb24pID4gZGlhZ29uYWxMZW5ndGhTcXVhcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qobm9ybWFsLCBoaXRQb2ludFdvcmxkLCBsMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZGVsdGEsIG5vcm1hbCwgLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2hvdWxkU3RvcChyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3FydERlbHRhID0gTWF0aC5zcXJ0KGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbnYyYSA9IDEgLyAoMiAqIGEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQxID0gKC1iIC0gc3FydERlbHRhKSAqIGludjJhO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQyID0gKC1iICsgc3FydERlbHRhKSAqIGludjJhO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQxID49IDAgJiYgZDEgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmxlcnAoaGl0UG9pbnRXb3JsZCwgZnJvbSwgdG8sIGQxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmVjMl8xLmRlZmF1bHQuc3F1YXJlZERpc3RhbmNlKGhpdFBvaW50V29ybGQsIHBvc2l0aW9uKSA+IGRpYWdvbmFsTGVuZ3RoU3F1YXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChub3JtYWwsIGhpdFBvaW50V29ybGQsIGwwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGQxLCBub3JtYWwsIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zaG91bGRTdG9wKHJheSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkMiA+PSAwICYmIGQyIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5sZXJwKGhpdFBvaW50V29ybGQsIGZyb20sIHRvLCBkMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlYzJfMS5kZWZhdWx0LnNxdWFyZWREaXN0YW5jZShoaXRQb2ludFdvcmxkLCBwb3NpdGlvbikgPiBkaWFnb25hbExlbmd0aFNxdWFyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qobm9ybWFsLCBoaXRQb2ludFdvcmxkLCBsMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZShub3JtYWwsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkMiwgbm9ybWFsLCAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2hvdWxkU3RvcChyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2Fwc3VsZS5wcm90b3R5cGUucG9pbnRUZXN0ID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHtcclxuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgdmFyIGhhbGZMZW5ndGggPSB0aGlzLmxlbmd0aCAqIDAuNTtcclxuICAgICAgICBpZiAoKE1hdGguYWJzKGxvY2FsUG9pbnRbMF0pIDw9IGhhbGZMZW5ndGggJiYgTWF0aC5hYnMobG9jYWxQb2ludFsxXSkgPD0gcmFkaXVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGgucG93KGxvY2FsUG9pbnRbMF0gLSBoYWxmTGVuZ3RoLCAyKSArIE1hdGgucG93KGxvY2FsUG9pbnRbMV0sIDIpIDw9IHJhZGl1cyAqIHJhZGl1cykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGgucG93KGxvY2FsUG9pbnRbMF0gKyBoYWxmTGVuZ3RoLCAyKSArIE1hdGgucG93KGxvY2FsUG9pbnRbMV0sIDIpIDw9IHJhZGl1cyAqIHJhZGl1cykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDYXBzdWxlO1xyXG59KHNoYXBlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDYXBzdWxlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyB2YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcclxuLy8gLCAgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcclxuLy8gLCAgICBzaGFsbG93Q2xvbmUgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpLnNoYWxsb3dDbG9uZTtcclxudmFyIFNoYXBlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vU2hhcGVcIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfd29ybGROb3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX2wwID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sMSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxGcm9tID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbFRvID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBIZWlnaHRmaWVsZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhIZWlnaHRmaWVsZCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogSGVpZ2h0ZmllbGQgc2hhcGUgY2xhc3MuIEhlaWdodCBkYXRhIGlzIGdpdmVuIGFzIGFuIGFycmF5LiBUaGVzZSBkYXRhIHBvaW50cyBhcmUgc3ByZWFkIG91dCBldmVubHkgd2l0aCBhIGRpc3RhbmNlIFwiZWxlbWVudFdpZHRoXCIuXHJcbiAgICAgKiBAY2xhc3MgSGVpZ2h0ZmllbGRcclxuICAgICAqIEBleHRlbmRzIFNoYXBlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBbb3B0aW9ucy5oZWlnaHRzXSBBbiBhcnJheSBvZiBZIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHRlcnJhaW4uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluVmFsdWVdIE1pbmltdW0gdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnRzIGluIHRoZSBkYXRhIGFycmF5LiBXaWxsIGJlIGNvbXB1dGVkIGF1dG9tYXRpY2FsbHkgaWYgbm90IGdpdmVuLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFZhbHVlXSBNYXhpbXVtIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVsZW1lbnRXaWR0aD0wLjFdIFdvcmxkIHNwYWNpbmcgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICAvLyBHZW5lcmF0ZSBzb21lIGhlaWdodCBkYXRhICh5LXZhbHVlcykuXHJcbiAgICAgKiAgICAgdmFyIGhlaWdodHMgPSBbXTtcclxuICAgICAqICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKXtcclxuICAgICAqICAgICAgICAgdmFyIHkgPSAwLjUgKiBNYXRoLmNvcygwLjIgKiBpKTtcclxuICAgICAqICAgICAgICAgaGVpZ2h0cy5wdXNoKHkpO1xyXG4gICAgICogICAgIH1cclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gQ3JlYXRlIHRoZSBoZWlnaHRmaWVsZCBzaGFwZVxyXG4gICAgICogICAgIHZhciBzaGFwZSA9IG5ldyBIZWlnaHRmaWVsZCh7XHJcbiAgICAgKiAgICAgICAgIGhlaWdodHM6IGhlaWdodHMsXHJcbiAgICAgKiAgICAgICAgIGVsZW1lbnRXaWR0aDogMSAvLyBEaXN0YW5jZSBiZXR3ZWVuIHRoZSBkYXRhIHBvaW50cyBpbiBYIGRpcmVjdGlvblxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoKTtcclxuICAgICAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlKTtcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIEB0b2RvIFNob3VsZCB1c2UgYSBzY2FsZSBwcm9wZXJ0eSB3aXRoIFggYW5kIFkgZGlyZWN0aW9uIGluc3RlYWQgb2YganVzdCBlbGVtZW50V2lkdGhcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gSGVpZ2h0ZmllbGQob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBTaGFwZV8xLmRlZmF1bHQuSEVJR0hURklFTEQsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgaGVpZ2h0IHZhbHVlcywgdGhhdCBhcmUgc3ByZWFkIG91dCBhbG9uZyB0aGUgeCBheGlzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGhlaWdodHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5oZWlnaHRzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWF4IHZhbHVlIG9mIHRoZSBoZWlnaHRzXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubWF4VmFsdWUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgaGVpZ2h0c1xyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5WYWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLm1pblZhbHVlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgd2lkdGggb2YgZWFjaCBlbGVtZW50XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVsZW1lbnRXaWR0aFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmVsZW1lbnRXaWR0aCA9IDA7XHJcbiAgICAgICAgX3RoaXMuaGVpZ2h0cyA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVpZ2h0cykgPyBvcHRpb25zLmhlaWdodHMuc2xpY2UoMCkgOiBbXTtcclxuICAgICAgICBfdGhpcy5lbGVtZW50V2lkdGggPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZWxlbWVudFdpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLjE7XHJcbiAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4VmFsdWUpICYmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWluVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm1heFZhbHVlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1heFZhbHVlO1xyXG4gICAgICAgICAgICBfdGhpcy5taW5WYWx1ZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGVNYXhNaW5WYWx1ZXMoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgLm1pblZhbHVlIGFuZCB0aGUgLm1heFZhbHVlXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZU1heE1pblZhbHVlc1xyXG4gICAgICovXHJcbiAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlTWF4TWluVmFsdWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5oZWlnaHRzO1xyXG4gICAgICAgIHZhciBtYXhWYWx1ZSA9IGRhdGFbMF07XHJcbiAgICAgICAgdmFyIG1pblZhbHVlID0gZGF0YVswXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdiA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIGlmICh2ID4gbWF4VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodiA8IG1pblZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXhWYWx1ZSA9IG1heFZhbHVlO1xyXG4gICAgICAgIHRoaXMubWluVmFsdWUgPSBtaW5WYWx1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICB9O1xyXG4gICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBJbmZpbml0eTtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGluZ1JhZGl1cztcclxuICAgIH07XHJcbiAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuaGVpZ2h0cywgYXJlYSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBhcmVhICs9IChkYXRhW2ldICsgZGF0YVtpICsgMV0pIC8gMiAqIHRoaXMuZWxlbWVudFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFyZWEgPSBhcmVhO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFyZWE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKG91dCwgcG9zaXRpb24sIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLFxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSxcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY3JlYXRlKClcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChwb2ludHNbMF0sIDAsIHRoaXMubWF4VmFsdWUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChwb2ludHNbMV0sIHRoaXMuZWxlbWVudFdpZHRoICogdGhpcy5oZWlnaHRzLmxlbmd0aCwgdGhpcy5tYXhWYWx1ZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHBvaW50c1syXSwgdGhpcy5lbGVtZW50V2lkdGggKiB0aGlzLmhlaWdodHMubGVuZ3RoLCB0aGlzLm1pblZhbHVlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQocG9pbnRzWzNdLCAwLCB0aGlzLm1pblZhbHVlKTtcclxuICAgICAgICBvdXQuc2V0RnJvbVBvaW50cyhwb2ludHMsIHBvc2l0aW9uLCBhbmdsZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBsaW5lIHNlZ21lbnQgaW4gdGhlIGhlaWdodGZpZWxkXHJcbiAgICAgKiBAbWV0aG9kIGdldExpbmVTZWdtZW50XHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gc3RhcnQgV2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBzdGFydCBwb2ludFxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IGVuZCBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0aW5nIGVuZCBwb2ludFxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBpXHJcbiAgICAgKi9cclxuICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRMaW5lU2VnbWVudCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBpKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmhlaWdodHM7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5lbGVtZW50V2lkdGg7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHN0YXJ0LCBpICogd2lkdGgsIGRhdGFbaV0pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChlbmQsIChpICsgMSkgKiB3aWR0aCwgZGF0YVtpICsgMV0pO1xyXG4gICAgfTtcclxuICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRTZWdtZW50SW5kZXggPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihwb3NpdGlvblswXSAvIHRoaXMuZWxlbWVudFdpZHRoKTtcclxuICAgIH07XHJcbiAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Q2xhbXBlZFNlZ21lbnRJbmRleCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5nZXRTZWdtZW50SW5kZXgocG9zaXRpb24pO1xyXG4gICAgICAgIGkgPSBNYXRoLm1pbih0aGlzLmhlaWdodHMubGVuZ3RoLCBNYXRoLm1heChpLCAwKSk7IC8vIGNsYW1wXHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHJheWNhc3RcclxuICAgICAqIEBwYXJhbSAge1JheVJlc3VsdH0gcmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24gKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgZnJvbSA9IHJheS5mcm9tO1xyXG4gICAgICAgIHZhciB0byA9IHJheS50bztcclxuICAgICAgICB2YXIgd29ybGROb3JtYWwgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF93b3JsZE5vcm1hbDtcclxuICAgICAgICB2YXIgbDAgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sMDtcclxuICAgICAgICB2YXIgbDEgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sMTtcclxuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxGcm9tO1xyXG4gICAgICAgIHZhciBsb2NhbFRvID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxUbztcclxuICAgICAgICAvLyBnZXQgbG9jYWwgcmF5IHN0YXJ0IGFuZCBlbmRcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUobG9jYWxGcm9tLCBmcm9tLCBwb3NpdGlvbiwgYW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvTG9jYWxGcmFtZShsb2NhbFRvLCB0bywgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICAvLyBHZXQgdGhlIHNlZ21lbnQgcmFuZ2VcclxuICAgICAgICB2YXIgaTAgPSB0aGlzLmdldENsYW1wZWRTZWdtZW50SW5kZXgobG9jYWxGcm9tKTtcclxuICAgICAgICB2YXIgaTEgPSB0aGlzLmdldENsYW1wZWRTZWdtZW50SW5kZXgobG9jYWxUbyk7XHJcbiAgICAgICAgaWYgKGkwID4gaTEpIHtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IGkwO1xyXG4gICAgICAgICAgICBpMCA9IGkxO1xyXG4gICAgICAgICAgICBpMSA9IHRtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIHNlZ21lbnRzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhlaWdodHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZVNlZ21lbnQobDAsIGwxLCBpKTtcclxuICAgICAgICAgICAgdmFyIHQgPSB2ZWMyXzEuZGVmYXVsdC5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihsb2NhbEZyb20sIGxvY2FsVG8sIGwwLCBsMSk7XHJcbiAgICAgICAgICAgIGlmICh0ID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHdvcmxkTm9ybWFsLCBsMSwgbDApO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCwgYW5nbGUgKyBNYXRoLlBJIC8gMik7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCB0LCB3b3JsZE5vcm1hbCwgLTEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zaG91bGRTdG9wKHJheSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhlaWdodGZpZWxkO1xyXG59KFNoYXBlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBIZWlnaHRmaWVsZDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gdmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpXHJcbi8vICwgICBzaGFsbG93Q2xvbmUgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpLnNoYWxsb3dDbG9uZVxyXG4vLyAsICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xyXG52YXIgU2hhcGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9TaGFwZVwiKSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciByYXljYXN0X25vcm1hbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgcmF5Y2FzdF9sMCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgcmF5Y2FzdF9sMSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgcmF5Y2FzdF91bml0X3kgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDAsIDEpO1xyXG52YXIgTGluZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhMaW5lLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lIHNoYXBlIGNsYXNzLiBUaGUgbGluZSBzaGFwZSBpcyBhbG9uZyB0aGUgeCBkaXJlY3Rpb24sIGFuZCBzdHJldGNoZXMgZnJvbSBbLWxlbmd0aC8yLCAwXSB0byBbbGVuZ3RoLzIsMF0uXHJcbiAgICAgKiBAY2xhc3MgTGluZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAoTm90ZSB0aGF0IHRoaXMgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IGNvbnN0cnVjdG9yLilcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MV0gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgbGluZVxyXG4gICAgICogQGV4dGVuZHMgU2hhcGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XHJcbiAgICAgKiAgICAgdmFyIGxpbmVTaGFwZSA9IG5ldyBMaW5lKHtcclxuICAgICAqICAgICAgICAgbGVuZ3RoOiAxXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShsaW5lU2hhcGUpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBMaW5lKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgU2hhcGVfMS5kZWZhdWx0LkxJTkUsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVuZ3RoIG9mIHRoaXMgbGluZVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsZW5ndGhcclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubGVuZ3RoID0gMTtcclxuICAgICAgICBfdGhpcy5sZW5ndGggPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIExpbmUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHRoaXMubGVuZ3RoLCAyKSAvIDEyO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIExpbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSB0aGlzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdSYWRpdXM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgTGluZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAob3V0LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgcG9pbnRzID0gW3ZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKV07XHJcbiAgICAgICAgdmFyIGwyID0gdGhpcy5sZW5ndGggLyAyO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChwb2ludHNbMF0sIC1sMiwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHBvaW50c1sxXSwgbDIsIDApO1xyXG4gICAgICAgIG91dC5zZXRGcm9tUG9pbnRzKHBvaW50cywgcG9zaXRpb24sIGFuZ2xlLCAwKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBMaW5lLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCByYXljYXN0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcclxuICAgICAqIEBwYXJhbSAge1JheX0gcmF5XHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgTGluZS5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uIChyZXN1bHQsIHJheSwgcG9zaXRpb24sIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIGZyb20gPSByYXkuZnJvbTtcclxuICAgICAgICB2YXIgdG8gPSByYXkudG87XHJcbiAgICAgICAgdmFyIGwwID0gcmF5Y2FzdF9sMDtcclxuICAgICAgICB2YXIgbDEgPSByYXljYXN0X2wxO1xyXG4gICAgICAgIC8vIGdldCBzdGFydCBhbmQgZW5kIG9mIHRoZSBsaW5lXHJcbiAgICAgICAgdmFyIGhhbGZMZW4gPSB0aGlzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGwwLCAtaGFsZkxlbiwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGwxLCBoYWxmTGVuLCAwKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKGwwLCBsMCwgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKGwxLCBsMSwgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICB2YXIgZnJhY3Rpb24gPSB2ZWMyXzEuZGVmYXVsdC5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihsMCwgbDEsIGZyb20sIHRvKTtcclxuICAgICAgICBpZiAoZnJhY3Rpb24gPj0gMCkge1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gcmF5Y2FzdF9ub3JtYWw7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShub3JtYWwsIHJheWNhc3RfdW5pdF95LCBhbmdsZSk7IC8vIHRvZG86IHRoaXMgc2hvdWxkIGRlcGVuZCBvbiB3aGljaCBzaWRlIHRoZSByYXkgY29tZXMgZnJvbVxyXG4gICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZnJhY3Rpb24sIG5vcm1hbCwgLTEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gTGluZTtcclxufShTaGFwZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTGluZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gdmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpXHJcbi8vICwgICBzaGFsbG93Q2xvbmUgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpLnNoYWxsb3dDbG9uZVxyXG4vLyAsICAgY29weSA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpLmNvcHk7XHJcbnZhciBTaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1NoYXBlXCIpKTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIGNvcHkgPSB2ZWMyXzEuZGVmYXVsdC5jb3B5O1xyXG52YXIgUGFydGljbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUGFydGljbGUsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIFBhcnRpY2xlIHNoYXBlIGNsYXNzLlxyXG4gICAgICogQGNsYXNzIFBhcnRpY2xlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXHJcbiAgICAgKiBAZXh0ZW5kcyBTaGFwZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XHJcbiAgICAgKiAgICAgdmFyIHNoYXBlID0gbmV3IFBhcnRpY2xlKCk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFBhcnRpY2xlKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgU2hhcGVfMS5kZWZhdWx0LlBBUlRJQ0xFLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgUGFydGljbGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7IC8vIENhbid0IHJvdGF0ZSBhIHBhcnRpY2xlXHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgUGFydGljbGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFBhcnRpY2xlLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlQUFCQlxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gICBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgUGFydGljbGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKG91dCwgcG9zaXRpb24gLyosIGFuZ2xlKi8pIHtcclxuICAgICAgICBjb3B5KG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XHJcbiAgICAgICAgY29weShvdXQudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFBhcnRpY2xlLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24gKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpIHsgMTsgfTtcclxuICAgIHJldHVybiBQYXJ0aWNsZTtcclxufShTaGFwZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUGFydGljbGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBzaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlXCIpKTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIGludGVyc2VjdFBsYW5lX3BsYW5lUG9pbnRUb0Zyb20gPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdFBsYW5lX25vcm1hbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0UGxhbmVfbGVuID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBQbGFuZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQbGFuZSwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogUGxhbmUgc2hhcGUgY2xhc3MuIFRoZSBwbGFuZSBpcyBmYWNpbmcgaW4gdGhlIFkgZGlyZWN0aW9uLlxyXG4gICAgICogQGNsYXNzIFBsYW5lXHJcbiAgICAgKiBAZXh0ZW5kcyBTaGFwZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIChOb3RlIHRoYXQgdGhpcyBvcHRpb25zIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gY29uc3RydWN0b3IuKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XHJcbiAgICAgKiAgICAgdmFyIHNoYXBlID0gbmV3IFBsYW5lKCk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFBsYW5lKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc2hhcGVfMS5kZWZhdWx0LlBMQU5FLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIG1vbWVudCBvZiBpbmVydGlhXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcclxuICAgICAqL1xyXG4gICAgUGxhbmUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7IC8vIFBsYW5lIGlzIGluZmluaXRlLiBUaGUgaW5lcnRpYSBzaG91bGQgdGhlcmVmb3JlIGJlIGluZmludHkgYnV0IGJ5IGNvbnZlbnRpb24gd2Ugc2V0IDAgaGVyZVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXNcclxuICAgICAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcclxuICAgICAqL1xyXG4gICAgUGxhbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBJbmZpbml0eTtcclxuICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxyXG4gICAgICovXHJcbiAgICBQbGFuZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAob3V0LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgYSA9IGFuZ2xlICUgKDIgKiBNYXRoLlBJKTtcclxuICAgICAgICB2YXIgc2V0ID0gdmVjMl8xLmRlZmF1bHQuc2V0O1xyXG4gICAgICAgIHZhciBtYXggPSAxZTc7XHJcbiAgICAgICAgdmFyIGxvd2VyQm91bmQgPSBvdXQubG93ZXJCb3VuZDtcclxuICAgICAgICB2YXIgdXBwZXJCb3VuZCA9IG91dC51cHBlckJvdW5kO1xyXG4gICAgICAgIC8vIFNldCBtYXggYm91bmRzXHJcbiAgICAgICAgc2V0KGxvd2VyQm91bmQsIC1tYXgsIC1tYXgpO1xyXG4gICAgICAgIHNldCh1cHBlckJvdW5kLCBtYXgsIG1heCk7XHJcbiAgICAgICAgaWYgKGEgPT09IDApIHtcclxuICAgICAgICAgICAgLy8geSBnb2VzIGZyb20gLWluZiB0byAwXHJcbiAgICAgICAgICAgIHVwcGVyQm91bmRbMV0gPSBwb3NpdGlvblsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYSA9PT0gTWF0aC5QSSAvIDIpIHtcclxuICAgICAgICAgICAgLy8geCBnb2VzIGZyb20gMCB0byBpbmZcclxuICAgICAgICAgICAgbG93ZXJCb3VuZFswXSA9IHBvc2l0aW9uWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhID09PSBNYXRoLlBJKSB7XHJcbiAgICAgICAgICAgIC8vIHkgZ29lcyBmcm9tIDAgdG8gaW5mXHJcbiAgICAgICAgICAgIGxvd2VyQm91bmRbMV0gPSBwb3NpdGlvblsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYSA9PT0gMyAqIE1hdGguUEkgLyAyKSB7XHJcbiAgICAgICAgICAgIC8vIHggZ29lcyBmcm9tIC1pbmYgdG8gMFxyXG4gICAgICAgICAgICB1cHBlckJvdW5kWzBdID0gcG9zaXRpb25bMF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBsYW5lLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXJlYSA9IEluZmluaXR5O1xyXG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgcmF5Y2FzdFxyXG4gICAgICogQHBhcmFtICB7UmF5UmVzdWx0fSByZXN1bHRcclxuICAgICAqIEBwYXJhbSAge1JheX0gcmF5XHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgUGxhbmUucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbiAocmVzdWx0LCByYXksIHBvc2l0aW9uLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBmcm9tID0gcmF5LmZyb207XHJcbiAgICAgICAgdmFyIHRvID0gcmF5LnRvO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSByYXkuZGlyZWN0aW9uO1xyXG4gICAgICAgIHZhciBwbGFuZVBvaW50VG9Gcm9tID0gaW50ZXJzZWN0UGxhbmVfcGxhbmVQb2ludFRvRnJvbTtcclxuICAgICAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0UGxhbmVfbm9ybWFsO1xyXG4gICAgICAgIHZhciBsZW4gPSBpbnRlcnNlY3RQbGFuZV9sZW47XHJcbiAgICAgICAgLy8gR2V0IHBsYW5lIG5vcm1hbFxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChub3JtYWwsIDAsIDEpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShub3JtYWwsIG5vcm1hbCwgYW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KGxlbiwgZnJvbSwgcG9zaXRpb24pO1xyXG4gICAgICAgIHZhciBwbGFuZVRvRnJvbSA9IHZlYzJfMS5kZWZhdWx0LmRvdChsZW4sIG5vcm1hbCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QobGVuLCB0bywgcG9zaXRpb24pO1xyXG4gICAgICAgIHZhciBwbGFuZVRvVG8gPSB2ZWMyXzEuZGVmYXVsdC5kb3QobGVuLCBub3JtYWwpO1xyXG4gICAgICAgIGlmIChwbGFuZVRvRnJvbSAqIHBsYW5lVG9UbyA+IDApIHtcclxuICAgICAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBhcmUgb24gdGhlIHNhbWUgc2lkZSBvZiB0aGUgcGxhbmUuLi4gYmFpbCBvdXRcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmVjMl8xLmRlZmF1bHQuc3F1YXJlZERpc3RhbmNlKGZyb20sIHRvKSA8IHBsYW5lVG9Gcm9tICogcGxhbmVUb0Zyb20pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbl9kb3RfZGlyID0gdmVjMl8xLmRlZmF1bHQuZG90KG5vcm1hbCwgZGlyZWN0aW9uKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChwbGFuZVBvaW50VG9Gcm9tLCBmcm9tLCBwb3NpdGlvbik7XHJcbiAgICAgICAgdmFyIHQgPSAtdmVjMl8xLmRlZmF1bHQuZG90KG5vcm1hbCwgcGxhbmVQb2ludFRvRnJvbSkgLyBuX2RvdF9kaXIgLyByYXkubGVuZ3RoO1xyXG4gICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCB0LCBub3JtYWwsIC0xKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBQbGFuZS5wcm90b3R5cGUucG9pbnRUZXN0ID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxQb2ludFsxXSA8PSAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQbGFuZTtcclxufShzaGFwZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUGxhbmU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBzb2x2ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zb2x2ZXJcIikpO1xyXG52YXIgZnJpY3Rpb25fZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL2ZyaWN0aW9uLWVxdWF0aW9uXCIpKTtcclxuLy8gU2V0cyB0aGUgLm11bHRpcGxpZXIgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvblxyXG5mdW5jdGlvbiB1cGRhdGVNdWx0aXBsaWVycyhlcXVhdGlvbnMsIGludkR0KSB7XHJcbiAgICB2YXIgbCA9IGVxdWF0aW9ucy5sZW5ndGg7XHJcbiAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgdmFyIGVxID0gZXF1YXRpb25zW2xdO1xyXG4gICAgICAgIGVxLm11bHRpcGxpZXIgPSBlcS5sYW1iZGEgKiBpbnZEdDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpdGVyYXRlRXF1YXRpb24oZXEpIHtcclxuICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXHJcbiAgICB2YXIgQiA9IGVxLkIsIGVwcyA9IGVxLmVwc2lsb24sIGludkMgPSBlcS5pbnZDLCBsYW1iZGFqID0gZXEubGFtYmRhLCBHV2xhbWJkYSA9IGVxLmNvbXB1dGVHV2xhbWJkYSgpLCBtYXhGb3JjZV9kdCA9IGVxLm1heEZvcmNlRHQsIG1pbkZvcmNlX2R0ID0gZXEubWluRm9yY2VEdDtcclxuICAgIHZhciBkZWx0YWxhbWJkYSA9IGludkMgKiAoQiAtIEdXbGFtYmRhIC0gZXBzICogbGFtYmRhaik7XHJcbiAgICAvLyBDbGFtcCBpZiB3ZSBhcmUgbm90IHdpdGhpbiB0aGUgbWluL21heCBpbnRlcnZhbFxyXG4gICAgdmFyIGxhbWJkYWpfcGx1c19kZWx0YWxhbWJkYSA9IGxhbWJkYWogKyBkZWx0YWxhbWJkYTtcclxuICAgIGlmIChsYW1iZGFqX3BsdXNfZGVsdGFsYW1iZGEgPCBtaW5Gb3JjZV9kdCkge1xyXG4gICAgICAgIGRlbHRhbGFtYmRhID0gbWluRm9yY2VfZHQgLSBsYW1iZGFqO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhID4gbWF4Rm9yY2VfZHQpIHtcclxuICAgICAgICBkZWx0YWxhbWJkYSA9IG1heEZvcmNlX2R0IC0gbGFtYmRhajtcclxuICAgIH1cclxuICAgIGVxLmxhbWJkYSArPSBkZWx0YWxhbWJkYTtcclxuICAgIGVxLmFkZFRvV2xhbWJkYShkZWx0YWxhbWJkYSk7XHJcbiAgICByZXR1cm4gZGVsdGFsYW1iZGE7XHJcbn1cclxudmFyIEdTU29sdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEdTU29sdmVyLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRpdmUgR2F1c3MtU2VpZGVsIGNvbnN0cmFpbnQgZXF1YXRpb24gc29sdmVyLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBHU1NvbHZlclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBTb2x2ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pdGVyYXRpb25zPTEwXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvbGVyYW5jZT0wXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBHU1NvbHZlcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgc29sdmVyXzEuZGVmYXVsdC5HUykgfHwgdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdGhhdCB3ZXJlIG1hZGUgZHVyaW5nIHRoZSBsYXN0IHNvbHZlLiBJZiAudG9sZXJhbmNlIGlzIHplcm8sIHRoaXMgdmFsdWUgd2lsbCBhbHdheXMgYmUgZXF1YWwgdG8gLml0ZXJhdGlvbnMsIGJ1dCBpZiAudG9sZXJhbmNlIGlzIGxhcmdlciB0aGFuIHplcm8sIGFuZCB0aGUgc29sdmVyIGNhbiBxdWl0IGVhcmx5LCB0aGVuIHRoaXMgbnVtYmVyIHdpbGwgYmUgc29tZXdoZXJlIGJldHdlZW4gMSBhbmQgLml0ZXJhdGlvbnMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHVzZWRJdGVyYXRpb25zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudXNlZEl0ZXJhdGlvbnMgPSAwO1xyXG4gICAgICAgIF90aGlzLml0ZXJhdGlvbnMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaXRlcmF0aW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTA7XHJcbiAgICAgICAgX3RoaXMudG9sZXJhbmNlID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvbGVyYW5jZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMWUtNztcclxuICAgICAgICBfdGhpcy5mcmljdGlvbkl0ZXJhdGlvbnMgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZnJpY3Rpb25JdGVyYXRpb25zKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU29sdmUgdGhlIHN5c3RlbSBvZiBlcXVhdGlvbnNcclxuICAgICAqIEBtZXRob2Qgc29sdmVcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gIGggICAgICAgVGltZSBzdGVwXHJcbiAgICAgKiBAcGFyYW0gIHtXb3JsZH0gICB3b3JsZCAgICBXb3JsZCB0byBzb2x2ZVxyXG4gICAgICovXHJcbiAgICBHU1NvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbiAoaCwgd29ybGQpIHtcclxuICAgICAgICB0aGlzLnNvcnRFcXVhdGlvbnMoKTtcclxuICAgICAgICB2YXIgaXRlciA9IDAsIG1heEl0ZXIgPSB0aGlzLml0ZXJhdGlvbnMsIG1heEZyaWN0aW9uSXRlciA9IHRoaXMuZnJpY3Rpb25JdGVyYXRpb25zLCBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucywgTmVxID0gZXF1YXRpb25zLmxlbmd0aCwgdG9sU3F1YXJlZCA9IE1hdGgucG93KHRoaXMudG9sZXJhbmNlICogTmVxLCAyKSwgYm9kaWVzID0gd29ybGQuYm9kaWVzLCBOYm9kaWVzID0gYm9kaWVzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnVzZWRJdGVyYXRpb25zID0gMDtcclxuICAgICAgICBpZiAoTmVxKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHNvbHZlIG1hc3NcclxuICAgICAgICAgICAgICAgIGIudXBkYXRlU29sdmVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSAhPT0gTmVxOyBpXzErKykge1xyXG4gICAgICAgICAgICB2YXIgY18xID0gZXF1YXRpb25zW2lfMV07XHJcbiAgICAgICAgICAgIGNfMS5sYW1iZGEgPSAwO1xyXG4gICAgICAgICAgICBpZiAoY18xLnRpbWVTdGVwICE9PSBoIHx8IGNfMS5uZWVkc1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgY18xLnRpbWVTdGVwID0gaDtcclxuICAgICAgICAgICAgICAgIGNfMS51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjXzEuQiA9IGNfMS5jb21wdXRlQihjXzEuYSwgY18xLmIsIGgpO1xyXG4gICAgICAgICAgICBjXzEuaW52QyA9IGNfMS5jb21wdXRlSW52QyhjXzEuZXBzaWxvbik7XHJcbiAgICAgICAgICAgIGNfMS5tYXhGb3JjZUR0ID0gY18xLm1heEZvcmNlICogaDtcclxuICAgICAgICAgICAgY18xLm1pbkZvcmNlRHQgPSBjXzEubWluRm9yY2UgKiBoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYywgZGVsdGFsYW1iZGFUb3QsIGo7XHJcbiAgICAgICAgaWYgKE5lcSAhPT0gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdmxhbWJkYVxyXG4gICAgICAgICAgICAgICAgYi5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXhGcmljdGlvbkl0ZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBjb250YWN0IGVxdWF0aW9ucyB0byBnZXQgbm9ybWFsIGZvcmNlc1xyXG4gICAgICAgICAgICAgICAgZm9yIChpdGVyID0gMDsgaXRlciAhPT0gbWF4RnJpY3Rpb25JdGVyOyBpdGVyKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiAhPT0gTmVxOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGVxdWF0aW9uc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhbGFtYmRhID0gaXRlcmF0ZUVxdWF0aW9uKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBNYXRoLmFicyhkZWx0YWxhbWJkYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlZEl0ZXJhdGlvbnMrKztcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgZXJyb3IgaXMgc21hbGwgZW5vdWdoIC0gc3RvcCBpdGVyYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhbGFtYmRhVG90ICogZGVsdGFsYW1iZGFUb3QgPD0gdG9sU3F1YXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVNdWx0aXBsaWVycyhlcXVhdGlvbnMsIDEgLyBoKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBjb21wdXRlZCBmcmljdGlvbiBmb3JjZVxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiAhPT0gTmVxOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXEgPSBlcXVhdGlvbnNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVxIGluc3RhbmNlb2YgZnJpY3Rpb25fZXF1YXRpb25fMS5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayAhPT0gZXEuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiArPSBlcS5jb250YWN0RXF1YXRpb25zW2tdLm11bHRpcGxpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZiAqPSBlcS5mcmljdGlvbkNvZWZmaWNpZW50IC8gZXEuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxLm1heEZvcmNlID0gZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXEubWluRm9yY2UgPSAtZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXEubWF4Rm9yY2VEdCA9IGYgKiBoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcS5taW5Gb3JjZUR0ID0gLWYgKiBoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVxdWF0aW9uc1xyXG4gICAgICAgICAgICBmb3IgKGl0ZXIgPSAwOyBpdGVyICE9PSBtYXhJdGVyOyBpdGVyKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHRvdGFsIGVycm9yIGZvciBlYWNoIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiAhPT0gTmVxOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjID0gZXF1YXRpb25zW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YWxhbWJkYSA9IGl0ZXJhdGVFcXVhdGlvbihjKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBNYXRoLmFicyhkZWx0YWxhbWJkYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVzZWRJdGVyYXRpb25zKys7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgZXJyb3IgaXMgc21hbGwgZW5vdWdoIC0gc3RvcCBpdGVyYXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFsYW1iZGFUb3QgKiBkZWx0YWxhbWJkYVRvdCA8IHRvbFNxdWFyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBZGQgcmVzdWx0IHRvIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgIT09IE5ib2RpZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYm9kaWVzW2ldLmFkZENvbnN0cmFpbnRWZWxvY2l0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVwZGF0ZU11bHRpcGxpZXJzKGVxdWF0aW9ucywgMSAvIGgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gR1NTb2x2ZXI7XHJcbn0oc29sdmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBHU1NvbHZlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGV2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXZlbnRzL2V2ZW50LWVtaXR0ZXJcIikpO1xyXG52YXIgU29sdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNvbHZlciwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQmFzZSBjbGFzcyBmb3IgY29uc3RyYWludCBzb2x2ZXJzLlxyXG4gICAgICogQGNsYXNzIFNvbHZlclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU29sdmVyKG9wdGlvbnMsIHR5cGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IGVxdWF0aW9ucyBpbiB0aGUgc29sdmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gc29ydCBhbGwgZXF1YXRpb25zIGJlZm9yZSBlYWNoIHNvbHZlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvblNvcnRGdW5jdGlvblxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbnxib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmVxdWF0aW9uU29ydEZ1bmN0aW9uID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVxdWF0aW9uU29ydEZ1bmN0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0IGFsbCBlcXVhdGlvbnMgdXNpbmcgdGhlIC5lcXVhdGlvblNvcnRGdW5jdGlvbi4gU2hvdWxkIGJlIGNhbGxlZCBieSBzdWJjbGFzc2VzIGJlZm9yZSBzb2x2aW5nLlxyXG4gICAgICogQG1ldGhvZCBzb3J0RXF1YXRpb25zXHJcbiAgICAgKi9cclxuICAgIFNvbHZlci5wcm90b3R5cGUuc29ydEVxdWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lcXVhdGlvblNvcnRGdW5jdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmVxdWF0aW9ucy5zb3J0KHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBlcXVhdGlvbiB0byBiZSBzb2x2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBhZGRFcXVhdGlvblxyXG4gICAgICogQHBhcmFtIHtFcXVhdGlvbn0gZXFcclxuICAgICAqL1xyXG4gICAgU29sdmVyLnByb3RvdHlwZS5hZGRFcXVhdGlvbiA9IGZ1bmN0aW9uIChlcSkge1xyXG4gICAgICAgIGlmIChlcS5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBlcXVhdGlvbnMuIFNhbWUgYXMgLmFkZEVxdWF0aW9uLCBidXQgdGhpcyB0aW1lIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBvZiBFcXVhdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGFkZEVxdWF0aW9uc1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZXFzXHJcbiAgICAgKi9cclxuICAgIFNvbHZlci5wcm90b3R5cGUuYWRkRXF1YXRpb25zID0gZnVuY3Rpb24gKGVxcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBOID0gZXFzLmxlbmd0aDsgaSAhPT0gTjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlcSA9IGVxc1tpXTtcclxuICAgICAgICAgICAgaWYgKGVxLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFuIGVxdWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgcmVtb3ZlRXF1YXRpb25cclxuICAgICAqIEBwYXJhbSB7RXF1YXRpb259IGVxXHJcbiAgICAgKi9cclxuICAgIFNvbHZlci5wcm90b3R5cGUucmVtb3ZlRXF1YXRpb24gPSBmdW5jdGlvbiAoZXEpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YoZXEpO1xyXG4gICAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBjdXJyZW50bHkgYWRkZWQgZXF1YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgcmVtb3ZlQWxsRXF1YXRpb25zXHJcbiAgICAgKi9cclxuICAgIFNvbHZlci5wcm90b3R5cGUucmVtb3ZlQWxsRXF1YXRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYXVzcy1TZWlkZWwgc29sdmVyLlxyXG4gICAgICogQHByb3BlcnR5IEdTXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBTb2x2ZXIuR1MgPSAxO1xyXG4gICAgcmV0dXJuIFNvbHZlcjtcclxufShldmVudF9lbWl0dGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTb2x2ZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBwb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9vbFwiKSk7XHJcbnZhciBjb250YWN0X2VxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2VxdWF0aW9ucy9jb250YWN0LWVxdWF0aW9uXCIpKTtcclxudmFyIENvbnRhY3RFcXVhdGlvblBvb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29udGFjdEVxdWF0aW9uUG9vbCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENvbnRhY3RFcXVhdGlvblBvb2wob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHJldHVybiB7Q29udGFjdEVxdWF0aW9ufVxyXG4gICAgICovXHJcbiAgICBDb250YWN0RXF1YXRpb25Qb29sLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb250YWN0X2VxdWF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBkZXN0cm95XHJcbiAgICAgKiBAcGFyYW0ge0NvbnRhY3RFcXVhdGlvbn0gZXF1YXRpb25cclxuICAgICAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvblBvb2x9XHJcbiAgICAgKi9cclxuICAgIENvbnRhY3RFcXVhdGlvblBvb2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXF1YXRpb24pIHtcclxuICAgICAgICBlcXVhdGlvbi5ib2R5QSA9IGVxdWF0aW9uLmJvZHlCID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29udGFjdEVxdWF0aW9uUG9vbDtcclxufShwb29sXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb250YWN0RXF1YXRpb25Qb29sO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcG9vbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Bvb2xcIikpO1xyXG52YXIgZnJpY3Rpb25fZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL2ZyaWN0aW9uLWVxdWF0aW9uXCIpKTtcclxudmFyIEZyaWN0aW9uRXF1YXRpb25Qb29sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZyaWN0aW9uRXF1YXRpb25Qb29sLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRnJpY3Rpb25FcXVhdGlvblBvb2wob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHJldHVybiB7RnJpY3Rpb25FcXVhdGlvbn1cclxuICAgICAqL1xyXG4gICAgRnJpY3Rpb25FcXVhdGlvblBvb2wucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGZyaWN0aW9uX2VxdWF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBkZXN0cm95XHJcbiAgICAgKiBAcGFyYW0ge0ZyaWN0aW9uRXF1YXRpb259IGVxdWF0aW9uXHJcbiAgICAgKiBAcmV0dXJuIHtGcmljdGlvbkVxdWF0aW9uUG9vbH1cclxuICAgICAqL1xyXG4gICAgRnJpY3Rpb25FcXVhdGlvblBvb2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXF1YXRpb24pIHtcclxuICAgICAgICBlcXVhdGlvbi5ib2R5QSA9IGVxdWF0aW9uLmJvZHlCID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gRnJpY3Rpb25FcXVhdGlvblBvb2w7XHJcbn0ocG9vbF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRnJpY3Rpb25FcXVhdGlvblBvb2w7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBwb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9vbFwiKSk7XHJcbnZhciBvdmVybGFwX2tlZXBlcl9yZWNvcmRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9vdmVybGFwLWtlZXBlci1yZWNvcmRcIikpO1xyXG52YXIgT3ZlcmxhcEtlZXBlclJlY29yZFBvb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoT3ZlcmxhcEtlZXBlclJlY29yZFBvb2wsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBPdmVybGFwS2VlcGVyUmVjb3JkUG9vbChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcmV0dXJuIHtPdmVybGFwS2VlcGVyUmVjb3JkfVxyXG4gICAgICovXHJcbiAgICBPdmVybGFwS2VlcGVyUmVjb3JkUG9vbC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgb3ZlcmxhcF9rZWVwZXJfcmVjb3JkXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBkZXN0cm95XHJcbiAgICAgKiBAcGFyYW0ge092ZXJsYXBLZWVwZXJSZWNvcmR9IHJlY29yZFxyXG4gICAgICogQHJldHVybiB7T3ZlcmxhcEtlZXBlclJlY29yZFBvb2x9XHJcbiAgICAgKi9cclxuICAgIE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIHJlY29yZC5zZXQodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gT3ZlcmxhcEtlZXBlclJlY29yZFBvb2w7XHJcbn0ocG9vbF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gT3ZlcmxhcEtlZXBlclJlY29yZFBvb2w7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBPdmVybGFwS2VlcGVyUmVjb3JkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVybGFwIGRhdGEgY29udGFpbmVyIGZvciB0aGUgT3ZlcmxhcEtlZXBlclxyXG4gICAgICogQGNsYXNzIE92ZXJsYXBLZWVwZXJSZWNvcmRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gT3ZlcmxhcEtlZXBlclJlY29yZChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKSB7XHJcbiAgICAgICAgdGhpcy5zZXQoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZGF0YSBmb3IgdGhlIHJlY29yZFxyXG4gICAgICogQG1ldGhvZCBzZXRcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXHJcbiAgICAgKi9cclxuICAgIE92ZXJsYXBLZWVwZXJSZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKSB7XHJcbiAgICAgICAgdGhpcy5zaGFwZUEgPSBzaGFwZUE7XHJcbiAgICAgICAgdGhpcy5zaGFwZUIgPSBzaGFwZUI7XHJcbiAgICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gT3ZlcmxhcEtlZXBlclJlY29yZDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gT3ZlcmxhcEtlZXBlclJlY29yZDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHR1cGxlX2RpY3Rpb25hcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90dXBsZS1kaWN0aW9uYXJ5XCIpKTtcclxudmFyIG92ZXJsYXBfa2VlcGVyX3JlY29yZF9wb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb3ZlcmxhcC1rZWVwZXItcmVjb3JkLXBvb2xcIikpO1xyXG52YXIgT3ZlcmxhcEtlZXBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgdHJhY2sgb2Ygb3ZlcmxhcHMgaW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHRoZSBsYXN0IHN0ZXAgc3RhdGUuXHJcbiAgICAgKiBAY2xhc3MgT3ZlcmxhcEtlZXBlclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE92ZXJsYXBLZWVwZXIoKSB7XHJcbiAgICAgICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZSA9IG5ldyB0dXBsZV9kaWN0aW9uYXJ5XzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUgPSBuZXcgdHVwbGVfZGljdGlvbmFyeV8xLmRlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLnJlY29yZFBvb2wgPSBuZXcgb3ZlcmxhcF9rZWVwZXJfcmVjb3JkX3Bvb2xfMS5kZWZhdWx0KHsgc2l6ZTogMTYgfSk7XHJcbiAgICAgICAgdGhpcy50bXBEaWN0ID0gbmV3IHR1cGxlX2RpY3Rpb25hcnlfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgdGhpcy50bXBBcnJheTEgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGlja3Mgb25lIHN0ZXAgZm9yd2FyZCBpbiB0aW1lLiBUaGlzIHdpbGwgbW92ZSB0aGUgY3VycmVudCBvdmVybGFwIHN0YXRlIHRvIHRoZSBcIm9sZFwiIG92ZXJsYXAgc3RhdGUsIGFuZCBjcmVhdGUgYSBuZXcgb25lIGFzIGN1cnJlbnQuXHJcbiAgICAgKiBAbWV0aG9kIHRpY2tcclxuICAgICAqL1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbGFzdCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGU7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xyXG4gICAgICAgIC8vIFNhdmUgb2xkIG9iamVjdHMgaW50byBwb29sXHJcbiAgICAgICAgdmFyIGwgPSBsYXN0LmtleXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGxhc3Qua2V5c1tsXTtcclxuICAgICAgICAgICAgdmFyIGxhc3RPYmplY3QgPSBsYXN0LmdldEJ5S2V5KGtleSk7XHJcbiAgICAgICAgICAgIGlmIChsYXN0T2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVjb3JkIGlzIG9ubHkgdXNlZCBpbiB0aGUgXCJsYXN0XCIgZGljdCwgYW5kIHdpbGwgYmUgcmVtb3ZlZC4gV2UgbWlnaHQgYXMgd2VsbCBwb29sIGl0LlxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRQb29sLnJlbGVhc2UobGFzdE9iamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xlYXIgbGFzdCBvYmplY3RcclxuICAgICAgICBsYXN0LnJlc2V0KCk7XHJcbiAgICAgICAgLy8gVHJhbnNmZXIgZnJvbSBuZXcgb2JqZWN0IHRvIG9sZFxyXG4gICAgICAgIGxhc3QuY29weShjdXJyZW50KTtcclxuICAgICAgICAvLyBDbGVhciBjdXJyZW50IG9iamVjdFxyXG4gICAgICAgIGN1cnJlbnQucmVzZXQoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2Qgc2V0T3ZlcmxhcHBpbmdcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gc2hhcGVBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IHNoYXBlQlxyXG4gICAgICovXHJcbiAgICBPdmVybGFwS2VlcGVyLnByb3RvdHlwZS5zZXRPdmVybGFwcGluZyA9IGZ1bmN0aW9uIChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xyXG4gICAgICAgIC8vIFN0b3JlIGN1cnJlbnQgY29udGFjdCBzdGF0ZVxyXG4gICAgICAgIGlmICghY3VycmVudC5nZXQoc2hhcGVBLmlkLCBzaGFwZUIuaWQpKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5yZWNvcmRQb29sLmdldCgpO1xyXG4gICAgICAgICAgICBkYXRhLnNldChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcclxuICAgICAgICAgICAgY3VycmVudC5zZXQoc2hhcGVBLmlkLCBzaGFwZUIuaWQsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXROZXdPdmVybGFwcyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXREaWZmKHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGUsIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUsIHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RW5kT3ZlcmxhcHMgPSBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlmZih0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlLCB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlLCByZXN1bHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHR3byBib2RpZXMgYXJlIGN1cnJlbnRseSBvdmVybGFwcGluZy5cclxuICAgICAqIEBtZXRob2QgYm9kaWVzQXJlT3ZlcmxhcHBpbmdcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuYm9kaWVzQXJlT3ZlcmxhcHBpbmcgPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xyXG4gICAgICAgIHZhciBsID0gY3VycmVudC5rZXlzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBjdXJyZW50LmtleXNbbF07XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gY3VycmVudC5kYXRhW2tleV07XHJcbiAgICAgICAgICAgIGlmICgoZGF0YS5ib2R5QSA9PT0gYm9keUEgJiYgZGF0YS5ib2R5QiA9PT0gYm9keUIpIHx8IGRhdGEuYm9keUEgPT09IGJvZHlCICYmIGRhdGEuYm9keUIgPT09IGJvZHlBKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RGlmZiA9IGZ1bmN0aW9uIChkaWN0QSwgZGljdEIsIHJlc3VsdCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgW107XHJcbiAgICAgICAgdmFyIGxhc3QgPSBkaWN0QTtcclxuICAgICAgICB2YXIgY3VycmVudCA9IGRpY3RCO1xyXG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHZhciBsID0gY3VycmVudC5rZXlzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBjdXJyZW50LmtleXNbbF07XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gY3VycmVudC5kYXRhW2tleV07XHJcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgJyArIGtleSArICcgaGFkIG5vIGRhdGEhJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxhc3REYXRhID0gbGFzdC5kYXRhW2tleV07XHJcbiAgICAgICAgICAgIGlmICghbGFzdERhdGEpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdCBvdmVybGFwcGluZyBpbiBsYXN0IHN0YXRlLCBidXQgaW4gY3VycmVudC5cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuaXNOZXdPdmVybGFwID0gZnVuY3Rpb24gKHNoYXBlQSwgc2hhcGVCKSB7XHJcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlO1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcclxuICAgICAgICAvLyBOb3QgaW4gbGFzdCBidXQgaW4gbmV3XHJcbiAgICAgICAgcmV0dXJuICFsYXN0LmdldChzaGFwZUEuaWQsIHNoYXBlQi5pZCkgJiYgISFjdXJyZW50LmdldChzaGFwZUEuaWQsIHNoYXBlQi5pZCk7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0TmV3Qm9keU92ZXJsYXBzID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMudG1wQXJyYXkxLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdmFyIG92ZXJsYXBzID0gdGhpcy5nZXROZXdPdmVybGFwcyh0aGlzLnRtcEFycmF5MSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm9keURpZmYob3ZlcmxhcHMsIHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RW5kQm9keU92ZXJsYXBzID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMudG1wQXJyYXkxLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdmFyIG92ZXJsYXBzID0gdGhpcy5nZXRFbmRPdmVybGFwcyh0aGlzLnRtcEFycmF5MSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm9keURpZmYob3ZlcmxhcHMsIHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0Qm9keURpZmYgPSBmdW5jdGlvbiAob3ZlcmxhcHMsIHJlc3VsdCkge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcclxuICAgICAgICB2YXIgYWNjdW11bGF0b3IgPSB0aGlzLnRtcERpY3Q7XHJcbiAgICAgICAgdmFyIGwgPSBvdmVybGFwcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGwtLSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IG92ZXJsYXBzW2xdO1xyXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSB1c2UgYm9keSBpZCdzIGZvciB0aGUgYWNjdW11bGF0b3IsIHRoZXNlIHdpbGwgYmUgYSBzdWJzZXQgb2YgdGhlIG9yaWdpbmFsIG9uZVxyXG4gICAgICAgICAgICBhY2N1bXVsYXRvci5zZXQoZGF0YS5ib2R5QS5pZCB8IDAsIGRhdGEuYm9keUIuaWQgfCAwLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbCA9IGFjY3VtdWxhdG9yLmtleXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBhY2N1bXVsYXRvci5nZXRCeUtleShhY2N1bXVsYXRvci5rZXlzW2xdKTtcclxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGEuYm9keUEpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZGF0YS5ib2R5Qik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYWNjdW11bGF0b3IucmVzZXQoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBPdmVybGFwS2VlcGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBPdmVybGFwS2VlcGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgUG9vbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogT2JqZWN0IHBvb2xpbmcgdXRpbGl0eS5cclxuICAgICAqIEBjbGFzcyBQb29sXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUG9vbChvcHRpb25zKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gb2JqZWN0c1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9iamVjdHMgPSBbXTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemUob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpemUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCByZXNpemVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXHJcbiAgICAgKiBAcmV0dXJuIHtQb29sfSBTZWxmLCBmb3IgY2hhaW5pbmdcclxuICAgICAqL1xyXG4gICAgUG9vbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICB2YXIgb2JqZWN0cyA9IHRoaXMub2JqZWN0cztcclxuICAgICAgICB3aGlsZSAob2JqZWN0cy5sZW5ndGggPiBzaXplKSB7XHJcbiAgICAgICAgICAgIG9iamVjdHMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChvYmplY3RzLmxlbmd0aCA8IHNpemUpIHtcclxuICAgICAgICAgICAgb2JqZWN0cy5wdXNoKHRoaXMuY3JlYXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbiBvYmplY3QgZnJvbSB0aGUgcG9vbCBvciBjcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICAgKiBAbWV0aG9kIGdldFxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBQb29sLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLm9iamVjdHM7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdHMubGVuZ3RoID8gb2JqZWN0cy5wb3AoKSA6IHRoaXMuY3JlYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhbiB1cCBhbmQgcHV0IHRoZSBvYmplY3QgYmFjayBpbnRvIHRoZSBwb29sIGZvciBsYXRlciB1c2UuXHJcbiAgICAgKiBAbWV0aG9kIHJlbGVhc2VcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcclxuICAgICAqIEByZXR1cm4ge1Bvb2x9IFNlbGYgZm9yIGNoYWluaW5nXHJcbiAgICAgKi9cclxuICAgIFBvb2wucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95KG9iamVjdCk7XHJcbiAgICAgICAgdGhpcy5vYmplY3RzLnB1c2gob2JqZWN0KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gUG9vbDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUG9vbDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHV0aWxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xyXG52YXIgVHVwbGVEaWN0aW9uYXJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3MgVHVwbGVEaWN0aW9uYXJ5XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVHVwbGVEaWN0aW9uYXJ5KCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkYXRhIHN0b3JhZ2VcclxuICAgICAgICAgKiBAcHJvcGVydHkgZGF0YVxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgdXNlZC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBrZXlzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5rZXlzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIGEga2V5IGdpdmVuIHR3byBpbnRlZ2Vyc1xyXG4gICAgICogQG1ldGhvZCBnZXRLZXlcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gaVxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKGlkMSwgaWQyKSB7XHJcbiAgICAgICAgaWYgKChpZDEpID09PSAoaWQyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHZhbGlkIGZvciB2YWx1ZXMgPCAyXjE2XHJcbiAgICAgICAgcmV0dXJuICgoaWQxKSA+IChpZDIpID9cclxuICAgICAgICAgICAgKGlkMSA8PCAxNikgfCAoaWQyICYgMHhGRkZGKSA6XHJcbiAgICAgICAgICAgIChpZDIgPDwgMTYpIHwgKGlkMSAmIDB4RkZGRikpIHwgMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZ2V0QnlLZXlcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0ga2V5XHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIFR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0QnlLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAga2V5ID0ga2V5O1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZ2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0galxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBUdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpLCBqKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmdldEtleShpLCBqKV07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSB2YWx1ZS5cclxuICAgICAqIEBtZXRob2Qgc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0galxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXHJcbiAgICAgKi9cclxuICAgIFR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGksIGosIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhIVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGksIGopO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGtleSBhbHJlYWR5IGV4aXN0c1xyXG4gICAgICAgIGlmICghdGhpcy5kYXRhW2tleV0pIHtcclxuICAgICAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBkYXRhLlxyXG4gICAgICogQG1ldGhvZCByZXNldFxyXG4gICAgICovXHJcbiAgICBUdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLCBrZXlzID0gdGhpcy5rZXlzO1xyXG4gICAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGwtLSkge1xyXG4gICAgICAgICAgICBkZWxldGUgZGF0YVtrZXlzW2xdXTtcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5cy5sZW5ndGggPSAwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29weSBhbm90aGVyIFR1cGxlRGljdGlvbmFyeS4gTm90ZSB0aGF0IGFsbCBkYXRhIGluIHRoaXMgZGljdGlvbmFyeSB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgKiBAbWV0aG9kIGNvcHlcclxuICAgICAqIEBwYXJhbSB7VHVwbGVEaWN0aW9uYXJ5fSBkaWN0IFRoZSBUdXBsZURpY3Rpb25hcnkgdG8gY29weSBpbnRvIHRoaXMgb25lLlxyXG4gICAgICovXHJcbiAgICBUdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoZGljdCkge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB1dGlsc18xLmRlZmF1bHQuYXBwZW5kQXJyYXkodGhpcy5rZXlzLCBkaWN0LmtleXMpO1xyXG4gICAgICAgIHZhciBsID0gZGljdC5rZXlzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBkaWN0LmtleXNbbF07XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVtrZXldID0gZGljdC5kYXRhW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBUdXBsZURpY3Rpb25hcnk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFR1cGxlRGljdGlvbmFyeTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyogZ2xvYmFsIFAyX0FSUkFZX1RZUEUgKi9cclxuLyoqXHJcbiAqIE1pc2MgdXRpbGl0eSBmdW5jdGlvbnNcclxuICovXHJcbnZhciBVdGlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFV0aWxzKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmQgdGhlIHZhbHVlcyBpbiBhcnJheSBiIHRvIHRoZSBhcnJheSBhLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM3NDEyNi9ob3ctdG8tYXBwZW5kLWFuLWFycmF5LXRvLWFuLWV4aXN0aW5nLWphdmFzY3JpcHQtYXJyYXkvMTM3NDEzMSMxMzc0MTMxXCI+dGhpczwvYT4gZm9yIGFuIGV4cGxhbmF0aW9uLlxyXG4gICAgICogQG1ldGhvZCBhcHBlbmRBcnJheVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBiXHJcbiAgICAgKi9cclxuICAgIFV0aWxzLnByb3RvdHlwZS5hcHBlbmRBcnJheSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGIubGVuZ3RoOyBpICE9PSBsZW47ICsraSkge1xyXG4gICAgICAgICAgICBhLnB1c2goYltpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2FyYmFnZSBmcmVlIEFycmF5LnNwbGljZSgpLiBEb2VzIG5vdCBhbGxvY2F0ZSBhIG5ldyBhcnJheS5cclxuICAgICAqIEBtZXRob2Qgc3BsaWNlXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyYXlcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaW5kZXhcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaG93bWFueVxyXG4gICAgICovXHJcbiAgICBVdGlscy5wcm90b3R5cGUuc3BsaWNlID0gZnVuY3Rpb24gKGFycmF5LCBpbmRleCwgaG93bWFueSkge1xyXG4gICAgICAgIGhvd21hbnkgPSBob3dtYW55IHx8IDE7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4LCBsZW4gPSBhcnJheS5sZW5ndGggLSBob3dtYW55OyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgaG93bWFueV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFycmF5Lmxlbmd0aCA9IGxlbjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBlbGVtZW50IGZyb20gYW4gYXJyYXksIGlmIHRoZSBhcnJheSBjb250YWlucyB0aGUgZWxlbWVudC5cclxuICAgICAqIEBtZXRob2QgYXJyYXlSZW1vdmVcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnJheVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIFV0aWxzLnByb3RvdHlwZS5hcnJheVJlbW92ZSA9IGZ1bmN0aW9uIChhcnJheSwgZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBpZHggPSBhcnJheS5pbmRleE9mKGVsZW1lbnQpO1xyXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlKGFycmF5LCBpZHgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBhbm90aGVyXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGV4dGVuZFxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBhXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGJcclxuICAgICAqL1xyXG4gICAgVXRpbHMucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGIpIHtcclxuICAgICAgICAgICAgYVtrZXldID0gYltrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNoYWxsb3cgY2xvbmUgYW4gb2JqZWN0LiBSZXR1cm5zIGEgbmV3IG9iamVjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgdGhlIGlucHV0IGluc3RhbmNlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBzaGFsbG93Q2xvbmVcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gb2JqXHJcbiAgICAgKi9cclxuICAgIFV0aWxzLnByb3RvdHlwZS5zaGFsbG93Q2xvbmUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgdmFyIG5ld09iaiA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXh0ZW5kKG5ld09iaiwgb2JqKTtcclxuICAgICAgICByZXR1cm4gbmV3T2JqO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBVdGlscztcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFV0aWxzKCk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBVbmlvbkZpbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIFdlaWdodGVkIFF1aWNrIFVuaW9uLUZpbmQgd2l0aCBQYXRoIENvbXByZXNzaW9uLiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vanV6ZXJhbGkvdW5pb25maW5kLCBidXQgb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZS5cclxuICAgICAqIEBjbGFzcyBVbmlvbkZpbmRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVW5pb25GaW5kKHNpemUpIHtcclxuICAgICAgICB0aGlzLmlkID0gW107XHJcbiAgICAgICAgdGhpcy5zeiA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpemVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgZGlzdGluY3QgZ3JvdXBzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb3VudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY291bnQgPSBzaXplO1xyXG4gICAgICAgIHRoaXMucmVzaXplKHNpemUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSBVbmlvbkZpbmQgZGF0YSBzdHJ1Y3R1cmUgd2l0aCBudW1iZXIgb2YgZGlzdGluY3QgZ3JvdXBzIHRvIGJlZ2luIHdpdGguIEVhY2ggZ3JvdXAgd2lsbCBiZSByZWZlcnJlZCB0byBhcyBpbmRleCBvZiB0aGUgYXJyYXkgb2Ygc2l6ZSBzaXplIHN0YXJ0aW5nIGF0IDAuXHJcbiAgICAgKiBAbWV0aG9kIHJlc2l6ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVcclxuICAgICAqL1xyXG4gICAgVW5pb25GaW5kLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgIHRoaXMuY291bnQgPSB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgICAgIHZhciBzeiA9IHRoaXMuc3o7XHJcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBpZFtpXSA9IGk7XHJcbiAgICAgICAgICAgIHN6W2ldID0gMTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHJvb3QgKHZhbHVlKSBvZiB0aGUgZ3JvdXAgaW4gd2hpY2ggcCBpcy5cclxuICAgICAqIEBtZXRob2QgZmluZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBcclxuICAgICAqL1xyXG4gICAgVW5pb25GaW5kLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xyXG4gICAgICAgIHdoaWxlIChwICE9PSBpZFtwXSkge1xyXG4gICAgICAgICAgICBpZFtwXSA9IGlkW2lkW3BdXTtcclxuICAgICAgICAgICAgcCA9IGlkW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmUgZWxlbWVudHMgaW4gZ3JvdXBzIHAgYW5kIHEgaW50byBhIHNpbmdsZSBncm91cC4gSW4gb3RoZXIgd29yZHMgY29ubmVjdCB0aGUgdHdvIGdyb3Vwcy5cclxuICAgICAqIEBtZXRob2QgdW5pb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcVxyXG4gICAgICovXHJcbiAgICBVbmlvbkZpbmQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24gKHAsIHEpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuZmluZChwKSwgaiA9IHRoaXMuZmluZChxKTtcclxuICAgICAgICBpZiAoaSA9PT0gaikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzeiA9IHRoaXMuc3o7XHJcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcclxuICAgICAgICBpZiAoc3pbaV0gPCBzeltqXSkge1xyXG4gICAgICAgICAgICBpZFtpXSA9IGo7XHJcbiAgICAgICAgICAgIHN6W2pdICs9IHN6W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWRbal0gPSBpO1xyXG4gICAgICAgICAgICBzeltpXSArPSBzeltqXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb3VudC0tO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVW5pb25GaW5kO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBVbmlvbkZpbmQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBnc19zb2x2ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc29sdmVyL2dzLXNvbHZlclwiKSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBzaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFwZXMvc2hhcGVcIikpO1xyXG52YXIgZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldmVudHMvZXZlbnQtZW1pdHRlclwiKSk7XHJcbnZhciBib2R5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL29iamVjdHMvYm9keVwiKSk7XHJcbnZhciBtYXRlcmlhbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRlcmlhbC9tYXRlcmlhbFwiKSk7XHJcbnZhciBjb250YWN0X21hdGVyaWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGVyaWFsL2NvbnRhY3QtbWF0ZXJpYWxcIikpO1xyXG52YXIgYWFiYl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9jb2xsaXNpb24vYWFiYlwiKSk7XHJcbnZhciBzYXBfYnJvYWRwaGFzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9jb2xsaXNpb24vc2FwLWJyb2FkcGhhc2VcIikpO1xyXG52YXIgbmFycm93cGhhc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vY29sbGlzaW9uL25hcnJvd3BoYXNlXCIpKTtcclxudmFyIHV0aWxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL3V0aWxzXCIpKTtcclxuLy9pbXBvcnQgYXJyYXlSZW1vdmUgZnJvbSAgXCJheVJlbW9cIjsgLy8gR2V0IHJpZCBvZiB0aGlzIGRlcGVuZGVuY3khXHJcbnZhciBvdmVybGFwX2tlZXBlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9vdmVybGFwLWtlZXBlclwiKSk7XHJcbnZhciB1bmlvbl9maW5kXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdW5pb24tZmluZFwiKSk7XHJcbi8vaW1wb3J0IGYzMiBmcm9tIFwiZjMyXCI7XHJcbi8qKlxyXG4gKiBGaXJlZCBhZnRlciB0aGUgc3RlcCgpLlxyXG4gKiBAZXZlbnQgcG9zdFN0ZXBcclxuICovXHJcbnZhciBwb3N0U3RlcEV2ZW50ID0ge1xyXG4gICAgdHlwZTogXCJwb3N0U3RlcFwiXHJcbn07XHJcbi8qKlxyXG4gKiBGaXJlZCB3aGVuIGEgYm9keSBpcyBhZGRlZCB0byB0aGUgd29ybGQuXHJcbiAqIEBldmVudCBhZGRCb2R5XHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gKi9cclxudmFyIEFkZEJvZHlFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFkZEJvZHlFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcImFkZEJvZHlcIjtcclxuICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFkZEJvZHlFdmVudDtcclxufSgpKTtcclxudmFyIGFkZEJvZHlFdmVudCA9IG5ldyBBZGRCb2R5RXZlbnQoKTtcclxuLyoqXHJcbiAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIHJlbW92ZWQgZnJvbSB0aGUgd29ybGQuXHJcbiAqIEBldmVudCByZW1vdmVCb2R5XHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gKi9cclxudmFyIFJlbW92ZUJvZHlFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlbW92ZUJvZHlFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInJlbW92ZUJvZHlcIjtcclxuICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlbW92ZUJvZHlFdmVudDtcclxufSgpKTtcclxudmFyIHJlbW92ZUJvZHlFdmVudCA9IG5ldyBSZW1vdmVCb2R5RXZlbnQoKTtcclxuLyoqXHJcbiAqIEZpcmVkIHdoZW4gYSBzcHJpbmcgaXMgYWRkZWQgdG8gdGhlIHdvcmxkLlxyXG4gKiBAZXZlbnQgYWRkU3ByaW5nXHJcbiAqIEBwYXJhbSB7U3ByaW5nfSBzcHJpbmdcclxuICovXHJcbnZhciBBZGRTcHJpbmdFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFkZFNwcmluZ0V2ZW50KCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiYWRkU3ByaW5nXCI7XHJcbiAgICAgICAgdGhpcy5zcHJpbmcgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFkZFNwcmluZ0V2ZW50O1xyXG59KCkpO1xyXG52YXIgYWRkU3ByaW5nRXZlbnQgPSBuZXcgQWRkU3ByaW5nRXZlbnQoKTtcclxuLyoqXHJcbiAqIEZpcmVkIHdoZW4gYSBmaXJzdCBjb250YWN0IGlzIGNyZWF0ZWQgYmV0d2VlbiB0d28gYm9kaWVzLiBUaGlzIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBzdGVwIGhhcyBiZWVuIGRvbmUuXHJcbiAqIEBldmVudCBpbXBhY3RcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAqIEBkZXByZWNhdGVkIEltcGFjdCBldmVudCB3aWxsIGJlIHJlbW92ZWQuIFVzZSBiZWdpbkNvbnRhY3QgaW5zdGVhZC5cclxuICovXHJcbnZhciBJbXBhY3RFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEltcGFjdEV2ZW50KCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiaW1wYWN0XCI7XHJcbiAgICAgICAgdGhpcy5ib2R5QSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib2R5QiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaGFwZUEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2hhcGVCID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSW1wYWN0RXZlbnQ7XHJcbn0oKSk7XHJcbnZhciBpbXBhY3RFdmVudCA9IG5ldyBJbXBhY3RFdmVudCgpO1xyXG4vKipcclxuICogRmlyZWQgYWZ0ZXIgdGhlIEJyb2FkcGhhc2UgaGFzIGNvbGxlY3RlZCBjb2xsaXNpb24gcGFpcnMgaW4gdGhlIHdvcmxkLlxyXG4gKiBJbnNpZGUgdGhlIGV2ZW50IGhhbmRsZXIsIHlvdSBjYW4gbW9kaWZ5IHRoZSBwYWlycyBhcnJheSBhcyB5b3UgbGlrZSwgdG9cclxuICogcHJldmVudCBjb2xsaXNpb25zIGJldHdlZW4gb2JqZWN0cyB0aGF0IHlvdSBkb24ndCB3YW50LlxyXG4gKiBAZXZlbnQgcG9zdEJyb2FkcGhhc2VcclxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMgQW4gYXJyYXkgb2YgY29sbGlzaW9uIHBhaXJzLiBJZiB0aGlzIGFycmF5IGlzIFtib2R5MSxib2R5Mixib2R5Myxib2R5NF0sIHRoZW4gdGhlIGJvZHkgcGFpcnMgMSwyIGFuZCAzLDQgd291bGQgYWR2YW5jZSB0byBuYXJyb3dwaGFzZS5cclxuICovXHJcbnZhciBQb3N0QnJvYWRwaGFzZUV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUG9zdEJyb2FkcGhhc2VFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInBvc3RCcm9hZHBoYXNlXCI7XHJcbiAgICAgICAgdGhpcy5wYWlycyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUG9zdEJyb2FkcGhhc2VFdmVudDtcclxufSgpKTtcclxudmFyIHBvc3RCcm9hZHBoYXNlRXZlbnQgPSBuZXcgUG9zdEJyb2FkcGhhc2VFdmVudDtcclxudmFyIEJlZ2luQ29udGFjdEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmVnaW5Db250YWN0RXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJiZWdpbkNvbnRhY3RcIjtcclxuICAgICAgICB0aGlzLnNoYXBlQSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaGFwZUIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYm9keUEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYm9keUIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJlZ2luQ29udGFjdEV2ZW50O1xyXG59KCkpO1xyXG4vKipcclxuICogRmlyZWQgd2hlbiB0d28gc2hhcGVzIHN0YXJ0cyBzdGFydCB0byBvdmVybGFwLiBGaXJlZCBpbiB0aGUgbmFycm93cGhhc2UsIGR1cmluZyBzdGVwLlxyXG4gKiBAZXZlbnQgYmVnaW5Db250YWN0XHJcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxyXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUJcclxuICogQHBhcmFtIHtCb2R5fSAgYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSAgYm9keUJcclxuICogQHBhcmFtIHtBcnJheX0gY29udGFjdEVxdWF0aW9uc1xyXG4gKi9cclxudmFyIGJlZ2luQ29udGFjdEV2ZW50ID0gbmV3IEJlZ2luQ29udGFjdEV2ZW50KCk7XHJcbi8qKlxyXG4gKiBGaXJlZCB3aGVuIHR3byBzaGFwZXMgc3RvcCBvdmVybGFwcGluZywgYWZ0ZXIgdGhlIG5hcnJvd3BoYXNlIChkdXJpbmcgc3RlcCkuXHJcbiAqIEBldmVudCBlbmRDb250YWN0XHJcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxyXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUJcclxuICogQHBhcmFtIHtCb2R5fSAgYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSAgYm9keUJcclxuICovXHJcbnZhciBlbmRDb250YWN0RXZlbnQgPSB7XHJcbiAgICB0eXBlOiBcImVuZENvbnRhY3RcIixcclxuICAgIHNoYXBlQTogbnVsbCxcclxuICAgIHNoYXBlQjogbnVsbCxcclxuICAgIGJvZHlBOiBudWxsLFxyXG4gICAgYm9keUI6IG51bGxcclxufTtcclxudmFyIGhpdFRlc3RfdG1wMSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBoaXRUZXN0X3RtcDIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuLyoqXHJcbiAqIEZpcmVkIGp1c3QgYmVmb3JlIGVxdWF0aW9ucyBhcmUgYWRkZWQgdG8gdGhlIHNvbHZlciB0byBiZSBzb2x2ZWQuIENhbiBiZSB1c2VkIHRvIGNvbnRyb2wgd2hhdCBlcXVhdGlvbnMgZ29lcyBpbnRvIHRoZSBzb2x2ZXIuXHJcbiAqIEBldmVudCBwcmVTb2x2ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBjb250YWN0RXF1YXRpb25zICBBbiBhcnJheSBvZiBjb250YWN0cyB0byBiZSBzb2x2ZWQuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGZyaWN0aW9uRXF1YXRpb25zIEFuIGFycmF5IG9mIGZyaWN0aW9uIGVxdWF0aW9ucyB0byBiZSBzb2x2ZWQuXHJcbiAqL1xyXG52YXIgUHJlU29sdmVFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByZVNvbHZlRXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwcmVTb2x2ZVwiO1xyXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJlU29sdmVFdmVudDtcclxufSgpKTtcclxudmFyIHByZVNvbHZlRXZlbnQgPSBuZXcgUHJlU29sdmVFdmVudCgpO1xyXG5mdW5jdGlvbiBzb3J0Qm9kaWVzQnlJc2xhbmQoYSwgYikge1xyXG4gICAgcmV0dXJuIGEuaXNsYW5kSWQgLSBiLmlzbGFuZElkO1xyXG59XHJcbmZ1bmN0aW9uIHNvcnRFcXVhdGlvbnNCeUlzbGFuZChlcXVhdGlvbkEsIGVxdWF0aW9uQikge1xyXG4gICAgaWYgKCEoZXF1YXRpb25BID09PSBudWxsIHx8IGVxdWF0aW9uQSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXF1YXRpb25BLmJvZHlBKSB8fCAhKGVxdWF0aW9uQSA9PT0gbnVsbCB8fCBlcXVhdGlvbkEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVxdWF0aW9uQS5ib2R5QikgfHwgIShlcXVhdGlvbkIgPT09IG51bGwgfHwgZXF1YXRpb25CID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcXVhdGlvbkIuYm9keUEpIHx8ICEoZXF1YXRpb25CID09PSBudWxsIHx8IGVxdWF0aW9uQiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXF1YXRpb25CLmJvZHlCKSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciBpc2xhbmRBID0gZXF1YXRpb25BLmJvZHlBLmlzbGFuZElkID4gMCA/IGVxdWF0aW9uQS5ib2R5QS5pc2xhbmRJZCA6IGVxdWF0aW9uQS5ib2R5Qi5pc2xhbmRJZDtcclxuICAgIHZhciBpc2xhbmRCID0gZXF1YXRpb25CLmJvZHlBLmlzbGFuZElkID4gMCA/IGVxdWF0aW9uQi5ib2R5QS5pc2xhbmRJZCA6IGVxdWF0aW9uQi5ib2R5Qi5pc2xhbmRJZDtcclxuICAgIGlmIChpc2xhbmRBICE9PSBpc2xhbmRCKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzbGFuZEEgLSBpc2xhbmRCO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gU29ydCBieSBlcXVhdGlvbiB0eXBlIGlmIHNhbWUgaXNsYW5kXHJcbiAgICAgICAgcmV0dXJuIGVxdWF0aW9uQS5pbmRleCAtIGVxdWF0aW9uQi5pbmRleDtcclxuICAgIH1cclxufVxyXG4vLyBXaHkgbm90IGp1c3QgbWFrZSB0aGlzIGEgcHJpdmF0ZSBtZXRob2QgaW4gd29ybGQ/XHJcbi8vIFdoYXQgYXJlIGFsbCB0aGVzZSBwcm9wcz8/P1xyXG5mdW5jdGlvbiBydW5OYXJyb3dwaGFzZSh3b3JsZCwgbnAsIGJpLCBzaSwgeGksIGFpLCBiaiwgc2osIHhqLCBhaiwgY20sIGdsZW4pIHtcclxuICAgIHZhciB4aXcgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgIHZhciB4ancgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgIC8vIENoZWNrIGNvbGxpc2lvbiBncm91cHMgYW5kIG1hc2tzXHJcbiAgICBpZiAoISgoc2kuY29sbGlzaW9uR3JvdXAgJiBzai5jb2xsaXNpb25NYXNrKSAhPT0gMCAmJiAoc2ouY29sbGlzaW9uR3JvdXAgJiBzaS5jb2xsaXNpb25NYXNrKSAhPT0gMCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBHZXQgd29ybGQgcG9zaXRpb24gYW5kIGFuZ2xlIG9mIGVhY2ggc2hhcGVcclxuICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUoeGl3LCB4aSwgYmkucG9zaXRpb24sIGJpLmFuZ2xlKTtcclxuICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUoeGp3LCB4aiwgYmoucG9zaXRpb24sIGJqLmFuZ2xlKTtcclxuICAgIGlmICh2ZWMyXzEuZGVmYXVsdC5kaXN0YW5jZSh4aXcsIHhqdykgPiBzaS5ib3VuZGluZ1JhZGl1cyArIHNqLmJvdW5kaW5nUmFkaXVzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGFpdyA9IGFpICsgYmkuYW5nbGU7XHJcbiAgICB2YXIgYWp3ID0gYWogKyBiai5hbmdsZTtcclxuICAgIG5wLmVuYWJsZUZyaWN0aW9uID0gY20uZnJpY3Rpb24gPiAwO1xyXG4gICAgdmFyIHJlZHVjZWRNYXNzO1xyXG4gICAgaWYgKGJpLnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LlNUQVRJQyB8fCBiaS50eXBlID09PSBib2R5XzEuZGVmYXVsdC5LSU5FTUFUSUMpIHtcclxuICAgICAgICByZWR1Y2VkTWFzcyA9IGJqLm1hc3M7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiai50eXBlID09PSBib2R5XzEuZGVmYXVsdC5TVEFUSUMgfHwgYmoudHlwZSA9PT0gYm9keV8xLmRlZmF1bHQuS0lORU1BVElDKSB7XHJcbiAgICAgICAgcmVkdWNlZE1hc3MgPSBiaS5tYXNzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVkdWNlZE1hc3MgPSAoYmkubWFzcyAqIGJqLm1hc3MpIC8gKGJpLm1hc3MgKyBiai5tYXNzKTtcclxuICAgIH1cclxuICAgIG5wLnNsaXBGb3JjZSA9IGNtLmZyaWN0aW9uICogZ2xlbiAqIHJlZHVjZWRNYXNzO1xyXG4gICAgbnAuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IGNtO1xyXG4gICAgbnAuZW5hYmxlZEVxdWF0aW9ucyA9IGJpLmNvbGxpc2lvblJlc3BvbnNlICYmIGJqLmNvbGxpc2lvblJlc3BvbnNlICYmIHNpLmNvbGxpc2lvblJlc3BvbnNlICYmIHNqLmNvbGxpc2lvblJlc3BvbnNlO1xyXG4gICAgdmFyIHNlbnNvciA9IHNpLnNlbnNvciB8fCBzai5zZW5zb3I7XHJcbiAgICB2YXIgbnVtRnJpY3Rpb25CZWZvcmUgPSBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7XHJcbiAgICB2YXIgbnVtQ29udGFjdHMgPSBucC50ZXN0Q29udGFjdChiaSwgc2ksIHhpdywgYmosIHNqLCB4ancsIHNlbnNvcik7XHJcbiAgICB2YXIgbnVtRnJpY3Rpb25FcXVhdGlvbnMgPSBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggLSBudW1GcmljdGlvbkJlZm9yZTtcclxuICAgIGlmIChudW1Db250YWN0cykge1xyXG4gICAgICAgIGlmIChiaS5hbGxvd1NsZWVwICYmXHJcbiAgICAgICAgICAgIGJpLnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LkRZTkFNSUMgJiZcclxuICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSA9PT0gYm9keV8xLmRlZmF1bHQuU0xFRVBJTkcgJiZcclxuICAgICAgICAgICAgYmouc2xlZXBTdGF0ZSA9PT0gYm9keV8xLmRlZmF1bHQuQVdBS0UgJiZcclxuICAgICAgICAgICAgYmoudHlwZSAhPT0gYm9keV8xLmRlZmF1bHQuU1RBVElDKSB7XHJcbiAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRCID0gdmVjMl8xLmRlZmF1bHQuc3F1YXJlZExlbmd0aChiai52ZWxvY2l0eSkgKyBNYXRoLnBvdyhiai5hbmd1bGFyVmVsb2NpdHksIDIpO1xyXG4gICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWRCID0gTWF0aC5wb3coYmouc2xlZXBTcGVlZExpbWl0LCAyKTtcclxuICAgICAgICAgICAgaWYgKHNwZWVkU3F1YXJlZEIgPj0gc3BlZWRMaW1pdFNxdWFyZWRCICogMikge1xyXG4gICAgICAgICAgICAgICAgYmkuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiai5hbGxvd1NsZWVwICYmXHJcbiAgICAgICAgICAgIGJqLnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LkRZTkFNSUMgJiZcclxuICAgICAgICAgICAgYmouc2xlZXBTdGF0ZSA9PT0gYm9keV8xLmRlZmF1bHQuU0xFRVBJTkcgJiZcclxuICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSA9PT0gYm9keV8xLmRlZmF1bHQuQVdBS0UgJiZcclxuICAgICAgICAgICAgYmkudHlwZSAhPT0gYm9keV8xLmRlZmF1bHQuU1RBVElDKSB7XHJcbiAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRBID0gdmVjMl8xLmRlZmF1bHQuc3F1YXJlZExlbmd0aChiaS52ZWxvY2l0eSkgKyBNYXRoLnBvdyhiaS5hbmd1bGFyVmVsb2NpdHksIDIpO1xyXG4gICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWRBID0gTWF0aC5wb3coYmkuc2xlZXBTcGVlZExpbWl0LCAyKTtcclxuICAgICAgICAgICAgaWYgKHNwZWVkU3F1YXJlZEEgPj0gc3BlZWRMaW1pdFNxdWFyZWRBICogMikge1xyXG4gICAgICAgICAgICAgICAgYmouX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdvcmxkLm92ZXJsYXBLZWVwZXIuc2V0T3ZlcmxhcHBpbmcoYmksIHNpLCBiaiwgc2opO1xyXG4gICAgICAgIGlmICh3b3JsZC5oYXMoJ2JlZ2luQ29udGFjdCcpICYmIHdvcmxkLm92ZXJsYXBLZWVwZXIuaXNOZXdPdmVybGFwKHNpLCBzaikpIHtcclxuICAgICAgICAgICAgLy8gUmVwb3J0IG5ldyBzaGFwZSBvdmVybGFwXHJcbiAgICAgICAgICAgIHZhciBlID0gYmVnaW5Db250YWN0RXZlbnQ7XHJcbiAgICAgICAgICAgIGUuc2hhcGVBID0gc2k7XHJcbiAgICAgICAgICAgIGUuc2hhcGVCID0gc2o7XHJcbiAgICAgICAgICAgIGUuYm9keUEgPSBiaTtcclxuICAgICAgICAgICAgZS5ib2R5QiA9IGJqO1xyXG4gICAgICAgICAgICAvLyBSZXNldCBjb250YWN0IGVxdWF0aW9uc1xyXG4gICAgICAgICAgICBlLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgaWYgKCFzZW5zb3IpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBucC5jb250YWN0RXF1YXRpb25zLmxlbmd0aCAtIG51bUNvbnRhY3RzOyBpIDwgbnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuY29udGFjdEVxdWF0aW9ucy5wdXNoKG5wLmNvbnRhY3RFcXVhdGlvbnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdvcmxkLmVtaXQoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRpdmlkZSB0aGUgbWF4IGZyaWN0aW9uIGZvcmNlIGJ5IHRoZSBudW1iZXIgb2YgY29udGFjdHNcclxuICAgICAgICBpZiAoIXNlbnNvciAmJiBudW1GcmljdGlvbkVxdWF0aW9ucyA+IDEpIHsgLy8gV2h5IGRpdmlkZSBieSAxP1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoIC0gbnVtRnJpY3Rpb25FcXVhdGlvbnM7IGkgPCBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBucC5mcmljdGlvbkVxdWF0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgIGYuc2V0U2xpcEZvcmNlKGYuZ2V0U2xpcEZvcmNlKCkgLyBudW1GcmljdGlvbkVxdWF0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0R2xvYmFsRXF1YXRpb25QYXJhbXMod29ybGQsIHBhcmFtcykge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHZhciBjb25zdHJhaW50cyA9IHdvcmxkLmNvbnN0cmFpbnRzO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcclxuICAgICAgICB2YXIgZXFzID0gYy5lcXVhdGlvbnM7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogIT09IGVxcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICB2YXIgZXEgPSBlcXNbal07XHJcbiAgICAgICAgICAgIGVxLnJlbGF4YXRpb24gPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucmVsYXhhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXEucmVsYXhhdGlvbjtcclxuICAgICAgICAgICAgZXEuc3RpZmZuZXNzID0gKF9iID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnN0aWZmbmVzcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZXEuc3RpZmZuZXNzO1xyXG4gICAgICAgICAgICBlcS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbnZhciBXb3JsZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhXb3JsZCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGR5bmFtaWNzIHdvcmxkLCB3aGVyZSBhbGwgYm9kaWVzIGFuZCBjb25zdHJhaW50cyBsaXZlLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBXb3JsZFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge1NvbHZlcn0gW29wdGlvbnMuc29sdmVyXSBEZWZhdWx0cyB0byBHU1NvbHZlci5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmdyYXZpdHldIERlZmF1bHRzIHRvIHk9LTkuNzguXHJcbiAgICAgKiBAcGFyYW0ge0Jyb2FkcGhhc2V9IFtvcHRpb25zLmJyb2FkcGhhc2VdIERlZmF1bHRzIHRvIFNBUEJyb2FkcGhhc2VcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNsYW5kU3BsaXQ9dHJ1ZV1cclxuICAgICAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKHtcclxuICAgICAqICAgICAgICAgZ3Jhdml0eTogWzAsIC0xMF0sXHJcbiAgICAgKiAgICAgICAgIGJyb2FkcGhhc2U6IG5ldyBTQVBCcm9hZHBoYXNlKClcclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KG5ldyBCb2R5KCkpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBXb3JsZChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxsIHNwcmluZ3MgaW4gdGhlIHdvcmxkLiBUbyBhZGQgYSBzcHJpbmcgdG8gdGhlIHdvcmxkLCB1c2Uge3sjY3Jvc3NMaW5rIFwiV29ybGQvYWRkU3ByaW5nOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzcHJpbmdzXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNwcmluZ3MgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGwgYm9kaWVzIGluIHRoZSB3b3JsZC4gVG8gYWRkIGEgYm9keSB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRCb2R5Om1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBib2RpZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5ib2RpZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlZCBib2R5IGNvbGxpc2lvbiBwYWlycy4gU2VlIHt7I2Nyb3NzTGluayBcIldvcmxkL2Rpc2FibGVCb2R5Q29sbGlzaW9uOm1ldGhvZFwifX0uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBkaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG5hcnJvd3BoYXNlIHRvIHVzZSB0byBnZW5lcmF0ZSBjb250YWN0cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBuYXJyb3dwaGFzZVxyXG4gICAgICAgICAqIEB0eXBlIHtOYXJyb3dwaGFzZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5uYXJyb3dwaGFzZSA9IG5ldyBuYXJyb3dwaGFzZV8xLmRlZmF1bHQoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHcmF2aXR5IGluIHRoZSB3b3JsZC4gVGhpcyBpcyBhcHBsaWVkIG9uIGFsbCBib2RpZXMgaW4gdGhlIGJlZ2lubmluZyBvZiBlYWNoIHN0ZXAoKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5XHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmdyYXZpdHkgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDAsIC05Ljc4KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHcmF2aXR5IHRvIHVzZSB3aGVuIGFwcHJveGltYXRpbmcgdGhlIGZyaWN0aW9uIG1heCBmb3JjZSAobXUqbWFzcypncmF2aXR5KS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJpY3Rpb25HcmF2aXR5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZnJpY3Rpb25HcmF2aXR5ID0gMTA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgLmZyaWN0aW9uR3Jhdml0eSB0byBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGUgbGVuZ3RoIG9mIC5ncmF2aXR5LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHlcclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBsZW5ndGggb2YgLmdyYXZpdHkgaXMgemVybywgYW5kIC51c2VXb3JsZEdyYXZpdHlBc0ZyaWN0aW9uR3Jhdml0eT10cnVlLCB0aGVuIHN3aXRjaCB0byB1c2luZyAuZnJpY3Rpb25HcmF2aXR5IGZvciBmcmljdGlvbiBpbnN0ZWFkLiBUaGlzIGZhbGxiYWNrIGlzIHVzZWZ1bCBmb3IgZ3Jhdml0eWxlc3MgZ2FtZXMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5XHJcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnVzZUZyaWN0aW9uR3Jhdml0eU9uWmVyb0dyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZXItYWRkZWQgY29uc3RyYWludHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuY29uc3RyYWludHMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEdW1teSBkZWZhdWx0IG1hdGVyaWFsIGluIHRoZSB3b3JsZCwgdXNlZCBpbiAuZGVmYXVsdENvbnRhY3RNYXRlcmlhbFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TWF0ZXJpYWx9IGRlZmF1bHRNYXRlcmlhbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmRlZmF1bHRNYXRlcmlhbCA9IG5ldyBtYXRlcmlhbF8xLmRlZmF1bHQoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGb3Iga2VlcGluZyB0cmFjayBvZiB3aGF0IHRpbWUgc3RlcCBzaXplIHdlIHVzZWQgbGFzdCBzdGVwXHJcbiAgICAgICAgICogQHByb3BlcnR5IGxhc3RUaW1lU3RlcFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubGFzdFRpbWVTdGVwID0gMSAvIDYwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuYWJsZSB0byBhdXRvbWF0aWNhbGx5IGFwcGx5IHNwcmluZyBmb3JjZXMgZWFjaCBzdGVwLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhcHBseVNwcmluZ0ZvcmNlc1xyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5hcHBseVNwcmluZ0ZvcmNlcyA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5hYmxlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgYm9keSBkYW1waW5nIGVhY2ggc3RlcC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYXBwbHlEYW1waW5nXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmFwcGx5RGFtcGluZyA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5hYmxlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgZ3Jhdml0eSBlYWNoIHN0ZXAuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGFwcGx5R3Jhdml0eVxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5hcHBseUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuYWJsZS9kaXNhYmxlIGNvbnN0cmFpbnQgc29sdmluZyBpbiBlYWNoIHN0ZXAuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNvbHZlQ29uc3RyYWludHNcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuc29sdmVDb25zdHJhaW50cyA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIENvbnRhY3RNYXRlcmlhbHMgYWRkZWQgdG8gdGhlIFdvcmxkLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb250YWN0TWF0ZXJpYWxzXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNvbnRhY3RNYXRlcmlhbHMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXb3JsZCB0aW1lLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0aW1lXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy50aW1lID0gMC4wO1xyXG4gICAgICAgIF90aGlzLmFjY3VtdWxhdG9yID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJcyB0cnVlIGR1cmluZyBzdGVwKCkuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzdGVwcGluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnN0ZXBwaW5nID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0byBlbmFibGUgaXNsYW5kIHNwbGl0dGluZy4gSXNsYW5kIHNwbGl0dGluZyBjYW4gYmUgYW4gYWR2YW50YWdlIGZvciBib3RoIHByZWNpc2lvbiBhbmQgcGVyZm9ybWFuY2UuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc2xhbmRTcGxpdFxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuaXNsYW5kU3BsaXQgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHRoZSB3b3JsZCB0byBlbWl0IHRoZSBcImltcGFjdFwiIGV2ZW50LiBUdXJuaW5nIHRoaXMgb2ZmIGNvdWxkIGltcHJvdmUgcGVyZm9ybWFuY2UuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGVtaXRJbXBhY3RFdmVudFxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBJbXBhY3QgZXZlbnQgd2lsbCBiZSByZW1vdmVkLiBVc2UgYmVnaW5Db250YWN0IGluc3RlYWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZW1pdEltcGFjdEV2ZW50ID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb3cgdG8gZGVhY3RpdmF0ZSBib2RpZXMgZHVyaW5nIHNpbXVsYXRpb24uIFBvc3NpYmxlIG1vZGVzIGFyZToge3sjY3Jvc3NMaW5rIFwiV29ybGQvTk9fU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuTk9fU0xFRVBJTkd7ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiV29ybGQvQk9EWV9TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5CT0RZX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIldvcmxkL0lTTEFORF9TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5JU0xBTkRfU0xFRVBJTkd7ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBJZiBzbGVlcGluZyBpcyBlbmFibGVkLCB5b3UgbWlnaHQgbmVlZCB0byB7eyNjcm9zc0xpbmsgXCJCb2R5L3dha2VVcDptZXRob2RcIn19d2FrZSB1cHt7L2Nyb3NzTGlua319IHRoZSBib2RpZXMgaWYgdGhleSBmYWxsIGFzbGVlcCB3aGVuIHRoZXkgc2hvdWxkbid0LiBJZiB5b3Ugd2FudCB0byBlbmFibGUgc2xlZXBpbmcgaW4gdGhlIHdvcmxkLCBidXQgd2FudCB0byBkaXNhYmxlIGl0IGZvciBhIHBhcnRpY3VsYXIgYm9keSwgc2VlIHt7I2Nyb3NzTGluayBcIkJvZHkvYWxsb3dTbGVlcDpwcm9wZXJ0eVwifX1Cb2R5LmFsbG93U2xlZXB7ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgc2xlZXBNb2RlXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBXb3JsZC5OT19TTEVFUElOR1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNsZWVwTW9kZSA9IFdvcmxkLk5PX1NMRUVQSU5HO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VW5pb25GaW5kfSB1bmlvbkZpbmRcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy51bmlvbkZpbmQgPSBuZXcgdW5pb25fZmluZF8xLmRlZmF1bHQoMSk7XHJcbiAgICAgICAgLy8gSWQgY291bnRlcnNcclxuICAgICAgICBfdGhpcy5fY29uc3RyYWludElkQ291bnRlciA9IDA7XHJcbiAgICAgICAgX3RoaXMuX2JvZHlJZENvdW50ZXIgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3ZlcmxhcEtlZXBlcn0gb3ZlcmxhcEtlZXBlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLm92ZXJsYXBLZWVwZXIgPSBuZXcgb3ZlcmxhcF9rZWVwZXJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgX3RoaXMuc29sdmVyID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNvbHZlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IGdzX3NvbHZlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmdyYXZpdHkpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShfdGhpcy5ncmF2aXR5LCBvcHRpb25zLmdyYXZpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5mcmljdGlvbkdyYXZpdHkgPSAoX2IgPSB2ZWMyXzEuZGVmYXVsdC5sZW5ndGgoX3RoaXMuZ3Jhdml0eSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEwO1xyXG4gICAgICAgIF90aGlzLmJyb2FkcGhhc2UgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYnJvYWRwaGFzZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IHNhcF9icm9hZHBoYXNlXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIF90aGlzLmJyb2FkcGhhc2Uuc2V0V29ybGQoX3RoaXMpO1xyXG4gICAgICAgIF90aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwgPSBuZXcgY29udGFjdF9tYXRlcmlhbF8xLmRlZmF1bHQoX3RoaXMuZGVmYXVsdE1hdGVyaWFsLCBfdGhpcy5kZWZhdWx0TWF0ZXJpYWwpO1xyXG4gICAgICAgIF90aGlzLmlzbGFuZFNwbGl0ID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlzbGFuZFNwbGl0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgY29uc3RyYWludCB0byB0aGUgc2ltdWxhdGlvbi4gTm90ZSB0aGF0IGJvdGggYm9kaWVzIGNvbm5lY3RlZCB0byB0aGUgY29uc3RyYWludCBtdXN0IGJlIGFkZGVkIHRvIHRoZSB3b3JsZCBmaXJzdC4gQWxzbyBub3RlIHRoYXQgeW91IGNhbid0IHJ1biB0aGlzIG1ldGhvZCBkdXJpbmcgc3RlcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGFkZENvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSB7Q29uc3RyYWludH0gY29uc3RyYWludFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBMb2NrQ29uc3RyYWludChib2R5QSwgYm9keUIpO1xyXG4gICAgICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5hZGRDb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGVwcGluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnN0cmFpbnRzIGNhbm5vdCBiZSBhZGRlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xyXG4gICAgICAgIGlmIChib2RpZXMuaW5kZXhPZihjb25zdHJhaW50LmJvZHlBKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIENvbnN0cmFpbnQ6IGJvZHlBIGlzIG5vdCBhZGRlZCB0byB0aGUgV29ybGQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChib2RpZXMuaW5kZXhPZihjb25zdHJhaW50LmJvZHlCKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIENvbnN0cmFpbnQ6IGJvZHlCIGlzIG5vdCBhZGRlZCB0byB0aGUgV29ybGQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIENvbnRhY3RNYXRlcmlhbCB0byB0aGUgc2ltdWxhdGlvbi5cclxuICAgICAqIEBtZXRob2QgYWRkQ29udGFjdE1hdGVyaWFsXHJcbiAgICAgKiBAcGFyYW0ge0NvbnRhY3RNYXRlcmlhbH0gY29udGFjdE1hdGVyaWFsXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5hZGRDb250YWN0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoY29udGFjdE1hdGVyaWFsKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWN0TWF0ZXJpYWxzLnB1c2goY29udGFjdE1hdGVyaWFsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjb250YWN0IG1hdGVyaWFsXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCByZW1vdmVDb250YWN0TWF0ZXJpYWxcclxuICAgICAqIEBwYXJhbSB7Q29udGFjdE1hdGVyaWFsfSBjbVxyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUucmVtb3ZlQ29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFycmF5UmVtb3ZlKHRoaXMuY29udGFjdE1hdGVyaWFscywgY20pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgY29udGFjdCBtYXRlcmlhbCBnaXZlbiB0d28gbWF0ZXJpYWxzXHJcbiAgICAgKiBAbWV0aG9kIGdldENvbnRhY3RNYXRlcmlhbFxyXG4gICAgICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxBXHJcbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEJcclxuICAgICAqIEByZXR1cm4ge0NvbnRhY3RNYXRlcmlhbH0gVGhlIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgb3IgZmFsc2Ugb24gZmFpbC5cclxuICAgICAqIEB0b2RvIFVzZSBmYXN0ZXIgaGFzaCBtYXAgdG8gbG9va3VwIGZyb20gbWF0ZXJpYWwgaWQnc1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuZ2V0Q29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24gKG1hdGVyaWFsQSwgbWF0ZXJpYWxCKSB7XHJcbiAgICAgICAgdmFyIGNtYXRzID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBOID0gY21hdHMubGVuZ3RoOyBpICE9PSBOOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNtID0gY21hdHNbaV07XHJcbiAgICAgICAgICAgIGlmICgoY20ubWF0ZXJpYWxBID09PSBtYXRlcmlhbEEgJiYgY20ubWF0ZXJpYWxCID09PSBtYXRlcmlhbEIpIHx8IChjbS5tYXRlcmlhbEEgPT09IG1hdGVyaWFsQiAmJiBjbS5tYXRlcmlhbEIgPT09IG1hdGVyaWFsQSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjb25zdHJhaW50LiBOb3RlIHRoYXQgeW91IGNhbid0IHJ1biB0aGlzIG1ldGhvZCBkdXJpbmcgc3RlcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSB7Q29uc3RyYWludH0gY29uc3RyYWludFxyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RlcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJhaW50cyBjYW5ub3QgYmUgcmVtb3ZlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFycmF5UmVtb3ZlKHRoaXMuY29uc3RyYWludHMsIGNvbnN0cmFpbnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RlcCB0aGUgcGh5c2ljcyB3b3JsZCBmb3J3YXJkIGluIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlcmUgYXJlIHR3byBtb2Rlcy4gVGhlIHNpbXBsZSBtb2RlIGlzIGZpeGVkIHRpbWVzdGVwcGluZyB3aXRob3V0IGludGVycG9sYXRpb24uIEluIHRoaXMgY2FzZSB5b3Ugb25seSB1c2UgdGhlIGZpcnN0IGFyZ3VtZW50LiBUaGUgc2Vjb25kIGNhc2UgdXNlcyBpbnRlcnBvbGF0aW9uLiBJbiB0aGF0IHlvdSBhbHNvIHByb3ZpZGUgdGhlIHRpbWUgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IHVzZWQsIGFzIHdlbGwgYXMgdGhlIG1heGltdW0gZml4ZWQgdGltZXN0ZXBzIHRvIHRha2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBzdGVwXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZHQgICAgICAgICAgICAgICAgICAgICAgIFRoZSBmaXhlZCB0aW1lIHN0ZXAgc2l6ZSB0byB1c2UuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTaW5jZUxhc3RDYWxsZWQ9MF0gIFRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IGNhbGxlZC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4U3ViU3RlcHM9MTBdICAgICAgICAgTWF4aW11bSBudW1iZXIgb2YgZml4ZWQgc3RlcHMgdG8gdGFrZSBwZXIgZnVuY3Rpb24gY2FsbC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIC8vIFNpbXBsZSBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uXHJcbiAgICAgKiAgICAgdmFyIGZpeGVkVGltZVN0ZXAgPSAxIC8gNjA7XHJcbiAgICAgKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCk7XHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgZnVuY3Rpb24gYW5pbWF0ZSgpe1xyXG4gICAgICogICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgKiAgICAgICAgIHdvcmxkLnN0ZXAoZml4ZWRUaW1lU3RlcCk7XHJcbiAgICAgKiAgICAgICAgIHJlbmRlckJvZHkoYm9keS5wb3NpdGlvbiwgYm9keS5hbmdsZSk7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBTdGFydCBhbmltYXRpb24gbG9vcFxyXG4gICAgICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIC8vIEZpeGVkIHRpbWVzdGVwcGluZyB3aXRoIGludGVycG9sYXRpb25cclxuICAgICAqICAgICB2YXIgbWF4U3ViU3RlcHMgPSAxMDtcclxuICAgICAqICAgICB2YXIgbGFzdFRpbWVTZWNvbmRzO1xyXG4gICAgICpcclxuICAgICAqICAgICBmdW5jdGlvbiBhbmltYXRlKHRpbWUpe1xyXG4gICAgICogICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgKiAgICAgICAgIHZhciB0aW1lU2Vjb25kcyA9IHRpbWUgLyAxMDAwO1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgaWYobGFzdFRpbWVTZWNvbmRzKXtcclxuICAgICAqICAgICAgICAgICAgIHZhciBkZWx0YVRpbWUgPSB0aW1lU2Vjb25kcyAtIGxhc3RUaW1lU2Vjb25kcztcclxuICAgICAqICAgICAgICAgICAgIHdvcmxkLnN0ZXAoZml4ZWRUaW1lU3RlcCwgZGVsdGFUaW1lLCBtYXhTdWJTdGVwcyk7XHJcbiAgICAgKiAgICAgICAgIH1cclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgIGxhc3RUaW1lU2Vjb25kcyA9IHRpbWVTZWNvbmRzO1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgcmVuZGVyQm9keShib2R5LmludGVycG9sYXRlZFBvc2l0aW9uLCBib2R5LmludGVycG9sYXRlZEFuZ2xlKTtcclxuICAgICAqICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIFN0YXJ0IGFuaW1hdGlvbiBsb29wXHJcbiAgICAgKiAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICpcclxuICAgICAqIEBzZWUgaHR0cDovL2J1bGxldHBoeXNpY3Mub3JnL21lZGlhd2lraS0xLjUuOC9pbmRleC5waHAvU3RlcHBpbmdfVGhlX1dvcmxkXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKGR0LCB0aW1lU2luY2VMYXN0Q2FsbGVkLCBtYXhTdWJTdGVwcykge1xyXG4gICAgICAgIG1heFN1YlN0ZXBzID0gbWF4U3ViU3RlcHMgfHwgMTA7XHJcbiAgICAgICAgdGltZVNpbmNlTGFzdENhbGxlZCA9IHRpbWVTaW5jZUxhc3RDYWxsZWQgfHwgMDtcclxuICAgICAgICBpZiAodGltZVNpbmNlTGFzdENhbGxlZCA9PT0gMCkgeyAvLyBGaXhlZCwgc2ltcGxlIHN0ZXBwaW5nXHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTtcclxuICAgICAgICAgICAgLy8gSW5jcmVtZW50IHRpbWVcclxuICAgICAgICAgICAgdGhpcy50aW1lICs9IGR0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hY2N1bXVsYXRvciArPSB0aW1lU2luY2VMYXN0Q2FsbGVkO1xyXG4gICAgICAgICAgICB2YXIgc3Vic3RlcHMgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5hY2N1bXVsYXRvciA+PSBkdCAmJiBzdWJzdGVwcyA8IG1heFN1YlN0ZXBzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBmaXhlZCBzdGVwcyB0byBjYXRjaCB1cFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lICs9IGR0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY2N1bXVsYXRvciAtPSBkdDtcclxuICAgICAgICAgICAgICAgIHN1YnN0ZXBzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHQgPSAodGhpcy5hY2N1bXVsYXRvciAlIGR0KSAvIGR0O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiAhPT0gdGhpcy5ib2RpZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5ib2RpZXNbal07XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5sZXJwKGIuaW50ZXJwb2xhdGVkUG9zaXRpb24sIGIucHJldmlvdXNQb3NpdGlvbiwgYi5wb3NpdGlvbiwgdCk7XHJcbiAgICAgICAgICAgICAgICBiLmludGVycG9sYXRlZEFuZ2xlID0gYi5wcmV2aW91c0FuZ2xlICsgdCAqIChiLmFuZ2xlIC0gYi5wcmV2aW91c0FuZ2xlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1ha2UgYSBmaXhlZCBzdGVwLlxyXG4gICAgICogQG1ldGhvZCBpbnRlcm5hbFN0ZXBcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gZHRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5pbnRlcm5hbFN0ZXAgPSBmdW5jdGlvbiAoZHQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xyXG4gICAgICAgIHZhciBzdGVwX21nID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGVuZE92ZXJsYXBzID0gW107XHJcbiAgICAgICAgdGhpcy5zdGVwcGluZyA9IHRydWU7XHJcbiAgICAgICAgdmFyIE5zcHJpbmdzID0gdGhpcy5zcHJpbmdzLmxlbmd0aCwgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncywgYm9kaWVzID0gdGhpcy5ib2RpZXMsIGcgPSB0aGlzLmdyYXZpdHksIHNvbHZlciA9IHRoaXMuc29sdmVyLCBOYm9kaWVzID0gdGhpcy5ib2RpZXMubGVuZ3RoLCBicm9hZHBoYXNlID0gdGhpcy5icm9hZHBoYXNlLCBucCA9IHRoaXMubmFycm93cGhhc2UsIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cywgbWcgPSBzdGVwX21nLCBhZGQgPSB2ZWMyXzEuZGVmYXVsdC5hZGQ7XHJcbiAgICAgICAgdGhpcy5vdmVybGFwS2VlcGVyLnRpY2soKTtcclxuICAgICAgICB0aGlzLmxhc3RUaW1lU3RlcCA9IGR0O1xyXG4gICAgICAgIC8vIFVwZGF0ZSBhcHByb3hpbWF0ZSBmcmljdGlvbiBncmF2aXR5LlxyXG4gICAgICAgIGlmICh0aGlzLnVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5KSB7XHJcbiAgICAgICAgICAgIHZhciBncmF2aXR5TGVuID0gdmVjMl8xLmRlZmF1bHQubGVuZ3RoKHRoaXMuZ3Jhdml0eSk7XHJcbiAgICAgICAgICAgIGlmICghKGdyYXZpdHlMZW4gPT09IDAgJiYgdGhpcy51c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9uemVybyBncmF2aXR5LiBVc2UgaXQuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uR3Jhdml0eSA9IGdyYXZpdHlMZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGdyYXZpdHkgdG8gYm9kaWVzXHJcbiAgICAgICAgaWYgKHRoaXMuYXBwbHlHcmF2aXR5KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldLCBmaSA9IGIuZm9yY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoYi50eXBlICE9PSBib2R5XzEuZGVmYXVsdC5EWU5BTUlDIHx8IGIuc2xlZXBTdGF0ZSA9PT0gYm9keV8xLmRlZmF1bHQuU0xFRVBJTkcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKG1nLCBnLCBiLm1hc3MgKiBiLmdyYXZpdHlTY2FsZSk7IC8vIEY9bSpnXHJcbiAgICAgICAgICAgICAgICBhZGQoZmksIGZpLCBtZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIHNwcmluZyBmb3JjZXNcclxuICAgICAgICBpZiAodGhpcy5hcHBseVNwcmluZ0ZvcmNlcykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTnNwcmluZ3M7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzcHJpbmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgcy5hcHBseUZvcmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYXBwbHlEYW1waW5nKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGIudHlwZSA9PT0gYm9keV8xLmRlZmF1bHQuRFlOQU1JQykge1xyXG4gICAgICAgICAgICAgICAgICAgIGIuYXBwbHlEYW1waW5nKGR0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCcm9hZHBoYXNlXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJyb2FkcGhhc2UuZ2V0Q29sbGlzaW9uUGFpcnModGhpcyk7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGlnbm9yZWQgY29sbGlzaW9uIHBhaXJzXHJcbiAgICAgICAgdmFyIGlnbm9yZWRQYWlycyA9IHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGlnbm9yZWRQYWlycy5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gcmVzdWx0Lmxlbmd0aCAtIDI7IGogPj0gMDsgaiAtPSAyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGlnbm9yZWRQYWlyc1tpXSA9PT0gcmVzdWx0W2pdICYmIGlnbm9yZWRQYWlyc1tpICsgMV0gPT09IHJlc3VsdFtqICsgMV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGlnbm9yZWRQYWlyc1tpICsgMV0gPT09IHJlc3VsdFtqXSAmJiBpZ25vcmVkUGFpcnNbaV0gPT09IHJlc3VsdFtqICsgMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNwbGljZShqLCAyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgY29uc3RyYWluZWQgcGFpcnMgd2l0aCBjb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlXHJcbiAgICAgICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYyA9IGNvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWMuY29sbGlkZUNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHJlc3VsdC5sZW5ndGggLSAyOyBqID49IDA7IGogLT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYy5ib2R5QSA9PT0gcmVzdWx0W2pdICYmIGMuYm9keUIgPT09IHJlc3VsdFtqICsgMV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjLmJvZHlCID09PSByZXN1bHRbal0gJiYgYy5ib2R5QSA9PT0gcmVzdWx0W2ogKyAxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNwbGljZShqLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcG9zdEJyb2FkcGhhc2UgZXZlbnRcclxuICAgICAgICBwb3N0QnJvYWRwaGFzZUV2ZW50LnBhaXJzID0gcmVzdWx0O1xyXG4gICAgICAgIHRoaXMuZW1pdChwb3N0QnJvYWRwaGFzZUV2ZW50KTtcclxuICAgICAgICBwb3N0QnJvYWRwaGFzZUV2ZW50LnBhaXJzID0gbnVsbDtcclxuICAgICAgICAvLyBOYXJyb3dwaGFzZVxyXG4gICAgICAgIG5wLnJlc2V0KCk7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRDb250YWN0TWF0ZXJpYWwgPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XHJcbiAgICAgICAgdmFyIGZyaWN0aW9uR3Jhdml0eSA9IHRoaXMuZnJpY3Rpb25HcmF2aXR5O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBOcmVzdWx0cyA9IHJlc3VsdC5sZW5ndGg7IGkgIT09IE5yZXN1bHRzOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdmFyIGJpID0gcmVzdWx0W2ldLCBiaiA9IHJlc3VsdFtpICsgMV07XHJcbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBhbGwgc2hhcGVzIG9mIGJvZHkgaVxyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMCwgTnNoYXBlc2kgPSBiaS5zaGFwZXMubGVuZ3RoOyBrICE9PSBOc2hhcGVzaTsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2kgPSBiaS5zaGFwZXNba10sIHhpID0gc2kucG9zaXRpb24sIGFpID0gc2kuYW5nbGU7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgc2hhcGVzIG9mIGJvZHkgalxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDAsIE5zaGFwZXNqID0gYmouc2hhcGVzLmxlbmd0aDsgbCAhPT0gTnNoYXBlc2o7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaiA9IGJqLnNoYXBlc1tsXSwgeGogPSBzai5wb3NpdGlvbiwgYWogPSBzai5hbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdE1hdGVyaWFsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2kubWF0ZXJpYWwgJiYgc2oubWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdE1hdGVyaWFsID0gdGhpcy5nZXRDb250YWN0TWF0ZXJpYWwoc2kubWF0ZXJpYWwsIHNqLm1hdGVyaWFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcnVuTmFycm93cGhhc2UodGhpcywgbnAsIGJpLCBzaSwgeGksIGFpLCBiaiwgc2osIHhqLCBhaiwgY29udGFjdE1hdGVyaWFsICE9PSBudWxsICYmIGNvbnRhY3RNYXRlcmlhbCAhPT0gdm9pZCAwID8gY29udGFjdE1hdGVyaWFsIDogZGVmYXVsdENvbnRhY3RNYXRlcmlhbCwgZnJpY3Rpb25HcmF2aXR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXYWtlIHVwIGJvZGllc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChib2R5Ll93YWtlVXBBZnRlck5hcnJvd3BoYXNlKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5Lndha2VVcCgpO1xyXG4gICAgICAgICAgICAgICAgYm9keS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVtaXQgZW5kIG92ZXJsYXAgZXZlbnRzXHJcbiAgICAgICAgaWYgKF9zdXBlci5wcm90b3R5cGUuaGFzLmNhbGwodGhpcywgXCJlbmRDb250YWN0XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3ZlcmxhcEtlZXBlci5nZXRFbmRPdmVybGFwcyhlbmRPdmVybGFwcyk7XHJcbiAgICAgICAgICAgIHZhciBlID0gZW5kQ29udGFjdEV2ZW50O1xyXG4gICAgICAgICAgICB2YXIgbCA9IGVuZE92ZXJsYXBzLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUgKGwtLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBlbmRPdmVybGFwc1tsXTtcclxuICAgICAgICAgICAgICAgIGUuc2hhcGVBID0gZGF0YS5zaGFwZUE7XHJcbiAgICAgICAgICAgICAgICBlLnNoYXBlQiA9IGRhdGEuc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgZS5ib2R5QSA9IGRhdGEuYm9keUE7XHJcbiAgICAgICAgICAgICAgICBlLmJvZHlCID0gZGF0YS5ib2R5QjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbmRPdmVybGFwcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmVTb2x2ZUV2ZW50LmNvbnRhY3RFcXVhdGlvbnMgPSBucC5jb250YWN0RXF1YXRpb25zO1xyXG4gICAgICAgIHByZVNvbHZlRXZlbnQuZnJpY3Rpb25FcXVhdGlvbnMgPSBucC5mcmljdGlvbkVxdWF0aW9ucztcclxuICAgICAgICB0aGlzLmVtaXQocHJlU29sdmVFdmVudCk7XHJcbiAgICAgICAgcHJlU29sdmVFdmVudC5jb250YWN0RXF1YXRpb25zID0gcHJlU29sdmVFdmVudC5mcmljdGlvbkVxdWF0aW9ucyA9IG51bGw7XHJcbiAgICAgICAgLy8gdXBkYXRlIGNvbnN0cmFpbnQgZXF1YXRpb25zXHJcbiAgICAgICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdHJhaW50c1tpXS51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoIHx8IG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCB8fCBOY29uc3RyYWludHMpIHtcclxuICAgICAgICAgICAgLy8gR2V0IGFsbCBlcXVhdGlvbnNcclxuICAgICAgICAgICAgdmFyIGVxdWF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICB1dGlsc18xLmRlZmF1bHQuYXBwZW5kQXJyYXkoZXF1YXRpb25zLCBucC5jb250YWN0RXF1YXRpb25zKTtcclxuICAgICAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFwcGVuZEFycmF5KGVxdWF0aW9ucywgbnAuZnJpY3Rpb25FcXVhdGlvbnMpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFwcGVuZEFycmF5KGVxdWF0aW9ucywgY29uc3RyYWludHNbaV0uZXF1YXRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc2xhbmRTcGxpdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgVW5pb25GaW5kXHJcbiAgICAgICAgICAgICAgICB2YXIgdW5pb25GaW5kID0gdGhpcy51bmlvbkZpbmQ7XHJcbiAgICAgICAgICAgICAgICB1bmlvbkZpbmQucmVzaXplKHRoaXMuYm9kaWVzLmxlbmd0aCArIDEpO1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGVxdWF0aW9uIGluZGV4XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVxdWF0aW9uc1tpXS5pbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBVbml0ZSBib2RpZXMgaWYgdGhleSBhcmUgY29ubmVjdGVkIGJ5IGFuIGVxdWF0aW9uXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5QSA9IGVxdWF0aW9uc1tpXS5ib2R5QTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keUIgPSBlcXVhdGlvbnNbaV0uYm9keUI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib2R5QSB8fCAhYm9keUIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5QS50eXBlID09PSBib2R5XzEuZGVmYXVsdC5EWU5BTUlDICYmIGJvZHlCLnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LkRZTkFNSUMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pb25GaW5kLnVuaW9uKGJvZHlBLmluZGV4LCBib2R5Qi5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgYm9keSBpc2xhbmRzXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkuaXNsYW5kSWQgPSBib2R5LnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LkRZTkFNSUMgPyB1bmlvbkZpbmQuZmluZChib2R5LmluZGV4KSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gU29ydCBlcXVhdGlvbnMgYnkgaXNsYW5kXHJcbiAgICAgICAgICAgICAgICBlcXVhdGlvbnMgPSBlcXVhdGlvbnMuc29ydChzb3J0RXF1YXRpb25zQnlJc2xhbmQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVxdWF0aW9uSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGVxdWF0aW9uSW5kZXggPCBlcXVhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVxdWF0aW9uID0gZXF1YXRpb25zW2VxdWF0aW9uSW5kZXgrK107XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9uKGVxdWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVxdWF0aW9uLmJvZHlBIHx8ICFlcXVhdGlvbi5ib2R5QilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJc2xhbmRJZCA9IGVxdWF0aW9uLmJvZHlBLmlzbGFuZElkID4gMCA/IGVxdWF0aW9uLmJvZHlBLmlzbGFuZElkIDogZXF1YXRpb24uYm9keUIuaXNsYW5kSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRJc2xhbmRJZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlaSA9IGVxdWF0aW9uc1tlcXVhdGlvbkluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVpLmJvZHlBICYmIGVpLmJvZHlCKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJc2xhbmRJZCA9ICgoX2IgPSAoX2EgPSBlaS5ib2R5QSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzbGFuZElkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSA+IDAgPyAoX2QgPSAoX2MgPSBlaS5ib2R5QSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmlzbGFuZElkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwIDogKF9mID0gKF9lID0gZWkuYm9keUIpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5pc2xhbmRJZCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRJc2xhbmRJZCAhPT0gY3VycmVudElzbGFuZElkIHx8IGVxdWF0aW9uSW5kZXggPT09IGVxdWF0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29sdmUgdGhpcyBpc2xhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc29sdmVDb25zdHJhaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29sdmVyLnNvbHZlKGR0LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x2ZXIucmVtb3ZlQWxsRXF1YXRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gU29sdmUgYWxsIGFzIG9uZSBpc2xhbmRcclxuICAgICAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbnMoZXF1YXRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvbHZlQ29uc3RyYWludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb2x2ZXIuc29sdmUoZHQsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFN0ZXAgZm9yd2FyZFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChib2R5LnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LkRZTkFNSUMgfHwgYm9keS50eXBlID09PSBib2R5XzEuZGVmYXVsdC5LSU5FTUFUSUMpIHtcclxuICAgICAgICAgICAgICAgIGJvZHkuaW50ZWdyYXRlKGR0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXNldCBmb3JjZVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgYm9kaWVzW2ldLnNldFplcm9Gb3JjZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFbWl0IGltcGFjdCBldmVudFxyXG4gICAgICAgIGlmICh0aGlzLmVtaXRJbXBhY3RFdmVudCAmJiB0aGlzLmhhcygnaW1wYWN0JykpIHtcclxuICAgICAgICAgICAgdmFyIGV2ID0gaW1wYWN0RXZlbnQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBucC5jb250YWN0RXF1YXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXEgPSBucC5jb250YWN0RXF1YXRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVxLmZpcnN0SW1wYWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYuYm9keUEgPSAoX2cgPSBlcS5ib2R5QSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBldi5ib2R5QiA9IChfaCA9IGVxLmJvZHlCKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2LnNoYXBlQSA9IGVxLnNoYXBlQTtcclxuICAgICAgICAgICAgICAgICAgICBldi5zaGFwZUIgPSBlcS5zaGFwZUI7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYuY29udGFjdEVxdWF0aW9uID0gZXE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTbGVlcGluZyB1cGRhdGVcclxuICAgICAgICBpZiAodGhpcy5zbGVlcE1vZGUgPT09IFdvcmxkLkJPRFlfU0xFRVBJTkcpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBib2RpZXNbaV0uc2xlZXBUaWNrKHRoaXMudGltZSwgZmFsc2UsIGR0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNsZWVwTW9kZSA9PT0gV29ybGQuSVNMQU5EX1NMRUVQSU5HICYmIHRoaXMuaXNsYW5kU3BsaXQpIHtcclxuICAgICAgICAgICAgLy8gVGVsbCBhbGwgYm9kaWVzIHRvIHNsZWVwIHRpY2sgYnV0IGRvbnQgc2xlZXAgeWV0XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgIT09IE5ib2RpZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUsIHRydWUsIGR0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTbGVlcCBpc2xhbmRzXHJcbiAgICAgICAgICAgIHZhciBib2RpZXNTb3J0ZWRCeUlzbGFuZCA9IGJvZGllcy5zb3J0KHNvcnRCb2RpZXNCeUlzbGFuZCk7XHJcbiAgICAgICAgICAgIHZhciBpc2xhbmRFbmQgPSAxO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpc2xhbmRTdGFydCA9IDA7IGlzbGFuZFN0YXJ0IDwgYm9kaWVzU29ydGVkQnlJc2xhbmQubGVuZ3RoOyBpc2xhbmRTdGFydCA9IGlzbGFuZEVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzbGFuZElkID0gYm9kaWVzU29ydGVkQnlJc2xhbmRbaXNsYW5kU3RhcnRdLmlzbGFuZElkO1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IGlzbGFuZEVuZCBpbmRleFxyXG4gICAgICAgICAgICAgICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xyXG4gICAgICAgICAgICAgICAgZm9yIChpc2xhbmRFbmQgPSBpc2xhbmRTdGFydCArIDE7IGlzbGFuZEVuZCA8IGJvZGllc1NvcnRlZEJ5SXNsYW5kLmxlbmd0aCAmJiBib2RpZXNTb3J0ZWRCeUlzbGFuZFtpc2xhbmRFbmRdLmlzbGFuZElkID09PSBpc2xhbmRJZDsgaXNsYW5kRW5kKyspIHsgfVxyXG4gICAgICAgICAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cclxuICAgICAgICAgICAgICAgIC8vIERvbid0IGNoZWNrIHN0YXRpYyBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNsYW5kSWQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNsYW5kU2hvdWxkU2xlZXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGlzbGFuZFN0YXJ0OyBpIDwgaXNsYW5kRW5kOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJvZGllc1NvcnRlZEJ5SXNsYW5kW2ldLndhbnRzVG9TbGVlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc2xhbmRTaG91bGRTbGVlcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNsYW5kU2hvdWxkU2xlZXApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaXNsYW5kU3RhcnQ7IGkgPCBpc2xhbmRFbmQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2RpZXNTb3J0ZWRCeUlzbGFuZFtpXS5zbGVlcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0ZXBwaW5nID0gZmFsc2U7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgcG9zdFN0ZXBFdmVudCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzcHJpbmcgdG8gdGhlIHNpbXVsYXRpb24uIE5vdGUgdGhhdCB0aGlzIG9wZXJhdGlvbiBjYW4ndCBiZSBkb25lIGR1cmluZyBzdGVwLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgYWRkU3ByaW5nXHJcbiAgICAgKiBAcGFyYW0ge1NwcmluZ30gc3ByaW5nXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5hZGRTcHJpbmcgPSBmdW5jdGlvbiAoc3ByaW5nKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RlcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcHJpbmdzIGNhbm5vdCBiZSBhZGRlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zcHJpbmdzLnB1c2goc3ByaW5nKTtcclxuICAgICAgICBhZGRTcHJpbmdFdmVudC5zcHJpbmcgPSBzcHJpbmc7XHJcbiAgICAgICAgdGhpcy5lbWl0KGFkZFNwcmluZ0V2ZW50KTtcclxuICAgICAgICBhZGRTcHJpbmdFdmVudC5zcHJpbmcgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgc3ByaW5nLiBOb3RlIHRoYXQgdGhpcyBvcGVyYXRpb24gY2FuJ3QgYmUgZG9uZSBkdXJpbmcgc3RlcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZVNwcmluZ1xyXG4gICAgICogQHBhcmFtIHtTcHJpbmd9IHNwcmluZ1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUucmVtb3ZlU3ByaW5nID0gZnVuY3Rpb24gKHNwcmluZykge1xyXG4gICAgICAgIGlmICh0aGlzLnN0ZXBwaW5nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3ByaW5ncyBjYW5ub3QgYmUgcmVtb3ZlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFycmF5UmVtb3ZlKHRoaXMuc3ByaW5ncywgc3ByaW5nKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGJvZHkgdG8gdGhlIHNpbXVsYXRpb24uIE5vdGUgdGhhdCB5b3UgY2FuJ3QgYWRkIGEgYm9keSBkdXJpbmcgc3RlcDogeW91IGhhdmUgdG8gd2FpdCB1bnRpbCBhZnRlciB0aGUgc3RlcCAoc2VlIHRoZSBwb3N0U3RlcCBldmVudCkuXHJcbiAgICAgKiBBbHNvIG5vdGUgdGhhdCBib2RpZXMgY2FuIG9ubHkgYmUgYWRkZWQgdG8gb25lIFdvcmxkIGF0IGEgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGFkZEJvZHlcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCksXHJcbiAgICAgKiAgICAgICAgIGJvZHkgPSBuZXcgQm9keSgpO1xyXG4gICAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSk7XHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5hZGRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGVwcGluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvZGllcyBjYW5ub3QgYmUgYWRkZWQgZHVyaW5nIHN0ZXAuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFscmVhZHkgYWRkZWQ/XHJcbiAgICAgICAgaWYgKGJvZHkud29ybGQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb2R5IGlzIGFscmVhZHkgYWRkZWQgdG8gYSBXb3JsZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYm9keS5pbmRleCA9IHRoaXMuYm9kaWVzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLmJvZGllcy5wdXNoKGJvZHkpO1xyXG4gICAgICAgIGJvZHkud29ybGQgPSB0aGlzO1xyXG4gICAgICAgIGFkZEJvZHlFdmVudC5ib2R5ID0gYm9keTtcclxuICAgICAgICB0aGlzLmVtaXQoYWRkQm9keUV2ZW50KTtcclxuICAgICAgICBhZGRCb2R5RXZlbnQuYm9keSA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYSBib2R5IGZyb20gdGhlIHNpbXVsYXRpb24uIE5vdGUgdGhhdCBib2RpZXMgY2Fubm90IGJlIHJlbW92ZWQgZHVyaW5nIHN0ZXAgKGZvciBleGFtcGxlLCBpbnNpZGUgdGhlIGJlZ2luQ29udGFjdCBldmVudCkuIEluIHRoYXQgY2FzZSB5b3UgbmVlZCB0byB3YWl0IHVudGlsIHRoZSBzdGVwIGlzIGRvbmUgKHNlZSB0aGUgcG9zdFN0ZXAgZXZlbnQpLlxyXG4gICAgICpcclxuICAgICAqIEFsc28gbm90ZSB0aGF0IGFueSBjb25zdHJhaW50cyBjb25uZWN0ZWQgdG8gdGhlIGJvZHkgbXVzdCBiZSByZW1vdmVkIGJlZm9yZSB0aGUgYm9keS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUJvZHlcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIHJlbW92ZUJvZHk7XHJcbiAgICAgKiAgICAgd29ybGQub24oXCJiZWdpbkNvbnRhY3RcIixmdW5jdGlvbihldmVudCl7XHJcbiAgICAgKiAgICAgICAgIC8vIFdlIGNhbm5vdCByZW1vdmUgdGhlIGJvZHkgaGVyZSBzaW5jZSB0aGUgd29ybGQgaXMgc3RpbGwgc3RlcHBpbmcuXHJcbiAgICAgKiAgICAgICAgIC8vIEluc3RlYWQsIHNjaGVkdWxlIHRoZSBib2R5IHRvIGJlIHJlbW92ZWQgYWZ0ZXIgdGhlIHN0ZXAgaXMgZG9uZS5cclxuICAgICAqICAgICAgICAgcmVtb3ZlQm9keSA9IGJvZHk7XHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgd29ybGQub24oXCJwb3N0U3RlcFwiLGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAqICAgICAgICAgaWYocmVtb3ZlQm9keSl7XHJcbiAgICAgKiAgICAgICAgICAgICAvLyBTYWZlbHkgcmVtb3ZlIHRoZSBib2R5IGZyb20gdGhlIHdvcmxkLlxyXG4gICAgICogICAgICAgICAgICAgd29ybGQucmVtb3ZlQm9keShyZW1vdmVCb2R5KTtcclxuICAgICAqICAgICAgICAgICAgIHJlbW92ZUJvZHkgPSBudWxsO1xyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5yZW1vdmVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGVwcGluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvZGllcyBjYW5ub3QgYmUgcmVtb3ZlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogd291bGQgaXQgYmUgc21hcnQgdG8gaGF2ZSBhIC5jb25zdHJhaW50cyBhcnJheSBvbiB0aGUgYm9keT9cclxuICAgICAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xyXG4gICAgICAgIHZhciBsID0gY29uc3RyYWludHMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnRzW2xdLmJvZHlBID09PSBib2R5IHx8IGNvbnN0cmFpbnRzW2xdLmJvZHlCID09PSBib2R5KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZW1vdmUgQm9keSBmcm9tIFdvcmxkOiBpdCBzdGlsbCBoYXMgY29uc3RyYWludHMgY29ubmVjdGVkIHRvIGl0LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJvZHkud29ybGQgPSBudWxsO1xyXG4gICAgICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcclxuICAgICAgICB1dGlsc18xLmRlZmF1bHQuYXJyYXlSZW1vdmUoYm9kaWVzLCBib2R5KTtcclxuICAgICAgICBib2R5LmluZGV4ID0gLTE7XHJcbiAgICAgICAgdmFyIGwgPSBib2RpZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgYm9kaWVzW2xdLmluZGV4ID0gbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRW1pdCByZW1vdmVCb2R5IGV2ZW50XHJcbiAgICAgICAgcmVtb3ZlQm9keUV2ZW50LmJvZHkgPSBib2R5O1xyXG4gICAgICAgIGJvZHkucmVzZXRDb25zdHJhaW50VmVsb2NpdHkoKTtcclxuICAgICAgICB0aGlzLmVtaXQocmVtb3ZlQm9keUV2ZW50KTtcclxuICAgICAgICByZW1vdmVCb2R5RXZlbnQuYm9keSA9IG51bGw7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGRpc2FibGVkIGJvZHkgY29sbGlzaW9uIHBhaXJzIHRoYXQgaW52b2x2ZSBib2R5XHJcbiAgICAgICAgdmFyIHBhaXJzID0gdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycztcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBwYWlycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHBhaXJzW2ldID09PSBib2R5IHx8IHBhaXJzW2kgKyAxXSA9PT0gYm9keSkge1xyXG4gICAgICAgICAgICAgICAgcGFpcnMuc3BsaWNlKGksIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgYm9keSBieSBpdHMgaWQuXHJcbiAgICAgKiBAbWV0aG9kIGdldEJvZHlCeUlkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWRcclxuICAgICAqIEByZXR1cm4ge0JvZHl9IFRoZSBib2R5LCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuZ2V0Qm9keUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChiLmlkID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNhYmxlIGNvbGxpc2lvbiBiZXR3ZWVuIHR3byBib2RpZXNcclxuICAgICAqIEBtZXRob2QgZGlzYWJsZUJvZHlDb2xsaXNpb25cclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqL1xyXG4gICAgV29ybGQucHJvdG90eXBlLmRpc2FibGVCb2R5Q29sbGlzaW9uID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnMucHVzaChib2R5QSk7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycy5wdXNoKGJvZHlCKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZSBjb2xsaXNpb25zIGJldHdlZW4gdGhlIGdpdmVuIHR3byBib2RpZXMsIGlmIHRoZXkgd2VyZSBwcmV2aW91c2x5IGRpc2FibGVkIHVzaW5nIC5kaXNhYmxlQm9keUNvbGxpc2lvbigpLlxyXG4gICAgICogQG1ldGhvZCBlbmFibGVCb2R5Q29sbGlzaW9uXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5lbmFibGVCb2R5Q29sbGlzaW9uID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgIHZhciBwYWlycyA9IHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICBpZiAoKHBhaXJzW2ldID09PSBib2R5QSAmJiBwYWlyc1tpICsgMV0gPT09IGJvZHlCKSB8fCAocGFpcnNbaSArIDFdID09PSBib2R5QSAmJiBwYWlyc1tpXSA9PT0gYm9keUIpKSB7XHJcbiAgICAgICAgICAgICAgICBwYWlycy5zcGxpY2UoaSwgMik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBib2RpZXMsIGNvbnN0cmFpbnRzLCBzcHJpbmdzLCBhbmQgY29udGFjdCBtYXRlcmlhbHMgZnJvbSB0aGUgd29ybGQuXHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBSZW1vdmUgYWxsIHNvbHZlciBlcXVhdGlvbnNcclxuICAgICAgICB0aGlzLnNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcclxuICAgICAgICAvLyBSZW1vdmUgYWxsIGNvbnN0cmFpbnRzXHJcbiAgICAgICAgdmFyIGNzID0gdGhpcy5jb25zdHJhaW50cztcclxuICAgICAgICB2YXIgaSA9IGNzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29uc3RyYWludChjc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgYm9kaWVzXHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xyXG4gICAgICAgIGkgPSBib2RpZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVCb2R5KGJvZGllc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgc3ByaW5nc1xyXG4gICAgICAgIHZhciBzcHJpbmdzID0gdGhpcy5zcHJpbmdzO1xyXG4gICAgICAgIGkgPSBzcHJpbmdzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU3ByaW5nKHNwcmluZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgYWxsIGNvbnRhY3QgbWF0ZXJpYWxzXHJcbiAgICAgICAgdmFyIGNtcyA9IHRoaXMuY29udGFjdE1hdGVyaWFscztcclxuICAgICAgICBpID0gY21zLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29udGFjdE1hdGVyaWFsKGNtc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBhIHdvcmxkIHBvaW50IG92ZXJsYXBzIGJvZGllc1xyXG4gICAgICogQG1ldGhvZCBoaXRUZXN0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gd29ybGRQb2ludCBQb2ludCB0byB1c2UgZm9yIGludGVyc2VjdGlvbiB0ZXN0c1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGJvZGllcyBBIGxpc3Qgb2Ygb2JqZWN0cyB0byBjaGVjayBmb3IgaW50ZXJzZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHByZWNpc2lvbiBVc2VkIGZvciBtYXRjaGluZyBhZ2FpbnN0IHBhcnRpY2xlcyBhbmQgbGluZXMuIEFkZHMgc29tZSBtYXJnaW4gdG8gdGhlc2UgaW5maW5pdGVzaW1hbCBvYmplY3RzLlxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGJvZGllcyB0aGF0IG92ZXJsYXAgdGhlIHBvaW50XHJcbiAgICAgKiBAdG9kbyBTaG91bGQgdXNlIGFuIGFwaSBzaW1pbGFyIHRvIHRoZSByYXljYXN0IGZ1bmN0aW9uXHJcbiAgICAgKiBAdG9kbyBTaG91bGQgcHJvYmFibHkgaW1wbGVtZW50IGEgLmNvbnRhaW5zUG9pbnQgbWV0aG9kIGZvciBhbGwgc2hhcGVzLiBXb3VsZCBiZSBtb3JlIGVmZmljaWVudFxyXG4gICAgICogQHRvZG8gU2hvdWxkIHVzZSB0aGUgYnJvYWRwaGFzZVxyXG4gICAgICogQHRvZG8gUmV0dXJuaW5nIHRoZSBoaXQgc2hhcGUgd291bGQgYmUgZmluZSAtIGl0IGNhcnJpZXMgYSByZWZlcmVuY2UgdG8gdGhlIGJvZHkgbm93XHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24gKHdvcmxkUG9pbnQsIGJvZGllcywgcHJlY2lzaW9uKSB7XHJcbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgcGFydGljbGUgYm9keSB3aXRoIGEgcGFydGljbGUgc2hhcGUgdG8gdGVzdCBhZ2FpbnN0IHRoZSBib2RpZXNcclxuICAgICAgICB2YXIgc2hhcGVXb3JsZFBvc2l0aW9uID0gaGl0VGVzdF90bXAxLCBzaGFwZUxvY2FsUG9pbnQgPSBoaXRUZXN0X3RtcDI7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIC8vIENoZWNrIGJvZGllc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBOID0gYm9kaWVzLmxlbmd0aDsgaSAhPT0gTjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgTlMgPSBib2R5LnNoYXBlcy5sZW5ndGg7IGogIT09IE5TOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IGJvZHkuc2hhcGVzW2pdO1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IGxvY2FsIHBvaW50IHBvc2l0aW9uIGluIHRoZSBzaGFwZVxyXG4gICAgICAgICAgICAgICAgc2hhcGUud29ybGRQb2ludFRvTG9jYWwoc2hhcGVMb2NhbFBvaW50LCB3b3JsZFBvaW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZS5wb2ludFRlc3Qoc2hhcGVMb2NhbFBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHNoYXBlIHdvcmxkIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHNoYXBlV29ybGRQb3NpdGlvbiwgc2hhcGUucG9zaXRpb24sIGJvZHkuYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChzaGFwZVdvcmxkUG9zaXRpb24sIHNoYXBlV29ybGRQb3NpdGlvbiwgYm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlLnR5cGUgPT09IHNoYXBlXzEuZGVmYXVsdC5QQVJUSUNMRSAmJiB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkRGlzdGFuY2Uoc2hhcGVXb3JsZFBvc2l0aW9uLCB3b3JsZFBvaW50KSA8IHByZWNpc2lvbiAqIHByZWNpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChib2R5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgc3RpZmZuZXNzIGZvciBhbGwgZXF1YXRpb25zIGFuZCBjb250YWN0IG1hdGVyaWFscy5cclxuICAgICAqIEBtZXRob2Qgc2V0R2xvYmFsU3RpZmZuZXNzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RpZmZuZXNzXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5zZXRHbG9iYWxTdGlmZm5lc3MgPSBmdW5jdGlvbiAoc3RpZmZuZXNzKSB7XHJcbiAgICAgICAgc2V0R2xvYmFsRXF1YXRpb25QYXJhbXModGhpcywgeyBzdGlmZm5lc3M6IHN0aWZmbmVzcyB9KTtcclxuICAgICAgICAvLyBTZXQgZm9yIGFsbCBjb250YWN0IG1hdGVyaWFsc1xyXG4gICAgICAgIHZhciBjb250YWN0TWF0ZXJpYWxzID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBjb250YWN0TWF0ZXJpYWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gY29udGFjdE1hdGVyaWFsc1tpXTtcclxuICAgICAgICAgICAgYy5zdGlmZm5lc3MgPSBjLmZyaWN0aW9uU3RpZmZuZXNzID0gc3RpZmZuZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZXQgZm9yIGRlZmF1bHQgY29udGFjdCBtYXRlcmlhbFxyXG4gICAgICAgIHZhciBjID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xyXG4gICAgICAgIGMuc3RpZmZuZXNzID0gYy5mcmljdGlvblN0aWZmbmVzcyA9IHN0aWZmbmVzcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcmVsYXhhdGlvbiBmb3IgYWxsIGVxdWF0aW9ucyBhbmQgY29udGFjdCBtYXRlcmlhbHMuXHJcbiAgICAgKiBAbWV0aG9kIHNldEdsb2JhbFJlbGF4YXRpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWxheGF0aW9uXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5zZXRHbG9iYWxSZWxheGF0aW9uID0gZnVuY3Rpb24gKHJlbGF4YXRpb24pIHtcclxuICAgICAgICBzZXRHbG9iYWxFcXVhdGlvblBhcmFtcyh0aGlzLCB7IHJlbGF4YXRpb246IHJlbGF4YXRpb24gfSk7XHJcbiAgICAgICAgLy8gU2V0IGZvciBhbGwgY29udGFjdCBtYXRlcmlhbHNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gdGhpcy5jb250YWN0TWF0ZXJpYWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzW2ldO1xyXG4gICAgICAgICAgICBjLnJlbGF4YXRpb24gPSBjLmZyaWN0aW9uUmVsYXhhdGlvbiA9IHJlbGF4YXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNldCBmb3IgZGVmYXVsdCBjb250YWN0IG1hdGVyaWFsXHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XHJcbiAgICAgICAgYy5yZWxheGF0aW9uID0gYy5mcmljdGlvblJlbGF4YXRpb24gPSByZWxheGF0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmF5IGNhc3QgYWdhaW5zdCBhbGwgYm9kaWVzIGluIHRoZSB3b3JsZC5cclxuICAgICAqIEBtZXRob2QgcmF5Y2FzdFxyXG4gICAgICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIHJheSA9IG5ldyBSYXkoe1xyXG4gICAgICogICAgICAgICBtb2RlOiBSYXkuQ0xPU0VTVCwgLy8gb3IgQU5ZXHJcbiAgICAgKiAgICAgICAgIGZyb206IFswLCAwXSxcclxuICAgICAqICAgICAgICAgdG86IFsxMCwgMF0sXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgdmFyIHJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XHJcbiAgICAgKiAgICAgd29ybGQucmF5Y2FzdChyZXN1bHQsIHJheSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIEdldCB0aGUgaGl0IHBvaW50XHJcbiAgICAgKiAgICAgdmFyIGhpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcclxuICAgICAqICAgICByZXN1bHQuZ2V0SGl0UG9pbnQoaGl0UG9pbnQsIHJheSk7XHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ0hpdCBwb2ludDogJywgaGl0UG9pbnRbMF0sIGhpdFBvaW50WzFdLCAnIGF0IGRpc3RhbmNlICcgKyByZXN1bHQuZ2V0SGl0RGlzdGFuY2UocmF5KSk7XHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgcmF5ID0gbmV3IFJheSh7XHJcbiAgICAgKiAgICAgICAgIG1vZGU6IFJheS5BTEwsXHJcbiAgICAgKiAgICAgICAgIGZyb206IFswLCAwXSxcclxuICAgICAqICAgICAgICAgdG86IFsxMCwgMF0sXHJcbiAgICAgKiAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihyZXN1bHQpe1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgICAgIC8vIFByaW50IHNvbWUgaW5mbyBhYm91dCB0aGUgaGl0XHJcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGl0IGJvZHkgYW5kIHNoYXBlOiAnLCByZXN1bHQuYm9keSwgcmVzdWx0LnNoYXBlKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAgICAvLyBHZXQgdGhlIGhpdCBwb2ludFxyXG4gICAgICogICAgICAgICAgICAgdmFyIGhpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcclxuICAgICAqICAgICAgICAgICAgIHJlc3VsdC5nZXRIaXRQb2ludChoaXRQb2ludCwgcmF5KTtcclxuICAgICAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaXQgcG9pbnQ6ICcsIGhpdFBvaW50WzBdLCBoaXRQb2ludFsxXSwgJyBhdCBkaXN0YW5jZSAnICsgcmVzdWx0LmdldEhpdERpc3RhbmNlKHJheSkpO1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgICAgIC8vIElmIHlvdSBhcmUgaGFwcHkgd2l0aCB0aGUgaGl0cyB5b3UgZ290IHRoaXMgZmFyLCB5b3UgY2FuIHN0b3AgdGhlIHRyYXZlcnNhbCBoZXJlOlxyXG4gICAgICogICAgICAgICAgICAgcmVzdWx0LnN0b3AoKTtcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHZhciByZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xyXG4gICAgICogICAgIHdvcmxkLnJheWNhc3QocmVzdWx0LCByYXkpO1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uIChyZXN1bHQsIHJheSkge1xyXG4gICAgICAgIHZhciB0bXBBQUJCID0gbmV3IGFhYmJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgdmFyIHRtcEFycmF5ID0gW107XHJcbiAgICAgICAgLy8gR2V0IGFsbCBib2RpZXMgd2l0aGluIHRoZSByYXkgQUFCQlxyXG4gICAgICAgIHJheS5nZXRBQUJCKHRtcEFBQkIpO1xyXG4gICAgICAgIHRoaXMuYnJvYWRwaGFzZS5hYWJiUXVlcnkodGhpcywgdG1wQUFCQiwgdG1wQXJyYXkpO1xyXG4gICAgICAgIHJheS5pbnRlcnNlY3RCb2RpZXMocmVzdWx0LCB0bXBBcnJheSk7XHJcbiAgICAgICAgdG1wQXJyYXkubGVuZ3RoID0gMDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0Lmhhc0hpdCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTmV2ZXIgZGVhY3RpdmF0ZSBib2RpZXMuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gTk9fU0xFRVBJTkdcclxuICAgICAqL1xyXG4gICAgV29ybGQuTk9fU0xFRVBJTkcgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWFjdGl2YXRlIGluZGl2aWR1YWwgYm9kaWVzIGlmIHRoZXkgYXJlIHNsZWVweS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCT0RZX1NMRUVQSU5HXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLkJPRFlfU0xFRVBJTkcgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWFjdGl2YXRlcyBib2RpZXMgdGhhdCBhcmUgaW4gY29udGFjdCwgaWYgYWxsIG9mIHRoZW0gYXJlIHNsZWVweS4gTm90ZSB0aGF0IHlvdSBtdXN0IGVuYWJsZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9pc2xhbmRTcGxpdDpwcm9wZXJ0eVwifX0uaXNsYW5kU3BsaXR7ey9jcm9zc0xpbmt9fSBmb3IgdGhpcyB0byB3b3JrLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElTTEFORF9TTEVFUElOR1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5JU0xBTkRfU0xFRVBJTkcgPSA0O1xyXG4gICAgcmV0dXJuIFdvcmxkO1xyXG59KGV2ZW50X2VtaXR0ZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFdvcmxkO1xyXG4iXX0=
(22)
});
